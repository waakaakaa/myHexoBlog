{"Asset":{"5qn5wxoulcjuzqnv":{"source":"themes/modernist/source/fancybox/blank.gif","mtime":1399382133000,"modified":true,"_id":"5qn5wxoulcjuzqnv","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/blank.gif","path":"fancybox/blank.gif"},"sntbu14qawvgvboy":{"source":"themes/modernist/source/fancybox/fancybox_loading.gif","mtime":1399382133000,"modified":true,"_id":"sntbu14qawvgvboy","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif"},"8za0aqs2xamvtbyj":{"source":"themes/modernist/source/fancybox/fancybox_overlay.png","mtime":1399382133000,"modified":true,"_id":"8za0aqs2xamvtbyj","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png"},"sq6z1k0oycsemz2m":{"source":"themes/modernist/source/fancybox/fancybox_sprite.png","mtime":1399382133000,"modified":true,"_id":"sq6z1k0oycsemz2m","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png"},"4900q7l65no4yy6t":{"source":"themes/modernist/source/fancybox/jquery.fancybox.css","mtime":1399382133000,"modified":true,"_id":"4900q7l65no4yy6t","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css"},"646yxhkv9fusi9bp":{"source":"themes/modernist/source/fancybox/jquery.fancybox.pack.js","mtime":1399382133000,"modified":true,"_id":"646yxhkv9fusi9bp","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js"},"6h341pa4wfvihp0v":{"source":"themes/modernist/source/js/gallery.js","mtime":1399382133000,"modified":true,"_id":"6h341pa4wfvihp0v","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/js/gallery.js","path":"js/gallery.js"},"61h33hr15h8x0902":{"source":"themes/modernist/source/js/jquery.imagesloaded.min.js","mtime":1399382133000,"modified":true,"_id":"61h33hr15h8x0902","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js"},"d2o110tgqyuis672":{"source":"themes/modernist/source/js/moment.min.js","mtime":1399382133000,"modified":true,"_id":"d2o110tgqyuis672","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/js/moment.min.js","path":"js/moment.min.js"},"kp6liynlsxju8qt6":{"source":"themes/modernist/source/js/scale.fix.js","mtime":1399382133000,"modified":true,"_id":"kp6liynlsxju8qt6","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/js/scale.fix.js","path":"js/scale.fix.js"},"2rrmfnqpvl67hswq":{"source":"themes/modernist/source/css/style.styl","mtime":1399382133000,"modified":true,"_id":"2rrmfnqpvl67hswq","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/style.styl","path":"css/style.styl"},"xw431rez5hhixa5o":{"source":"themes/modernist/source/css/fonts/FontAwesome.otf","mtime":1399382133000,"modified":true,"_id":"xw431rez5hhixa5o","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf"},"372rile9cnmsi9r3":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.eot","mtime":1399382133000,"modified":true,"_id":"372rile9cnmsi9r3","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot"},"q60j3mijp0li5lod":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.svg","mtime":1399382133000,"modified":true,"_id":"q60j3mijp0li5lod","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg"},"a9zhoej2n8jgs7mv":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.ttf","mtime":1399382133000,"modified":true,"_id":"a9zhoej2n8jgs7mv","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf"},"9me3n16oam05xy3t":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.woff","mtime":1399382133000,"modified":true,"_id":"9me3n16oam05xy3t","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff"},"do8twq45v4jq3ug1":{"source":"themes/modernist/source/css/images/checker.png","mtime":1399382133000,"modified":true,"_id":"do8twq45v4jq3ug1","full_source":"/Users/apple/Documents/hexo/themes/modernist/source/css/images/checker.png","path":"css/images/checker.png"}},"Cache":{"n8e05z8wfpb9sx86":{"content":"title: 'AOP 那点事儿'\ndate: 2014-05-14 15:08:13\n\n---\n又是一个周末，刚给宝宝喂完牛奶，终于让她睡着了。所以现在我才能腾出手来，坐在电脑面前给大家写这篇文章。\n\n今天我要和大家分享的是 AOP（Aspect-Oriented Programming）这个东西，名字与 OOP 仅差一个字母，其实它是对 OOP 编程方式的一种补充，并非是取而代之。翻译过来就是“面向方面编程”，可我更倾向于翻译为“面向切面编程”。它听起有些的神秘，为什么呢？当你看完这篇文章的时候，就会知道，我们做的很重要的工作就是去写这个“切面” 。那么什么是“切面”呢？\n\n没错！就是用一把刀来切一坨面。注意，相对于面而言，我们一定是横着来切它，这简称为“横切”。可以把一段代码想象成一坨面，同样也可以用一把刀来横切它，下面要做的就是如何去实现这把刀！\n\n需要澄清的是，这个概念不是由 Rod Johnson（老罗）提出的。其实很早以前就有了，目前最知名最强大的 Java 开源项目就是 AspectJ 了，然而它的前身是 AspectWerkz（该项目已经在 2005 年停止更新），这才是 AOP 的老祖宗。老罗（一个头发秃得和我老爸有一拼的天才）写了一个叫做 Spring 框架，从此一炮走红，成为了 Spring 之父。他在自己的 IOC 的基础之上，又实现了一套 AOP 的框架，后来仿佛发现自己越来越走进深渊里，在不能自拔的时候，有人建议他还是集成 AspectJ 吧，他在万般无奈之下才接受了该建议。于是，我们现在用得最多的想必就是 Spring + AspectJ 这种 AOP 框架了。\n\n那么 AOP 到底是什么？如何去使用它？本文将逐步带您进入 AOP 的世界，让您感受到前所未有的畅快！\n\n不过在开始讲解 AOP 之前，我想有必要回忆一下这段代码：\n\n**1. 写死代码**\n\n先来一个接口：\n\n\tpublic interface Greeting {\n\t\n\t    void sayHello(String name);\n\t\n\t}\n\n还有一个实现类：\n\n\tpublic class GreetingImpl implements Greeting {\n\t\n\t    @Override\n\t    public void sayHello(String name) {\n\t        before();\n\t        System.out.println(\"Hello! \" + name);\n\t        after();\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\nbefore() 与 after() 方法写死在 sayHello() 方法体中了，这样的代码的味道非常不好。如果哪位仁兄大量写了这样的代码，肯定要被你的架构师骂个够呛。\n\n比如：我们要统计每个方法的执行时间，以对性能作出评估，那是不是要在每个方法的一头一尾都做点手脚呢？\n\n再比如：我们要写一个 JDBC 程序，那是不是也要在方法的开头去连接数据库，方法的末尾去关闭数据库连接呢？\n\n这样的代码只会把程序员累死，把架构师气死！\n\n一定要想办法对上面的代码进行重构，首先给出三个解决方案：\n\n**2. 静态代理**\n\n最简单的解决方案就是使用静态代理模式了，我们单独为 GreetingImpl 这个类写一个代理类：\n\n\tpublic class GreetingProxy implements Greeting {\n\t\n\t    private GreetingImpl greetingImpl;\n\t\n\t    public GreetingProxy(GreetingImpl greetingImpl) {\n\t        this.greetingImpl = greetingImpl;\n\t    }\n\t\n\t    @Override\n\t    public void sayHello(String name) {\n\t        before();\n\t        greetingImpl.sayHello(name);\n\t        after();\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n就用这个 GreetingProxy 去代理 GreetingImpl，下面看看客户端如何来调用：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        Greeting greetingProxy = new GreetingProxy(new GreetingImpl());\n\t        greetingProxy.sayHello(\"Jack\");\n\t    }\n\t}\n\n这样写没错，但是有个问题，XxxProxy 这样的类会越来越多，如何才能将这些代理类尽可能减少呢？最好只有一个代理类。\n\n这时我们就需要使用 JDK 提供的动态代理了。 \n\n**3. JDK 动态代理**\n\n\tpublic class JDKDynamicProxy implements InvocationHandler {\n\t\n\t    private Object target;\n\t\n\t    public JDKDynamicProxy(Object target) {\n\t        this.target = target;\n\t    }\n\t\n\t    @SuppressWarnings(\"unchecked\")\n\t    public <T> T getProxy() {\n\t        return (T) Proxy.newProxyInstance(\n\t            target.getClass().getClassLoader(),\n\t            target.getClass().getInterfaces(),\n\t            this\n\t        );\n\t    }\n\t\n\t    @Override\n\t    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t        before();\n\t        Object result = method.invoke(target, args);\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n客户端是这样调用的：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getProxy();\n\t        greeting.sayHello(\"Jack\");\n\t    }\n\t}\n\n这样所有的代理类都合并到动态代理类中了，但这样做仍然存在一个问题：JDK 给我们提供的动态代理只能代理接口，而不能代理没有接口的类。有什么方法可以解决呢？\n\n**4. CGLib 动态代理**\n\n我们使用开源的 CGLib 类库可以代理没有接口的类，这样就弥补了 JDK 的不足。CGLib 动态代理类是这样玩的：\n\n\tpublic class CGLibDynamicProxy implements MethodInterceptor {\n\t\n\t    private static CGLibDynamicProxy instance = new CGLibDynamicProxy();\n\t\n\t    private CGLibDynamicProxy() {\n\t    }\n\t\n\t    public static CGLibDynamicProxy getInstance() {\n\t        return instance;\n\t    }\n\t\n\t    @SuppressWarnings(\"unchecked\")\n\t    public <T> T getProxy(Class<T> cls) {\n\t        return (T) Enhancer.create(cls, this);\n\t    }\n\t\n\t    @Override\n\t    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n\t        before();\n\t        Object result = proxy.invokeSuper(target, args);\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n以上代码中了 Singleton 模式，那么客户端调用也更加轻松了：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class);\n\t        greeting.sayHello(\"Jack\");\n\t    }\n\t}\n\n到此为止，我们能做的都做了，问题似乎全部都解决了。但事情总不会那么完美，而我们一定要追求完美！\n\n老罗搞出了一个 AOP 框架，能否做到完美而优雅呢？请大家继续往下看吧！\n\n**5. Spring AOP：前置增强、后置增强、环绕增强（编程式）**\n\n在 Spring AOP 的世界里，与 AOP 相关的术语实在太多，往往也是我们的“拦路虎”，不管是看那本书或是技术文档，在开头都要将这些术语逐个灌输给读者。我想这完全是在吓唬人了，其实没那么复杂的，大家放轻松一点。\n\n我们上面例子中提到的 before() 方法，在 Spring AOP 里就叫 Before Advice（前置增强）。有些人将 Advice 直译为“通知”，我想这是不太合适的，因为它根本就没有“通知”的含义，而是对原有代码功能的一种“增强”。再说，CGLib 中也有一个 Enhancer 类，它就是一个增强类。\n\n此外，像 after() 这样的方法就叫 After Advice（后置增强），因为它放在后面来增强代码的功能。\n\n如果能把 before() 与 after() 合并在一起，那就叫 Around Advice（环绕增强），就像汉堡一样，中间夹一根火腿。\n\n这三个概念是不是轻松地理解了呢？如果是，那就继续吧！\n\n我们下面要做的就是去实现这些所谓的“增强类”，让他们横切到代码中，而不是将这些写死在代码中。\n\n先来一个前置增强类吧：\n\n\tpublic class GreetingBeforeAdvice implements MethodBeforeAdvice {\n\t\n\t    @Override\n\t    public void before(Method method, Object[] args, Object target) throws Throwable {\n\t        System.out.println(\"Before\");\n\t    }\n\t}\n\n注意：这个类实现了 org.springframework.aop.MethodBeforeAdvice 接口，我们将需要增强的代码放入其中。\n\n再来一个后置增强类吧：\n\n\tpublic class GreetingAfterAdvice implements AfterReturningAdvice {\n\t\n\t    @Override\n\t    public void afterReturning(Object result, Method method, Object[] args, Object target) throws Throwable {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n类似地，这个类实现了 org.springframework.aop.AfterReturningAdvice 接口。\n\n最后用一个客户端来把它们集成起来，看看如何调用吧：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        ProxyFactory proxyFactory = new ProxyFactory();     // 创建代理工厂\n\t        proxyFactory.setTarget(new GreetingImpl());         // 射入目标类对象\n\t        proxyFactory.addAdvice(new GreetingBeforeAdvice()); // 添加前置增强\n\t        proxyFactory.addAdvice(new GreetingAfterAdvice());  // 添加后置增强 \n\t\n\t        Greeting greeting = (Greeting) proxyFactory.getProxy(); // 从代理工厂中获取代理\n\t        greeting.sayHello(\"Jack\");                              // 调用代理的方法\n\t    }\n\t}\n\n请仔细阅读以上代码及其注释，您会发现，其实 Spring AOP 还是挺简单的，对吗？\n\n当然，我们完全可以只定义一个增强类，让它同时实现 MethodBeforeAdvice 与 AfterReturningAdvice 这两个接口，如下：\n\n\tpublic class GreetingBeforeAndAfterAdvice implements MethodBeforeAdvice, AfterReturningAdvice {\n\t\n\t    @Override\n\t    public void before(Method method, Object[] args, Object target) throws Throwable {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    @Override\n\t    public void afterReturning(Object result, Method method, Object[] args, Object target) throws Throwable {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n这样我们只需要使用一行代码，同时就可以添加前置与后置增强：\n\n\tproxyFactory.addAdvice(new GreetingBeforeAndAfterAdvice());\n\n刚才有提到“环绕增强”，其实这个东西可以把“前置增强”与“后置增强”的功能给合并起来，无需让我们同时实现以上两个接口。\n\n\tpublic class GreetingAroundAdvice implements MethodInterceptor {\n\t\n\t    @Override\n\t    public Object invoke(MethodInvocation invocation) throws Throwable {\n\t        before();\n\t        Object result = invocation.proceed();\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n环绕增强类需要实现 org.aopalliance.intercept.MethodInterceptor 接口。注意，这个接口不是 Spring 提供的，它是 AOP 联盟（一个很牛逼的联盟）写的，Spring 只是借用了它。\n\n在客户端中同样也需要将该增强类的对象添加到代理工厂中：\n\n\tproxyFactory.addAdvice(new GreetingAroundAdvice());\n\n好了，这就是 Spring AOP 的基本用法，但这只是“编程式”而已。Spring AOP 如果只是这样，那就太傻逼了，它曾经也是一度宣传用 Spring 配置文件的方式来定义 Bean 对象，把代码中的 new 操作全部解脱出来。\n\n**6.   Spring AOP：前置增强、后置增强、环绕增强（声明式）**\n\n先看 Spring 配置文件是如何写的吧：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t       xmlns:context=\"http://www.springframework.org/schema/context\"\n\t       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t       http://www.springframework.org/schema/beans/spring-beans.xsd\n\t       http://www.springframework.org/schema/context\n\t       http://www.springframework.org/schema/context/spring-context.xsd\">\n\t\n\t    <!-- 扫描指定包（将 @Component 注解的类自动定义为 Spring Bean） -->\n\t    <context:component-scan base-package=\"aop.demo\"/>\n\t\n\t    <!-- 配置一个代理 -->\n\t    <bean id=\"greetingProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n\t        <property name=\"interfaces\" value=\"aop.Greeting\"/> <!-- 需要代理的接口 -->\n\t        <property name=\"target\" ref=\"greetingImpl\"/>       <!-- 接口实现类 -->\n\t        <property name=\"interceptorNames\">                 <!-- 拦截器名称（也就是增强类名称，Spring Bean 的 id） -->\n\t            <list>\n\t                <value>greetingAroundAdvice</value>\n\t            </list>\n\t        </property>\n\t    </bean>\n\t\n\t</beans>\n\n一定要阅读以上代码的注释，其实使用 ProxyFactoryBean 就可以取代前面的 ProxyFactory，其实它们俩就一回事儿。我认为 interceptorNames 应该改名为 adviceNames 或许会更容易让人理解，不就是往这个属性里面添加增强类吗？\n\n此外，如果只有一个增强类，可以使用以下方法来简化：\n\n\t...\n\t\n\t    <bean id=\"greetingProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n\t        <property name=\"interfaces\" value=\"aop.Greeting\"/>\n\t        <property name=\"target\" ref=\"greetingImpl\"/>\n\t        <property name=\"interceptorNames\" value=\"greetingAroundAdvice\"/> <!-- 注意这行配置 -->\n\t    </bean>\n\t\n\t...\n\n还需要注意的是，这里使用了 Spring 2.5+ 的特性“Bean 扫描”，这样我们就无需在 Spring 配置文件里不断地定义 <bean id=\"xxx\" class=\"xxx\"/> 了，从而解脱了我们的双手。\n\n看看这是有多么的简单：\n\n\t@Component\n\tpublic class GreetingImpl implements Greeting {\n\t\n\t    ...\n\t}\n\t\n\t@Component\n\tpublic class GreetingAroundAdvice implements MethodInterceptor {\n\t\n\t    ...\n\t}\n\n最后看看客户端吧：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"aop/demo/spring.xml\"); // 获取 Spring Context\n\t        Greeting greeting = (Greeting) context.getBean(\"greetingProxy\");                        // 从 Context 中根据 id 获取 Bean 对象（其实就是一个代理）\n\t        greeting.sayHello(\"Jack\");                                                              // 调用代理的方法\n\t    }\n\t}\n\n代码量确实少了，我们将配置性的代码放入配置文件，这样也有助于后期维护。更重要的是，代码只关注于业务逻辑，而将配置放入文件中。这是一条最佳实践！\n\n除了上面提到的那三类增强以外，其实还有两类增强也需要了解一下，关键的时候您要能想得到它们才行。 \n\n**7. Spring AOP：抛出增强**\n\n程序报错，抛出异常了，一般的做法是打印到控制台或日志文件中，这样很多地方都得去处理，有没有一个一劳永逸的方法呢？那就是 Throws Advice（抛出增强），它确实很强，不信你就继续往下看：\n\n\t@Component\n\tpublic class GreetingImpl implements Greeting {\n\t\n\t    @Override\n\t    public void sayHello(String name) {\n\t        System.out.println(\"Hello! \" + name);\n\t\n\t        throw new RuntimeException(\"Error\"); // 故意抛出一个异常，看看异常信息能否被拦截到\n\t    }\n\t}\n\n下面是抛出增强类的代码：\n\n\t@Component\n\tpublic class GreetingThrowAdvice implements ThrowsAdvice {\n\t\n\t    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {\n\t        System.out.println(\"---------- Throw Exception ----------\");\n\t        System.out.println(\"Target Class: \" + target.getClass().getName());\n\t        System.out.println(\"Method Name: \" + method.getName());\n\t        System.out.println(\"Exception Message: \" + e.getMessage());\n\t        System.out.println(\"-------------------------------------\");\n\t    }\n\t}\n\n抛出增强类需要实现 org.springframework.aop.ThrowsAdvice 接口，在接口方法中可获取方法、参数、目标对象、异常对象等信息。我们可以把这些信息统一写入到日志中，当然也可以持久化到数据库中。\n\n这个功能确实太棒了！但还有一个更厉害的增强。如果某个类实现了 A 接口，但没有实现 B 接口，那么该类可以调用 B 接口的方法吗？如果您没有看到下面的内容，一定不敢相信原来这是可行的！\n\n**8. Spring AOP：引入增强**\n\n以上提到的都是对方法的增强，那能否对类进行增强呢？用 AOP 的行话来讲，对方法的增强叫做 Weaving（织入），而对类的增强叫做 Introduction（引入）。而 Introduction Advice（引入增强）就是对类的功能增强，它也是 Spring AOP 提供的最后一种增强。建议您一开始千万不要去看《Spring Reference》，否则您一定会后悔的。因为当您看了以下的代码示例后，一定会彻底明白什么才是引入增强。\n\n定义了一个新接口 Apology（道歉）：\n\n\tpublic interface Apology {\n\t\n\t    void saySorry(String name);\n\t}\n\n但我不想在代码中让 GreetingImpl 直接去实现这个接口，我想在程序运行的时候动态地实现它。因为假如我实现了这个接口，那么我就一定要改写 GreetingImpl 这个类，关键是我不想改它，或许在真实场景中，这个类有1万行代码，我实在是不敢动了。于是，我需要借助 Spring 的引入增强。这个有点意思了！\n\n\t@Component\n\tpublic class GreetingIntroAdvice extends DelegatingIntroductionInterceptor implements Apology {\n\t\n\t    @Override\n\t    public Object invoke(MethodInvocation invocation) throws Throwable {\n\t        return super.invoke(invocation);\n\t    }\n\t\n\t    @Override\n\t    public void saySorry(String name) {\n\t        System.out.println(\"Sorry! \" + name);\n\t    }\n\t}\n\n以上定义了一个引入增强类，扩展了 org.springframework.aop.support.DelegatingIntroductionInterceptor 类，同时也实现了新定义的 Apology 接口。在类中首先覆盖了父类的 invoke() 方法，然后实现了 Apology 接口的方法。我就是想用这个增强类去丰富 GreetingImpl 类的功能，那么这个 GreetingImpl 类无需直接实现 Apology 接口，就可以在程序运行的时候调用 Apology 接口的方法了。这简直是太神奇的！\n\n看看是如何配置的吧：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t       xmlns:context=\"http://www.springframework.org/schema/context\"\n\t       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t       http://www.springframework.org/schema/beans/spring-beans.xsd\n\t       http://www.springframework.org/schema/context\n\t       http://www.springframework.org/schema/context/spring-context.xsd\">\n\t\n\t    <context:component-scan base-package=\"aop.demo\"/>\n\t\n\t    <bean id=\"greetingProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n\t        <property name=\"interfaces\" value=\"aop.demo.Apology\"/>          <!-- 需要动态实现的接口 -->\n\t        <property name=\"target\" ref=\"greetingImpl\"/>                    <!-- 目标类 -->\n\t        <property name=\"interceptorNames\" value=\"greetingIntroAdvice\"/> <!-- 引入增强 -->\n\t        <property name=\"proxyTargetClass\" value=\"true\"/>                <!-- 代理目标类（默认为 false，代理接口） -->\n\t    </bean>\n\t\n\t</beans>\n\n需要注意 proxyTargetClass 属性，它表明是否代理目标类，默认为 false，也就是代理接口了，此时 Spring 就用 JDK 动态代理。如果为 true，那么 Spring 就用 CGLib 动态代理。这简直就是太方便了！Spring 封装了这一切，让程序员不在关心那么多的细节。我们要向老罗同志致敬，您是我们心中永远的 idol！\n\n当您看完下面的客户端代码，一定会完全明白以上的这一切：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"aop/demo/spring.xml\");\n\t        GreetingImpl greetingImpl = (GreetingImpl) context.getBean(\"greetingProxy\"); // 注意：转型为目标类，而并非它的 Greeting 接口\n\t        greetingImpl.sayHello(\"Jack\");\n\t\n\t        Apology apology = (Apology) greetingImpl; // 将目标类强制向上转型为 Apology 接口（这是引入增强给我们带来的特性，也就是“接口动态实现”功能）\n\t        apology.saySorry(\"Jack\");\n\t    }\n\t}\n\n没想到 saySorry() 方法原来是可以被 greetingImpl 对象来直接调用的，只需将其强制转换为该接口即可。\n\n我们再次感谢 Spring AOP，感谢老罗给我们提供了这么强大的特性！\n\n其实，Spring AOP 还有很多精彩的地方，下一篇将介绍更多更有价值的 AOP 技术，让大家得到更多的收获。\n\n未完，待续...\n\n***\n\n本文是《AOP 那点事儿》的续集。\n\n在上篇中，我们从写死代码，到使用代理；从编程式 Spring AOP 到声明式 Spring AOP。一切都朝着简单实用主义的方向在发展。沿着 Spring AOP 的方向，Rod Johnson（老罗）花了不少心思，都是为了让我们使用 Spring 框架时不会感受到麻烦，但事实却并非如此。那么，后来老罗究竟对 Spring AOP 做了哪些改进呢？\n\n现在继续！\n\n**9. Spring AOP：切面**\n\n之前谈到的 AOP 框架其实可以将它理解为一个拦截器框架，但这个拦截器似乎非常武断。比如说，如果它拦截了一个类，那么它就拦截了这个类中所有的方法。类似地，当我们在使用动态代理的时候，其实也遇到了这个问题。需要在代码中对所拦截的方法名加以判断，才能过滤出我们需要拦截的方法，想想这种做法确实不太优雅。在大量的真实项目中，似乎我们只需要拦截特定的方法就行了，没必要拦截所有的方法。于是，老罗同志借助了 AOP 的一个很重要的工具，Advisor（切面），来解决这个问题。它也是 AOP 中的核心！是我们关注的重点！\n\n也就是说，我们可以通过切面，将增强类与拦截匹配条件组合在一起，然后将这个切面配置到 ProxyFactory 中，从而生成代理。\n\n这里提到这个“拦截匹配条件”在 AOP 中就叫做 Pointcut（切点），其实说白了就是一个基于表达式的拦截条件罢了。\n\n归纳一下，Advisor（切面）封装了 Advice（增强）与 Pointcut（切点 ）。当您理解了这句话后，就往下看吧。\n\n我在 GreetingImpl 类中故意增加了两个方法，都以“good”开头。下面要做的就是拦截这两个新增的方法，而对 sayHello() 方法不作拦截。\n\n\t@Component\n\tpublic class GreetingImpl implements Greeting {\n\t\n\t    @Override\n\t    public void sayHello(String name) {\n\t        System.out.println(\"Hello! \" + name);\n\t    }\n\t\n\t    public void goodMorning(String name) {\n\t        System.out.println(\"Good Morning! \" + name);\n\t    }\n\t\n\t    public void goodNight(String name) {\n\t        System.out.println(\"Good Night! \" + name);\n\t    }\n\t}\n\n在 Spring AOP 中，老罗已经给我们提供了许多切面类了，这些切面类我个人感觉最好用的就是基于正则表达式的切面类。看看您就明白了：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans ...\">\n\t\n\t    <context:component-scan base-package=\"aop.demo\"/>\n\t\n\t    <!-- 配置一个切面 -->\n\t    <bean id=\"greetingAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\n\t        <property name=\"advice\" ref=\"greetingAroundAdvice\"/>            <!-- 增强 -->\n\t        <property name=\"pattern\" value=\"aop.demo.GreetingImpl.good.*\"/> <!-- 切点（正则表达式） -->\n\t    </bean>\n\t\n\t    <!-- 配置一个代理 -->\n\t    <bean id=\"greetingProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n\t        <property name=\"target\" ref=\"greetingImpl\"/>                <!-- 目标类 -->\n\t        <property name=\"interceptorNames\" value=\"greetingAdvisor\"/> <!-- 切面 -->\n\t        <property name=\"proxyTargetClass\" value=\"true\"/>            <!-- 代理目标类 -->\n\t    </bean>\n\t\n\t</beans>\n\n注意以上代理对象的配置中的 interceptorNames，它不再是一个增强，而是一个切面，因为已经将增强封装到该切面中了。此外，切面还定义了一个切点（正则表达式），其目的是为了只将满足切点匹配条件的方法进行拦截。\n\n需要强调的是，这里的切点表达式是基于正则表达式的。示例中的“aop.demo.GreetingImpl.good.*”表达式后面的“.*”表示匹配所有字符，翻译过来就是“匹配 aop.demo.GreetingImpl 类中以 good 开头的方法”。\n\n除了 RegexpMethodPointcutAdvisor 以外，在 Spring AOP 中还提供了几个切面类，比如：\n\n* DefaultPointcutAdvisor：默认切面（可扩展它来自定义切面）\n\n* NameMatchMethodPointcutAdvisor：根据方法名称进行匹配的切面\n\n* StaticMethodMatcherPointcutAdvisor：用于匹配静态方法的切面\n\n总的来说，让用户去配置一个或少数几个代理，似乎还可以接受，但随着项目的扩大，代理配置就会越来越多，配置的重复劳动就多了，麻烦不说，还很容易出错。能否让 Spring 框架为我们自动生成代理呢？\n\n**10. Spring AOP：自动代理（扫描 Bean 名称）**\n\nSpring AOP 提供了一个可根据 Bean 名称来自动生成代理的工具，它就是 BeanNameAutoProxyCreator。是这样配置的：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans ...>\n\t\n\t    ...\n\t\n\t    <bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n\t        <property name=\"beanNames\" value=\"*Impl\"/>                       <!-- 只为后缀是“Impl”的 Bean 生成代理 -->\n\t        <property name=\"interceptorNames\" value=\"greetingAroundAdvice\"/> <!-- 增强 -->\n\t        <property name=\"optimize\" value=\"true\"/>                         <!-- 是否对代理生成策略进行优化 -->\n\t    </bean>\n\t\n\t</beans>\n\n以上使用 BeanNameAutoProxyCreator 只为后缀为“Impl”的 Bean 生成代理。需要注意的是，这个地方我们不能定义代理接口，也就是 interfaces 属性，因为我们根本就不知道这些 Bean 到底实现了多少接口。此时不能代理接口，而只能代理类。所以这里提供了一个新的配置项，它就是 optimize。若为 true 时，则可对代理生成策略进行优化（默认是 false 的）。也就是说，如果该类有接口，就代理接口（使用 JDK 动态代理）；如果没有接口，就代理类（使用 CGLib 动态代理）。而并非像之前使用的 proxyTargetClass 属性那样，强制代理类，而不考虑代理接口的方式。可见 Spring AOP 确实为我们提供了很多很好地服务！\n\n既然 CGLib 可以代理任何的类了，那为什么还要用 JDK 的动态代理呢？肯定您会这样问。\n\n根据多年来实际项目经验得知：CGLib 创建代理的速度比较慢，但创建代理后运行的速度却非常快，而 JDK 动态代理正好相反。如果在运行的时候不断地用 CGLib 去创建代理，系统的性能会大打折扣，所以建议一般在系统初始化的时候用 CGLib 去创建代理，并放入 Spring 的 ApplicationContext 中以备后用。\n\n以上这个例子只能匹配目标类，而不能进一步匹配其中指定的方法，要匹配方法，就要考虑使用切面与切点了。Spring AOP 基于切面也提供了一个自动代理生成器：DefaultAdvisorAutoProxyCreator。\n\n**11. Spring AOP：自动代理（扫描切面配置）**\n\n为了匹配目标类中的指定方法，我们仍然需要在 Spring 中配置切面与切点：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans ...>\n\t\n\t    ...\n\t\n\t    <bean id=\"greetingAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\n\t        <property name=\"pattern\" value=\"aop.demo.GreetingImpl.good.*\"/>\n\t        <property name=\"advice\" ref=\"greetingAroundAdvice\"/>\n\t    </bean>\n\t\n\t    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\">\n\t        <property name=\"optimize\" value=\"true\"/>\n\t    </bean>\n\t\n\t</beans>\n\n这里无需再配置代理了，因为代理将会由 DefaultAdvisorAutoProxyCreator 自动生成。也就是说，这个类可以扫描所有的切面类，并为其自动生成代理。\n\n看来不管怎样简化，老罗始终解决不了切面的配置，这件繁重的手工劳动。在 Spring 配置文件中，仍然会存在大量的切面配置。然而在有很多情况下 Spring AOP 所提供的切面类真的不太够用了，比如：想拦截指定注解的方法，我们就必须扩展 DefaultPointcutAdvisor 类，自定义一个切面类，然后在 Spring 配置文件中进行切面配置。不做不知道，做了您就知道相当麻烦了。\n\n老罗的解决方案似乎已经掉进了切面类的深渊，这还真是所谓的“面向切面编程”了，最重要的是切面，最麻烦的也是切面。\n\n必须要把切面配置给简化掉，Spring 才能有所突破！ \n\n神一样的老罗总算认识到了这一点，接受了网友们的建议，集成了 AspectJ，同时也保留了以上提到的切面与代理配置方式（为了兼容老的项目，更为了维护自己的面子）。将 Spring 与 AspectJ 集成与直接使用 AspectJ 是不同的，我们不需要定义 AspectJ 类（它是扩展了 Java 语法的一种新的语言，还需要特定的编译器），只需要使用 AspectJ 切点表达式即可（它是比正则表达式更加友好的表现形式）。\n\n**12. Spring + AspectJ（基于注解：通过 AspectJ execution 表达式拦截方法）**\n\n下面以一个最简单的例子，实现之前提到的环绕增强。先定义一个 Aspect 切面类：\n\n\t@Aspect\n\t@Component\n\tpublic class GreetingAspect {\n\t\n\t    @Around(\"execution(* aop.demo.GreetingImpl.*(..))\")\n\t    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n\t        before();\n\t        Object result = pjp.proceed();\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n注意：类上面标注的 @Aspect 注解，这表明该类是一个 Aspect（其实就是 Advisor）。该类无需实现任何的接口，只需定义一个方法（方法叫什么名字都无所谓），只需在方法上标注 @Around 注解，在注解中使用了 AspectJ 切点表达式。方法的参数中包括一个 ProceedingJoinPoint 对象，它在 AOP 中称为 Joinpoint（连接点），可以通过该对象获取方法的任何信息，例如：方法名、参数等。\n\n下面重点来分析一下这个切点表达式：\n\nexecution(* aop.demo.GreetingImpl.*(..))\n\nexecution()：表示拦截方法，括号中可定义需要匹配的规则。\n\n第一个“*”：表示方法的返回值是任意的。\n\n第二个“*”：表示匹配该类中所有的方法。\n\n(..)：表示方法的参数是任意的。\n\n是不是比正则表达式的可读性更强呢？如果想匹配指定的方法，只需将第二个“*”改为指定的方法名称即可。\n\n如何配置呢？看看是有多简单吧：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t       xmlns:context=\"http://www.springframework.org/schema/context\"\n\t       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t       http://www.springframework.org/schema/beans/spring-beans.xsd\n\t       http://www.springframework.org/schema/context\n\t       http://www.springframework.org/schema/context/spring-context.xsd\n\t       http://www.springframework.org/schema/aop\n\t       http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\t\n\t    <context:component-scan base-package=\"aop.demo\"/>\n\t\n\t    <aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n\t\n\t</beans>\n\n两行配置就行了，不需要配置大量的代理，更不需要配置大量的切面，真是太棒了！需要注意的是 proxy-target-class=\"true\" 属性，它的默认值是 false，默认只能代理接口（使用 JDK 动态代理），当为 true 时，才能代理目标类（使用 CGLib 动态代理）。\n\nSpring 与 AspectJ 结合的威力远远不止这些，我们来点时尚的吧，拦截指定注解的方法怎么样？\n\n**13. Spring + AspectJ（基于注解：通过 AspectJ @annotation 表达式拦截方法）** \n\n为了拦截指定的注解的方法，我们首先需要来自定义一个注解：\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Tag {\n\t}\n\n以上定义了一个 @Tag 注解，此注解可标注在方法上，在运行时生效。\n\n只需将前面的 Aspect 类的切点表达式稍作改动：\n\n\t@Aspect\n\t@Component\n\tpublic class GreetingAspect {\n\t\n\t    @Around(\"@annotation(aop.demo.Tag)\")\n\t    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n\t        ...\n\t    }\n\t\n\t    ...\n\t}\n\n这次使用了 @annotation() 表达式，只需在括号内定义需要拦截的注解名称即可。\n\n直接将 @Tag 注解定义在您想要拦截的方法上，就这么简单：\n\n\t@Component\n\tpublic class GreetingImpl implements Greeting {\n\t\n\t    @Tag\n\t    @Override\n\t    public void sayHello(String name) {\n\t        System.out.println(\"Hello! \" + name);\n\t    }\n\t}\n\n以上示例中只有一个方法，如果有多个方法，我们只想拦截其中某些时，这种解决方案会更加有价值。\n\n除了 @Around 注解外，其实还有几个相关的注解，稍微归纳一下吧：\n\n* @Before：前置增强\n\n* @After：后置增强\n\n* @Around：环绕增强\n\n* @AfterThrowing：抛出增强\n\n* @DeclareParents：引入增强\n\n此外还有一个 @AfterReturning（返回后增强），也可理解为 Finally 增强，相当于 finally 语句，它是在方法结束后执行的，也就说说，它比 @After 还要晚一些。\n\n最后一个 @DeclareParents 竟然就是引入增强！为什么不叫做 @Introduction 呢？我也不知道为什么，但它干的活就是引入增强。\n\n**14. Spring + AspectJ（引入增强）**\n\n为了实现基于 AspectJ 的引入增强，我们同样需要定义一个 Aspect 类：\n\n\t@Aspect\n\t@Component\n\tpublic class GreetingAspect {\n\t\n\t    @DeclareParents(value = \"aop.demo.GreetingImpl\", defaultImpl = ApologyImpl.class)\n\t    private Apology apology;\n\t}\n\n只需要在 Aspect 类中定义一个需要引入增强的接口，它也就是运行时需要动态实现的接口。在这个接口上标注了 @DeclareParents 注解，该注解有两个属性：\n\n* value：目标类\n\n* defaultImpl：引入接口的默认实现类\n\n我们只需要对引入的接口提供一个默认实现类即可完成引入增强：\n\n\tpublic class ApologyImpl implements Apology {\n\t\n\t    @Override\n\t    public void saySorry(String name) {\n\t        System.out.println(\"Sorry! \" + name);\n\t    }\n\t}\n\n以上这个实现会在运行时自动增强到 GreetingImpl 类中，也就是说，无需修改 GreetingImpl 类的代码，让它去实现 Apology 接口，我们单独为该接口提供一个实现类（ApologyImpl），来做 GreetingImpl 想做的事情。\n\n还是用一个客户端来尝试一下吧：\n\n\tpublic class Client {\n\t\n\t    public static void main(String[] args) {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"aop/demo/spring.xml\");\n\t        Greeting greeting = (Greeting) context.getBean(\"greetingImpl\");\n\t        greeting.sayHello(\"Jack\");\n\t\n\t        Apology apology = (Apology) greeting; // 强制转型为 Apology 接口\n\t        apology.saySorry(\"Jack\");\n\t    }\n\t}\n\n从 Spring ApplicationContext 中获取 greetingImpl 对象（其实是个代理对象），可转型为自己静态实现的接口 Greeting，也可转型为自己动态实现的接口 Apology，切换起来非常方便。\n\n使用 AspectJ 的引入增强比原来的 Spring AOP 的引入增强更加方便了，而且还可面向接口编程（以前只能面向实现类），这也算一个非常巨大的突破。\n\n这一切真的已经非常强大也非常灵活了！但仍然还是有用户不能尝试这些特性，因为他们还在使用 JDK 1.4（根本就没有注解这个东西），怎么办呢？没想到 Spring AOP 为那些遗留系统也考虑到了。\n\n**15. Spring + AspectJ（基于配置）**\n\n除了使用 @Aspect 注解来定义切面类以外，Spring AOP 也提供了基于配置的方式来定义切面类：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans ...\">\n\t\n\t    <bean id=\"greetingImpl\" class=\"aop.demo.GreetingImpl\"/>\n\t\n\t    <bean id=\"greetingAspect\" class=\"aop.demo.GreetingAspect\"/>\n\t\n\t    <aop:config>\n\t        <aop:aspect ref=\"greetingAspect\">\n\t            <aop:around method=\"around\" pointcut=\"execution(* aop.demo.GreetingImpl.*(..))\"/>\n\t        </aop:aspect>\n\t    </aop:config>\n\t\n\t</beans>\n\n使用 <aop:config> 元素来进行 AOP 配置，在其子元素中配置切面，包括增强类型、目标方法、切点等信息。\n\n无论您是不能使用注解，还是不愿意使用注解，Spring AOP 都能为您提供全方位的服务。\n\n好了，我所知道的比较实用的 AOP 技术都在这里了，当然还有一些更为高级的特性，由于个人精力有限，这里就不再深入了。\n\n还是依照惯例，给一张牛逼的高清无码思维导图，总结一下以上各个知识点：\n\n![image](http://waakaakaa.qiniudn.com/111332_5YL3_223750.png)\n\n最后给一张 UML 类图描述一下 Spring AOP 的整体架构：\n\n![image](http://waakaakaa.qiniudn.com/235319_GQUH_223750.png)","mtime":1400053027000,"source":"source/_posts/aop-那点事儿.md","_id":"n8e05z8wfpb9sx86"},"qrrt578n0zlko5up":{"content":"title: 'Every Programmer Should Know These Latency Numbers'\ndate: 2014-05-14 11:56:45\n\n---\n### Latency numbers every programmer should know\n    L1 cache reference ......................... 0.5 ns\n    Branch mispredict ............................ 5 ns\n    L2 cache reference ........................... 7 ns\n    Mutex lock/unlock ........................... 25 ns\n    Main memory reference ...................... 100 ns\n    Compress 1K bytes with Zippy ............. 3,000 ns = 3 µs\n    Send 2K bytes over 1 Gbps network ....... 20,000 ns = 20 µs\n    SSD random read ........................ 150,000 ns = 150 µs\n    Read 1 MB sequentially from memory ..... 250,000 ns = 250 µs\n    Round trip within same datacenter ...... 500,000 ns = 0.5 ms\n    Read 1 MB sequentially from SSD* ..... 1,000,000 ns = 1 ms\n    Disk seek ........................... 10,000,000 ns = 10 ms\n    Read 1 MB sequentially from disk .... 20,000,000 ns = 20 ms\n    Send packet CA->Netherlands->CA .... 150,000,000 ns = 150 ms\n\nAssuming ~1GB/sec SSD\n\n![Visual representation of latencies](http://i.imgur.com/k0t1e.png)\n\nVisual chart provided by [ayshen](https://gist.github.com/ayshen)\n\nData by [Jeff Dean](http://research.google.com/people/jeff/)\n\nOriginally by [Peter Norvig](http://norvig.com/21-days.html#answers)\n\nLets multiply all these durations by a billion:\n\nMagnitudes:\n\n### Minute:\n    L1 cache reference 0.5 s One heart beat (0.5 s)\n    Branch mispredict 5 s Yawn\n    L2 cache reference 7 s Long yawn\n    Mutex lock/unlock 25 s Making a coffee\n\n### Hour:\n    Main memory reference 100 s Brushing your teeth\n    Compress 1K bytes with Zippy 50 min One episode of a TV show (including ad breaks)\n\n### Day:\n    Send 2K bytes over 1 Gbps network 5.5 hr From lunch to end of work day\n\n### Week\n    SSD random read 1.7 days A normal weekend\n    Read 1 MB sequentially from memory 2.9 days A long weekend\n    Round trip within same datacenter 5.8 days A medium vacation\n    Read 1 MB sequentially from SSD 11.6 days Waiting for almost 2 weeks for a delivery\n\n### Year\n    Disk seek 16.5 weeks A semester in university\n    Read 1 MB sequentially from disk 7.8 months Almost producing a new human being\n    The above 2 together 1 year\n\n### Decade\n    Send packet CA->Netherlands->CA 4.8 years Average time it takes to complete a bachelor's degree\n\n","mtime":1400039891000,"source":"source/_posts/every-programmer-should-know-these-latency-numbers.md","_id":"qrrt578n0zlko5up"},"d4kyu3x36fn3ql6o":{"content":"title: 'Java 处理 XML 的三种主流技术及介绍'\ndate: 2014-05-14 12:38:14\n\n---\nXML (Extensible Markup Language) 意为可扩展标记语言，它已经是软件开发行业中大多数程序员和厂商用以选择作为数据传输的载体。本文作者对于 Java 处理 XML 的几种主流技术进行一些总结和介绍，希望帮助那些有不同需求的开发人员对于 XML 处理技术的作出最优的选择。\n\n最初，XML 语言仅仅是意图用来作为 HTML 语言的替代品而出现的，但是随着该语言的不断发展和完善，人们越来越发现它所具有的优点：例如标记语言可扩展，严格的语法规定，可使用有意义的标记，内容 存储和表现分离等等优势注定了该语言从诞生之日起就会走向辉煌。 XML 语言在成为 W3C 标准之后进入到了一个快速发展的时期，当然它本身所具有的一系列优点和优势也注定了各大技术厂商对它的偏爱，Java 作为软件行业的一种开发技术也迅速作出了反应，出现了多种对 XML 支持的工具，本文将会从这个角度对 Java 处理 XML 的几种主流技术进行介绍，希望能对您有所帮助。在这篇文章中，您将会得到以下信息：\n\n1. Java 提供了哪些优秀的类库及工具便于程序员对 XML 进行处理 ?\n2. 有了 DOM 了，其它工具类库还有必要么 ?\n3. 几个小例程带你快速了解这三种解析方式\n\nJava 有哪些优秀的类库及工具便于程序员对 XML 进行处理 ?\n\n* 大名鼎鼎的 DOM\n* 绿色环保的 SAX\n* 默默无闻的 Digester\n\nXML 三种解析方式简介\n===\n\n大名鼎鼎的 DOM\n\n说它大名鼎鼎可是一点不为过，DOM 是 W3C 处理 XML 的标准 API，它是许多其它与 XML 处理相关的标准的基础，不仅是 Java，其它诸如 Javascript，PHP，MS .NET 等等语言都实现了该标准， 成为了应用最为广泛的 XML 处理方式。当然，为了能提供更多更加强大的功能，Java 对于 DOM 直接扩展工具类有很多，比如很多 Java 程序员耳熟能详的 JDOM，DOM4J 等等， 它们基本上属于对 DOM 接口功能的扩充，保留了很多 DOM API 的特性，许多原本的 DOM 程序员甚至都没有任何障碍就熟练掌握了另外两者的使用，直观、易于操作的方式使它深受广大 Java 程序员的喜爱。\n\n绿色环保的 SAX\n\nSAX 的应运而生有它特殊的需要，为什么说它绿色环保呢，这是因为 SAX 使用了最少的系统资源和最快速的解析方式对 XML 处理提供了支持。 但随之而来繁琐的查找方式也给广大程序员带来许多困扰，常常令人头痛不已，同时它对 XPath 查询功能的支持，令人们对它又爱又恨。\n\n默默无闻的 Digester：XML 的 JavaBean 化\n\nDigester 是 apache 基金组织下的一个开源项目，笔者对它的了解源于对 Struts 框架的研究，是否有很多程序员想要一解各大开源框架的设计甚至想要自己写一个功能强大的框架时会碰到这样一个难题： 这些形形色色的用 XML 语言标记的框架配置文件，框架底层是用什么技术来解析呢？ DOM 解析耗费时间，SAX 解析又过于繁琐，况且每次解析系统开销也会过大， 于是，大家想到需要用与 XML 结构相对应的 JavaBean 来装载这些信息，由此 Digester 应运而生。它的出现为 XML 转换为 JavaBean 对象的需求带来了方便的操作接口，使得更多的类似需求得到了比较完美的解决方法， 不再需要程序员自己实现此类繁琐的解析程序了。与此同时 SUN 也推出了 XML 和 JavaBean 转换工具类 JAXB，有兴趣的读者可以自行了解。\n\n三种解析方式比较\n===\n\nDOM\n\n优缺点：实现 W3C 标准，有多种编程语言支持这种解析方式，并且这种方法本身操作上简单快捷，十分易于初学者掌握。其处理方式是将 XML 整个作为类似树结构的方式读入内存中以便操作及解析，因此支持应用程序对 XML 数据的内容和结构进行修改，但是同时由于其需要在处理开始时将整个 XML 文件读入到内存中去进行分析，因此其在解析大数据量的 XML 文件时会遇到类似于内存泄露以及程序崩溃的风险，请对这点多加注意。\n\n适用范围：小型 XML 文件解析、需要全解析或者大部分解析 XML、需要修改 XML 树内容以生成自己的对象模型\n\nSAX\n\nSAX 从根本上解决了 DOM 在解析 XML 文档时产生的占用大量资源的问题。其实现是通过类似于流解析的技术，通读整个 XML 文档树，通过事件处理器来响应程序员对于 XML 数据解析的需求。由于其不需要将整个 XML 文档读入内存当中，它对系统资源的节省是十分显而易见的，它在一些需要处理大型 XML 文档以及性能要求较高的场合有起了十分重要的作用。支持 XPath 查询的 SAX 使得开发人员更加灵活，处理起 XML 来更加的得心应手。但是同时，其仍然有一些不足之处也困扰广大的开发人员：首先是它十分复杂的 API 接口令人望而生畏，其次由于其是属于类似流解析的文件扫描方式，因此不支持应用程序对于 XML 树内容结构等的修改，可能会有不便之处。\n\n适用范围：大型 XML 文件解析、只需要部分解析或者只想取得部分 XML 树内容、有 XPath 查询需求、有自己生成特定 XML 树对象模型的需求\n\nDigester/JAXB\n\n优缺点 : 由于其是在上述两者的基础上衍生出来的工具类，为的是满足将 XML 转换为 JavaBean 的特殊需求，故而没有什么特别明显的优缺点。作为大名鼎鼎的开源框架 Struts 的 XML 解析工具 Digester，为我们带来了将 XML 转换为 JavaBean 的可靠方法。\n\n适用范围 : 有将 XML 文档直接转换为 JavaBean 需求。\n\n应用示例\n\n下面给出一段用于解析的 XML 片段：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n\t <books> \n\t   <book id=\"001\"> \n\t      <title>Harry Potter</title> \n\t      <author>J K. Rowling</author> \n\t   </book> \n\t   <book id=\"002\"> \n\t      <title>Learning XML</title> \n\t      <author>Erik T. Ray</author> \n\t   </book> \n\t </books> \n\nDOM 解析 XML\n===\n\nJava 中的 DOM 接口简介： JDK 中的 DOM API 遵循 W3C DOM 规范，其中 org.w3c.dom 包提供了 Document、DocumentType、Node、NodeList、Element 等接口， 这些接口均是访问 DOM 文档所必须的。我们可以利用这些接口创建、遍历、修改 DOM 文档。\n\njavax.xml.parsers 包中的 DoumentBuilder 和 DocumentBuilderFactory 用于解析 XML 文档生成对应的 DOM Document 对象。\n\njavax.xml.transform.dom 和 javax.xml.transform.stream 包中 DOMSource 类和 StreamSource 类，用于将更新后的 DOM 文档写入 XML 文件。\n\n下面给出一个运用 DOM 解析 XML 的例子：\n\n\timport java.io.File; \n\t import java.io.IOException; \n\t import javax.xml.parsers.DocumentBuilder; \n\t import javax.xml.parsers.DocumentBuilderFactory; \n\t import javax.xml.parsers.ParserConfigurationException; \n\t import org.w3c.dom.Document; \n\t import org.w3c.dom.Element; \n\t import org.w3c.dom.Node; \n\t import org.w3c.dom.NodeList; \n\t import org.xml.sax.SAXException; \n\n\t public class DOMParser { \n\t   DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); \n\t   //Load and parse XML file into DOM \n\t   public Document parse(String filePath) { \n\t      Document document = null; \n\t      try { \n\t         //DOM parser instance \n\t         DocumentBuilder builder = builderFactory.newDocumentBuilder(); \n\t         //parse an XML file into a DOM tree \n\t         document = builder.parse(new File(filePath)); \n\t      } catch (ParserConfigurationException e) { \n\t         e.printStackTrace();  \n\t      } catch (SAXException e) { \n\t         e.printStackTrace(); \n\t      } catch (IOException e) { \n\t         e.printStackTrace(); \n\t      } \n\t      return document; \n\t   } \n\t\n\t   public static void main(String[] args) { \n\t         DOMParser parser = new DOMParser(); \n\t         Document document = parser.parse(\"books.xml\"); \n\t         //get root element \n\t         Element rootElement = document.getDocumentElement(); \n\n\t         //traverse child elements \n\t         NodeList nodes = rootElement.getChildNodes(); \n\t         for (int i=0; i < nodes.getLength(); i++) \n\t         { \n\t            Node node = nodes.item(i); \n\t            if (node.getNodeType() == Node.ELEMENT_NODE) {   \n\t               Element child = (Element) node; \n\t               //process child element \n\t            } \n\t         } \n\n\t         NodeList nodeList = rootElement.getElementsByTagName(\"book\"); \n\t         if(nodeList != null) \n\t         { \n\t            for (int i = 0 ; i < nodeList.getLength(); i++) \n\t            {\n\t            \tElement element = (Element)nodeList.item(i); \n\t\t\t\t\tString id = element.getAttribute(\"id\"); \n\t            } \n\t         } \n\t   } \n\t } \n \n在上面的例子中，DOMParser 的 Parse() 方法负责解析 XML 文件并生成对应的 DOM Document 对象。其中 DocumentBuilderFactory 用于生成 DOM 文档解析器以便解析 XML 文档。 在获取了 XML 文件对应的 Document 对象之后，我们可以调用一系列的 API 方便的对文档对象模型中的元素进行访问和处理。 需要注意的是调用 Element 对象的 getChildNodes() 方法时将返回其下所有的子节点，其中包括空白节点，因此需要在处理子 Element 之前对节点类型加以判断。\n\n可以看出 DOM 解析 XML 易于开发，只需要通过解析器建立起 XML 对应的 DOM 树型结构后便可以方便的使用 API 对节点进行访问和处理，支持节点的删除和修改等。 但是 DOM 解析 XML 文件时会将整个 XML 文件的内容解析成树型结构存放在内存中，因此不适合用 DOM 解析很大的 XML 文件。\n\nSAX 解析 XML\n===\n\n与 DOM 建立树形结构的方式不同，SAX 采用事件模型来解析 XML 文档，是解析 XML 文档的一种更快速、更轻量的方法。 利用 SAX 可以对 XML 文档进行有选择的解析和访问，而不必像 DOM 那样加载整个文档，因此它对内存的要求较低。 但 SAX 对 XML 文档的解析为一次性读取，不创建任何文档对象，很难同时访问文档中的多处数据。\n\n下面是一个 SAX 解析 XML 的例子：\n\n\timport org.xml.sax.Attributes; \n\t import org.xml.sax.SAXException; \n\t import org.xml.sax.XMLReader; \n\t import org.xml.sax.helpers.DefaultHandler; \n\t import org.xml.sax.helpers.XMLReaderFactory; \n\n\t public class SAXParser { \n\n\t   class BookHandler extends DefaultHandler { \n\t      private List<String> nameList; \n\t      private boolean title = false; \n   \n\t      public List<String> getNameList() { \n\t\t\treturn nameList; \n\t      } \n\t      // Called at start of an XML document \n\t      @Override \n\t      public void startDocument() throws SAXException { \n\t         System.out.println(\"Start parsing document...\"); \n\t         nameList = new ArrayList<String>(); \n\t      } \n\t      // Called at end of an XML document \n\t      @Override \n\t      public void endDocument() throws SAXException {  \n\t         System.out.println(\"End\");  \n\t      } \n      \n\t      /** \n\t       * Start processing of an element. \n\t       * @param namespaceURI  Namespace URI \n\t       * @param localName  The local name, without prefix \n\t       * @param qName  The qualified name, with prefix \n\t       * @param atts  The attributes of the element \n\t       */ \n\t      @Override \n\t      public void startElement(String uri, String localName, String qName, \n\t\t     Attributes atts) throws SAXException { \n\t         // Using qualified name because we are not using xmlns prefixes here. \n\t         if (qName.equals(\"title\")) { \n\t            title = true; \n\t         } \n\t      } \n   \n\t      @Override \n\t      public void endElement(String namespaceURI, String localName, String qName) \n\t      \t throws SAXException { \n\t         // End of processing current element \n\t         if (title) { \n\t            title = false; \n\t         } \n\t      } \n   \t\t\t\n\t      @Override \n\t      public void characters(char[] ch, int start, int length) { \n\t         // Processing character data inside an element \n\t         if (title) { \n\t            String bookTitle = new String(ch, start, length); \n\t            System.out.println(\"Book title: \" + bookTitle); \n\t            nameList.add(bookTitle); \n\t         } \n\t      } \t\t\t\n\t   } \n\t\n\t   public static void main(String[] args) throws SAXException, IOException { \n\t      XMLReader parser = XMLReaderFactory.createXMLReader(); \n\t      BookHandler bookHandler = (new SAXParser()).new BookHandler(); \n\t      parser.setContentHandler(bookHandler); \n\t      parser.parse(\"books.xml\"); \n\t      System.out.println(bookHandler.getNameList()); \n\t   } \n\t } \n \nSAX 解析器接口和事件处理器接口定义在 org.xml.sax 包中。主要的接口包括 ContentHandler、DTDHandler、EntityResolver 及 ErrorHandler。 其中 ContentHandler 是主要的处理器接口，用于处理基本的文档解析事件；DTDHandler 和 EntityResolver 接口用于处理与 DTD 验证和实体解析相关的事件； ErrorHandler 是基本的错误处理接口。DefaultHandler 类实现了上述四个事件处理接口。上面的例子中 BookHandler 继承了 DefaultHandler 类， 并覆盖了其中的五个回调方法 startDocument()、endDocument()、startElement()、endElement() 及 characters() 以加入自己的事件处理逻辑。\n\nDigester 解析 XML\n===\n\n为了满足将 XML 转换为 JavaBean 的特殊需求，Apache 旗下的一个名为 Digester 的工具为我们提供了这么一个选择。由于最终是将 XML 转化为 JavaBean 存储在内存当中， 故而解析性能等方面其实与使用者并没有多大关系。解析的关键在于用以匹配 XML 的模式以及规则等，由于该工具较为复杂，限于篇幅，作者只能给予简单的介绍。\n\n下面是一个 Digester 解析 XML 的例子片段：\n\n\t// 定义要解析的 XML 的路径，并初始化工具类\n\tFile input = new File(\"books.xml\"); \n\tDigester digester = new Digester(); \n\n\t// 如果碰到了 <books> 这个标签，应该初始化 test.myBean.Books 这个 JavaBean 并填装相关内容\n\tdigester.addObjectCreate(\"books\", \"test.myBean.Books\"); \n\tdigester.addSetProperties(\"books\"); \n\t// 如果碰到了 <books/book> 这个标签，同上初始化 test.myBean.Book 这个 JavaBean \n\tdigester.addObjectCreate(\"books/book\", \"test.myBean.Book\"); \n\tdigester.addSetProperties(\"books/book\"); \n\t// 通过调用上面已经初始化过的 JavaBean 的 addBook() 方法来把多个 <books/book> 加到一个集合中\n\tdigester.addSetNext(\"books/book\", \"addBook\", \"test.myBean.Book\"); \n\n\t// 定义好了上面的解析规则后，就可以开始进行解析工作了\n\tBooks books = (Books) digester.parse(input); \n\n上述代码简单的向读者展示了 Digester 处理 XML 的一些要点，主要是说明了一些模式以及规则的匹配。 简言之，Digester 就是一种用来把一个 XML 转化为一个与该 XML 结构类似的 JavaBean。你可以把 XML 根元素想象成一个 JavaBean， 该根元素的 attribute 就是这个 JavaBean 的各种 Field，当该根元素有其他子 tag 时，又要把这个子 tag 想象成一个个新的 XML，将其视为一个新的 JavaBean， 并作为一个 Field 加入到父 Bean 当中，然后以此类推，通过循环的方式将整个 XML 进行解析。\n\n\n结束语\n===\n\n本文介绍了 Java 解析 XML 的三种常用技术，其中 DOM 易于上手，程序易于理解，但缺点在于占用内存大，不适合于解析较大的 XML 文件； SAX 基于事件模型占用系统资源少，能够胜任较大的 XML 文件解析，但解析过程较为繁琐查找元素不方便； Digester/JAXB 基于上述两种技术衍生而来。文中的实例向读者展示了三种 API 的基本使用方法， 在实际开发过程中使用那种技术解析 XML 更好要依据各自的优缺点视具体情况而定。\n原文出处：[IBM developerWorks](http://www.ibm.com/developerworks/cn/xml/dm-1208gub/index.html) ","mtime":1400042943000,"source":"source/_posts/java-处理-xml-的三种主流技术及介绍.md","_id":"d4kyu3x36fn3ql6o"},"bv2qytgp11ckcr2q":{"content":"title: about\ndate: 2014-05-07 16:17:33\n---\n","mtime":1399450653000,"source":"source/about/index.md","_id":"bv2qytgp11ckcr2q"},"nuqfnek547qnzih3":{"content":"title: 'Proxy 那点事儿'\ndate: 2014-05-14 15:02:44\n\n---\nProxy，也就是“代理”了。意思就是，你不用去做，别人代替你去处理。比如说：赚钱方面，我就是我老婆的 Proxy；带小孩方面，我老婆就是我的 Proxy；家务事方面，没有 Proxy。 \n\n它在程序开发中起到了非常重要的作用，比如传说中的 AOP（面向切面编程），就是针对代理的一种应用。此外，在设计模式中，还有一个“代理模式”。在公司里要上外网，要在浏览器里设置一个 HTTP 代理。wocao，代理无处不在啊，不搞明白，岂不是很没面子？\n\n凡是都要由浅入深，学习也不例外。先来一个 Hello World 吧： \n\n\tpublic interface Hello {\n\t\n\t    void say(String name);\n\t}\n\n这是一个 Hello 接口，不用解释了，大家都懂的。赶紧上实现类吧：\n\n\tpublic class HelloImpl implements Hello {\n\t\n\t    @Override\n\t    public void say(String name) {\n\t        System.out.println(\"Hello! \" + name);\n\t    }\n\t}\n\nwocao！这简直就是 So easy 嘛！但是有个问题：如果要在 println() 方法前面和后面分别需要处理一些逻辑，怎么做呢？把这些逻辑写死在 say() 方法里面吗？肯定不够优雅啦，菜鸟一般这样干，作为一名资深的程序员，我坚决不能这样做！\n\n我要用代理！写一个 HelloProxy 类，让它去调用 HelloImpl 的 say() 方法，在调用的前后分别进行逻辑处理不就行了吗？赶紧搞一个吧：\n\n\tpublic class HelloProxy implements Hello {\n\t\n\t    private HelloImpl helloImpl;\n\t\n\t    public HelloProxy() {\n\t        helloImpl = new HelloImpl();\n\t    }\n\t\n\t    @Override\n\t    public void say(String name) {\n\t        before();\n\t        helloImpl.say(name);\n\t        after();\n\t    }\n\t\n\t    private void before() {\n\t        System.out.println(\"Before\");\n\t    }\n\t\n\t    private void after() {\n\t        System.out.println(\"After\");\n\t    }\n\t}\n\n我将 HelloProxy 类实现了 Hello 接口（和 HelloImpl 实现相同的接口），并且在构造方法中 new 出一个 HelloImpl 类的实例。这样一来，我就可以在 HelloProxy 的 say() 方法里面去调用 HelloImpl 的 say() 方法了。更重要的是，我还可以在调用的前后分别加上 before() 与 after() 方法，在这两个方法里去实现那些前后逻辑。\n\n用一个 main 方法来测试一下吧：\n\n\tpublic static void main(String[] args) {\n\t    Hello helloProxy = new HelloProxy();\n\t    helloProxy.say(\"Jack\");\n\t}\n\n运行后，打印出：\n\n\tBefore\n\tHello! Jack\n\tAfter\n\n轻而易举，我就写出了这么优雅的代码（暗自小嗨了一把）。\n\n不久后，我在一本设计模式的书上看到，原来我写的这个 HelloProxy 就是所谓的“代理模式”啊！我只能说，自己和 GoF（四人帮）的距离有接近了一点。 \n\n于是我疯狂的使用“代理模式”，项目中到处都有 XxxProxy 的声影。直到有一天，架构师看到了我的代码，他惊呆了！他对我说：“你怎么这么喜欢用静态代理呢？你就不会用动态代理吗？给我全都重构了！”。\n\n我表面上点了点头，说：“好的！”。其实我根本都不知道什么是“静态代理”，什么又是“动态代理”。我继续翻开我那本垫桌脚的设计模式，深入得研究了一番，最后我才明白，原来我一直用的都是“静态代理”啊，怪不得架构师说我到处都是 XxxProxy 类了。我好恨我自己！一定要将这些垃圾 Proxy 都重构为“动态代理”。\n\n于是我就是用 JDK 给我们提供的动态代理方案，写了一个 DynamicProxy：\n\n\tpublic class DynamicProxy implements InvocationHandler {\n\t\n\t    private Object target;\n\t\n\t    public DynamicProxy(Object target) {\n\t        this.target = target;\n\t    }\n\t\n\t    @Override\n\t    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t        before();\n\t        Object result = method.invoke(target, args);\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    ...\n\t}\n\n在 DynamicProxy 类中，我定义了一个 Object 类型的 target 变量，它就是被代理的目标对象，通过构造函数来初始化（现在流行叫“注入”了，我觉得叫“射入”也不错哦！构造函数初始化叫“正着射”，所以 reflect 方式就叫“反着射”，简称“反射”）。\n\n言归正传，DynamicProxy 实现了 InvocationHandler 接口，那么必须实现该接口的 invoke 方法，参数不做解释，望文生义吧，是 JRE 给我们“射”进来的。在该方法中，直接通过反射去 invoke method，在调用前后分别处理 before 与 after，最后将 result 返回。\n\n写一个 main() 方法看看实际怎么用吧：\n\n\tpublic static void main(String[] args) {\n\t    Hello hello = new HelloImpl();\n\t\n\t    DynamicProxy dynamicProxy = new DynamicProxy(hello);\n\t\n\t    Hello helloProxy = (Hello) Proxy.newProxyInstance(\n\t        hello.getClass().getClassLoader(),\n\t        hello.getClass().getInterfaces(),\n\t        dynamicProxy\n\t    );\n\t\n\t    helloProxy.say(\"Jack\");\n\t}\n\n没错，意思就是，用我写的这个通用的 DynamicProxy 类去包装 HelloImpl 实例，然后再调用 JDK 给我们提供的 Proxy 类的工厂方法 newProxyInstance() 去动态地创建一个 Hello 接口的代理类，最后调用这个代理类的 say() 方法。\n\n运行一下，结果和以前一样，动态代理成功了。其实，动态代理就是帮我们自动生成 XxxProxy 类的法宝啊！\n\n要注意的是，Proxy.newProxyInstance() 方法的参数实在是让我“蛋碎一地”！\n\n参数1：ClassLoader\n参数2：该实现类的所有接口\n参数3：动态代理对象\n\n调用完了还要来一个强制类型转换一下。\n\nwocao！这一坨 shi 一定要想办法封装一下，避免再次发生到处都是 Proxy.newProxyInstance()，这样架构师又要骂我了。于是我将这个 DynamicProxy 重构了：\n\n\tpublic class DynamicProxy implements InvocationHandler {\n\t\n\t    ...\n\t\n\t    @SuppressWarnings(\"unchecked\")\n\t    public <T> T getProxy() {\n\t        return (T) Proxy.newProxyInstance(\n\t            target.getClass().getClassLoader(),\n\t            target.getClass().getInterfaces(),\n\t            this\n\t        );\n\t    }\n\t\n\t    ...\n\t}\n\n我在 DynamicProxy 里添加了一个 getProxy() 方法，无需传入任何参数，将刚才所说的那一坨 shi，放在这个方法中，并且该方法返回一个泛型类型，就不会强制类型转换了。方法头上加那个 @SuppressWarnings(\"unchecked\") 注解表示忽略编译时的警告（因为 Proxy.newProxyInstance() 方法返回的是一个 Object，这里我强制转换为 T 了，这是向下转型，IDE 中就会有警告，编译时也会出现提示，很烦）。\n\n好了，这下子使用 DynamicProxy 就简单了吧：\n\n\tpublic static void main(String[] args) {\n\t    DynamicProxy dynamicProxy = new DynamicProxy(new HelloImpl());\n\t    Hello helloProxy = dynamicProxy.getProxy();\n\t\n\t    helloProxy.say(\"Jack\");\n\t}\n\n确实简单用 2 行代理就去掉了前面的 7 行代码（省了 5 行），架构师看到了这样的代码肯定会表扬我！\n\n经过一番代码重构后，我提交了所有的代码，架构师看到了，没有吱声…… 可我总算学会了动态代理。\n\n用了这个 DynamicProxy 以后，我觉得它还是非常爽的，爽的地方是，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，实现类还要动，代理类也要动。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有勇武之地了！这就是 JDK 给我们提供的动态代理，让我不知道该说什么了。\n\n于是我又开始调研，能否代理没有接口的类呢？终于让我找到了这颗“银弹”！那就是 CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。说起来好高深，实际用起来一点都不难。我再搞一个 CGLibProxy 吧：\n\n\tpublic class CGLibProxy implements MethodInterceptor {\n\t\n\t    public <T> T getProxy(Class<T> cls) {\n\t          return (T) Enhancer.create(cls, this);\n\t    }\n\t\n\t    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n\t        before();\n\t        Object result = proxy.invokeSuper(obj, args);\n\t        after();\n\t        return result;\n\t    }\n\t\n\t    ...\n\t}\n\n需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。这个功能对于我们这群屌丝程序员而言，如同雪中送炭啊，此乃神器也！我们直接调用 proxy 的 invokeSuper() 方法，将被代理的对象 obj 以及方法参数 args 传入其中即可。\n\n与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧：\n\n\tpublic static void main(String[] args) {\n\t    CGLibProxy cgLibProxy = new CGLibProxy();\n\t    HelloImpl helloProxy = cgLibProxy.getProxy(HelloImpl.class);\n\t\n\t    helloProxy.say(\"Jack\");\n\t}\n\n仍然通过 2 行代码就可以返回代理对象了，与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象（不管它是“屌丝”还是“高富帅”）。说它是神器，过分吗？\n\n我一向都是以追求完美而著称，2 行代码返回代理对象，我觉得还是有些多余，我不想总是去 new 这个 CGLibProxy 对象，最好 new 一次，以后随时拿随时用。于是我想到了“单例模式”：\n\n\tpublic class CGLibProxy implements MethodInterceptor {\n\t\n\t    private static CGLibProxy instance = new CGLibProxy();\n\t\n\t    private CGLibProxy() {\n\t    }\n\t\n\t    public static CGLibProxy getInstance() {\n\t        return instance;\n\t    }\n\t\n\t    ...\n\t}\n\n我加了以上几行代码，就搞定了！需要说明的是：这里有一个 private 的构造方法，就是为了限制外界不能再去 new 它了，换句话说，我在这里把它给“阉”了。\n\n用一个 main() 方法来证明我的简单主义思想：\n\n\tpublic static void main(String[] args) {\n\t    HelloImpl helloImpl = CGLibProxy.getInstance().getProxy(HelloImpl.class);\n\t\n\t    helloImpl.say(\"Jack\");\n\t}\n\n没错吧？只需 1 行代码就可以获取代理对象了！\n\n总结一下，我们今天谈到了无代理、静态代理、JDK 动态代理、CGLib 动态代理，其实代理的世界远不止这么小，还有很多实际的应用场景。本文一开始谈到的 AOP 是一个最为典型的案例，所以有必要再进行继续下去。\n\n我的宝宝突然尿了，在那里狂哭，我得去换块尿布了，老婆这个 Proxy 还是靠不住啊！\n\n今天就到此为止，祝大家有个美好的周末！同样也期待您的留言。","mtime":1400051266000,"source":"source/_posts/proxy-那点事儿.md","_id":"nuqfnek547qnzih3"},"fk7mvehpxq1c6655":{"content":"title: TCP三次握手/四次挥手详解\ndate: 2014-05-14 15:51:16\n\n---\n**一，TCP(Transmission Control Protocol)　传输控制协议**\n\n\nTCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:\n\n**二，三次握手过程**\n\n第一次握手：主机A发送位码为SYN＝1，随机产生seq =X 的数据包到服务器，主机B由SYN=1知道，A要求建立联机。（A处于SYN - SENT，B处于LISTEN）\n\n![image](http://waakaakaa.qiniudn.com/021331_vUTD_264328.png)\n\n第二次握手： 主机B收到请求（根据SYN=1）后要确认联机信息，向A发送ack =(X+1),SYN=1,ACK=1,随机产生seq=Y的包 。（B处于SYN -- RECEIVED）\n\n![image](http://waakaakaa.qiniudn.com/021343_N70t_264328.png)\n\n第三次握手：主机A收到后检查ack是否正确，即第一次发送的seq+1,以及位码ACK是否为1，若正确，主机A会再发送ack =(Y+1),ACK=1，主机B收到后确认seq值与ack=1则连接建立成功。（记住此时SYN！=1）  （A发送完ESTABLISHED，B接受到为ESTABLISHED）\n\n![image](http://waakaakaa.qiniudn.com/021354_IPUM_264328.png)\n\n完成三次握手，主机A与主机B开始传送数据。一个完整的三次握手也就是 请求---应答---再次确认\n\n**三，四次挥手：**\n\n由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。\n\n收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n\n1. 客户端A发送一个FIN=1，用来关闭客户A到服务器B的数据传送。  （此时A处于FIN - WAIT-1，等待B的FIN=1）\n\n2. 服务器B收到这个FIN=1，它发回一个ACK=1，确认序号：X+1。   （此时B处于CLOSE - WAIT-1）\n\n3. 服务器B发送完数据，发送一个FIN=1给客户端A。（此时B处于LAST - ACK，A处于FIN - WAIT-2）\n\n4. 客户端A发回ACK=1报文确认，并将确认序号设置为收到序号加1   （此时A处于TIME - WAIT，B处于CLOSEED）\n\n**四，问题汇总**\n\n**1\\. 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**\n\n这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。\n\n但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送，但未必所有的数据都全部发送给对方，所以你未必会马上关闭SOCKET，也即你可能还需要发送一些数据给对方，之后再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。\n\n**2\\. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？**\n\n这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；\n\n但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。\n\n**3\\. 什么是2MSL**\n\nMSL是Maximum Segment Lifetime,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n因为TCP报文（segment）是IP数据报（datagram）的数据部分，而IP头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。\n\nRFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等\n\n2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间。\n\n等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。\n\n在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。\n\n当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。\n\nTTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。\n\n**4\\. SYN攻击**\n\n在三次握手过程中，服务器【发送SYN-ACK之后，收到客户端的ACK之前】的TCP连接称为半连接(half-open connect)。此时服务器处于SYN_RECV状态，当收到ACK后，服务器转入ESTABLISHED状态.\n\nSYN攻击就是：攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复ACK确认包，并等待客户的确认从而建立连接。由于源地址是不存在的，不会再发送ACK确认包，所以服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。\n\nSYN攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。\n\n在Linux下可以如下命令检测是否被Syn攻击：netstat  -n  -p  TCP | grep SYN_RECV\n\n一般较新的TCP/IP协议栈都对这一过程进行修正来防范SYN攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等。但是不能完全防范syn攻击。","mtime":1400054268000,"source":"source/_posts/tcp三次握手四次挥手详解.md","_id":"fk7mvehpxq1c6655"},"waiojthhd2w3pcub":{"content":"title: 'ThoughtWorks(中国) 程序员读书雷达'\ndate: 2014-05-14 14:13:08\n\n---\n![image](http://waakaakaa.qiniudn.com/reading-radar.jpg)\n\n软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。\n\nThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。\n\n现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。\n\n该读书雷达将书籍分为了如下四个维度：\n\n>Coding Practice（编程实践）\n\n>Architecture & Design（架构与设计）\n\n>Methodology（方法学）\n\n>Thought & Leadership（思想与领导力）\n\n我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。\n\n每个维度皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。\n\n或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，”吾生也有涯，而知也无涯”，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodolog（方法学）维度，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于我和刘龙军还不够擅长的领域，我们不敢也不愿做出可能误导人的推荐。\n\n本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。\n\n我将在后面的文章中，根据每个维度为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示(感谢凯峰为这个雷达图建立的豆列，可以访问[ThoughtWorks(中国)程序员读书雷达](http://book.douban.com/doulist/2012097/))：\n\n**Coding Practice | 编程实践**\n\n基础篇\n\n>Clean Code《代码整洁之道》\n\n>Pragmatic Unit Testing《单元测试之道》\n\n>The Productive Programmer《卓有成效的程序员》\n\n>Test-Driven Development By Example《测试驱动开发》\n\n>Clean Coder《程序员的职业修养》\n\n>The Art of Readable Code《编写可读代码的艺术》\n\n进阶篇\n\n>Refactoring To Patterns《重构与模式》\n\n>Implementation Patterns《实现模式》\n\n>Code Completed《代码大全》\n\n>The Pragmatic Programmer《程序员修炼之道》\n\n高级篇\n\n>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》\n\n>Working Effectively with Legacy Code《修改代码的艺术》\n\n**Architecture & Design | 架构与设计**\n\n基础篇\n\n>Agile Software Development 《敏捷软件开发：原则、实践与模式》\n\n>Head First Design Patterns《深入浅出设计模式》\n\n>Design Patterns 《设计模式》\n\n进阶篇\n\n>The Art of UNIX Programming 《Unix编程艺术》\n\n>Practical API Design 《框架设计的艺术》\n\n>Domain Specific Languages 《领域特定语言》\n\n>Patterns of Enterprise Application Architecture 《企业应用架构模式》\n\n高级篇\n\n>Release It \n\n>Domain-Driven Design 《领域驱动设计》\n\n>Enterprise Integration Patterns《企业集成模式》\n\n>Beautiful Architecture《架构之美》\n\n>Pattern-Oriented Software Architecture《面向模式的软件架构》\n\n**Methodology | 方法学**\n\n基础篇\n\n>User Stories Applied《用户故事与敏捷方法》\n\n>The Gold Mine《金矿》\n\n>Scrum and XP From the Trenches《硝烟中的Scrum和XP》\n\n>Continuous Integration《持续集成》\n\n>Extreme Programming Explained《解析极限编程》\n\n进阶篇\n\n>Lean Thinking《精益思想》\n\n>Continuous Delivery《持续交付》\n\n>How Google Tests Software\n\n>Agile Testing\n\n>Extreme Programming Refactored《重构极限编程》\n\n高级篇\n\n>Specification By Example\n\n**Thought & Leadership | 思想与领导力**\n\n基础篇\n\n>The Effective Executive《卓有成效的管理者》\n\n>Are Your Lights On?《你的灯亮着吗》\n\n>Becoming A Technical Leader《成为技术领导者》\n\n进阶篇\n\n>The Fifth Discipline《第五项修炼》\n\n>The Design Of Business\n\n>Management 3.0《管理3.0：培养和提升敏捷领导力》\n\n>Presentation To Win\n\n>The McKinsey Way《麦肯锡方法》\n\n高级篇\n\n>Thinking, Fast and Slow《思考快与慢》","mtime":1400048276000,"source":"source/_posts/thoughtworks(中国)-程序员读书雷达.md","_id":"waiojthhd2w3pcub"},"a6lxjozb2of2wih8":{"content":"title: 'Peter Norvig：编程语言的选择并不重要'\ndate: 2014-05-14 11:49:25\n\n---\n![image](http://waakaakaa.qiniudn.com/58_101020040205_1.jpg)\n\nLisp被许多资深程序员视为编程语言中的圣杯，因为学起来很难。著名程序员、最热门的技术问答网站StackOverflow创始人Joel Spolsky曾经在[“Java语言学校的危险性”](http://www.ruanyifeng.com/blog/2008/12/the_perils_of_javaschools.html)一 文中说，自己当年在大学里学习用Lisp的导论课程也是苦不堪言，而Lisp这样的函数式语言实际开发中并不常用，但是一旦到了体现优势的时候，你如果不 懂，将失之千里。他还认为，Google的核心技术之一MapReduce就来自函数式语言，而且使Google领先微软多年。请注意，Spolsky曾 经1990年代微软的Excel项目经理，VBA的主要创造者。\n\n《Unix编程艺术》的作者Eric Raymond也在[“如何成为黑客”](http://www.aka.org.cn/Docs/hacker-howto_2001.html)（英文版）中说过，Lisp是对黑客特别重要的语言，“掌握了之后，你会得到丰富的启迪和经验。 即使实际上很少使用Lisp，这些经验也会使你在以后的日子里成为更好的程序员。”\n\n而Paul Graham更是Lisp的头号吹鼓手，他曾与蠕虫病毒发明者Robert Morris一起，成功地用Lisp开发历史上第一个Web应用——ViaWeb，并高价卖给Yahoo致富。他在2001年写了一篇宣传Lisp的名文“[Beating the Averages](http://www.paulgraham.com/avg.html)”（英文），其中说到：“Lisp之所以极为优秀，并不是因为只有铁杆粉丝才知道的某些魔术般的性质，而在于它确实是最强大的编程语言。大家不用它的原因，在于编程语言不只是技术，而且也是思维习惯，这是改变起来最慢的东西。”\n\n有意思的是，美国时间10月18日，著名技术新闻网站Hacker News上，名为kung-fu-master的用户发了一篇名为[“问PG: Lisp与Python (2010)”](http://news.ycombinator.com/item?id=1803351)的帖子，内容很简单：“好像许多Lisp老枪都开始转而用Python的（比如Peter Norvig）。今天你怎么看Lisp与Python？”\n\n这里的PG就是指Hacker News的创始人、著名Lisp程序员与吹鼓手Paul Graham。而其中提到的Peter Norvig则是另一个著名Lisp程序员，现任Google研发总监。他有一篇经典的文章[“十年学会编程”](http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html)（英文版），相信大家都已经看过，他的首选推荐语言当然也是Lisp（更准确的说是Lisp的方言Scheme）。\n\n面对这样直接的问题，专家们是怎么回答的呢？\n\nPaul Graham说：\n\n \n\n>这问题好像来自2005年而不是2010年。Lisp现在由于Clojure（Lisp的现代方言，可以运行在JVM和.NET上——CSDN编者注）的出现，已经又变得时髦了。当然Python也有很好的库，但是我觉得用缺乏宏的语言编程很受局限。\n\n许多网友对Python没有宏的问题进行了讨论。有人说不支持宏是出于代码可读性的考虑。而更多的人则认同宏是一种抽象工具，任何工具都会被误用、滥用，但并不表示工具本身有问题。\n\n另一Lisp专家，《Coder at Work》和《Practical Common Lisp》作者>Peter Seibel也加入了讨论（他最近忙于编辑一种杂志Code Quarterly）。他说：自己与Peter Norvig有类似的体验。虽然自己Lisp非常熟练，但是在表达算法方面Python是最佳选择。不过，相比Lisp实现，CPython的运行速度慢得惊人，甚至差5-10倍。\n\n而Peter Norvig也罕见地现出真身，给出了自己的回答，内容一如既往地经典：\n\n \n\n>我是Peter Norvig。我转向Python不是因为它比Lisp更好、更令人满意、更实用，而是因为它用作伪代码更合适。许多学生说，在《人工智能》 （Norvig与Russell合著的经典教材）一书中的伪代码与我们在网上提供的Lisp代码之间进行转换太难了。于是我要寻找一种更近似伪代码的语 言，发现Python是最合适的。然后我就自学了Python，熟练到足以实现教材中示例的地步。我发现Python对于一些类型的小问题非常合适，有些 库也是我与其他的一些代码（包括在Google内和网上其他地方的代码）集成非常需要的。 我认为Lisp对更大的项目和编译速度很重要的应用而言仍然具有优势。但是在主要目的是交流而非编程的时候（比如针对数量众多的学生），Python更有 优势。\n\n就更一般意义上的编程而言，在Google和其他地方，我认为语言的选择并不如其他方面的选择那么重要：如果你有了正确的总体架构、正确的程序员团队、正确的开发过程（能够快速开发、持续改善），那么很多语言都能胜任；但如果以上的东西你没有，那无论选择什么语言，你都会陷入一团糟。\n\n还有人找出今年2月Norvig在一次采访（无法直接访问）中类似的话，透露了Google内部的一些信息：\n\n \n\n1. Google最开始似乎核心程序员都是用C++的，效率很高。这部分形成了公司的文化。\n\n2. Google早期的Lisp程序员(Erann Gat) 注意到其他程序员和自己的效率差不多，甚至更好。关键还是在人，与20年前相比，现在语言的选择不那么重要了。\n\n3. Lisp是为单个程序员或者一小组程序员进行探索性工作而专门设计的……如果我想自己在周末修改代码，会更愿意用Lisp，但是如果有几百个程序员一起改代码，那就不是编程语言的问题，而是社会问题了。\n\n4. 库。\n\n其他人举出的材料中，最有意思的应该来自Lisp之父、计算机科学巨人约翰麦卡锡。[这篇博客](http://smuglispweeny.blogspot.com/2008/02/ooh-ooh-my-turn-why-lisp.html)（无法直接访问）里生动讲述了这位图灵奖得主在某次听Peter Norvig改而鼓吹Python的演讲后的情景：\n\n \n\nNorvig演讲后，进入提问环节。出乎我的意料，他点了一位皱巴巴的老头。老头的胡子和头发都花白了，而且乱糟糟的，看 上去像是来此参观但是迷路了，到这里来休息一下，好奇地听听我们在说什么。我第一个念头是，估计他已经被这么艰深的话题弄晕了。但是马上想到，不对啊，这 里离斯坦福很近，这老头的年纪也对，难道是……\n\n只听Norvig说：“是，John，你有什么问题？”我记不清Lisp之父当时怎么问的了，但不超过十个词，就是问 Python是否能如Lisp那样优雅地像数据一样处理代码。“不，John，不行。”Norvig回答，然后静等麦卡锡继续发问。但是，老人什么也没有 再说。此时真是无言胜千语啊……\n\n看来，在大师眼中，数据与代码等同处理是最重要的语言特性之一。他还曾经在访谈中这样评价Ruby（提问者说Ruby从Lisp中借鉴了很多）：“Ruby能像数据那样使用列表结构吗？那每次算加和减的时候，都得进行解析啰？这方面Ruby还不如1960年的Lisp。”","mtime":1400039723000,"source":"source/_posts/peter-norvig：编程语言的选择并不重要.md","_id":"a6lxjozb2of2wih8"},"du7o5ukunnqy3hfq":{"content":"# Mou\n\n![Mou icon](http://mouapp.com/Mou_128.png)\n\n## Overview\n\n**Mou**, the missing Markdown editor for *web developers*.\n\n<!--more-->\n\n### Syntax\n\n#### Strong and Emphasize \n\n**strong** or __strong__ ( Cmd + B )\n\n*emphasize* or _emphasize_ ( Cmd + I )\n\n**Sometimes I want a lot of text to be bold.\nLike, seriously, a _LOT_ of text**\n\n#### Blockquotes\n\n> Right angle brackets &gt; are used for block quotes.\n\n#### Links and Email\n\nAn email <example@example.com> link.\n\nSimple inline link <http://chenluois.com>, another inline link [Smaller](http://smallerapp.com), one more inline link with title [Resize](http://resizesafari.com \"a Safari extension\").\n\nA [reference style][id] link. Input id, then anywhere in the doc, define the link with corresponding id:\n\n[id]: http://mouapp.com \"Markdown editor on Mac OS X\"\n\nTitles ( or called tool tips ) in the links are optional.\n\n#### Images\n\nAn inline image ![Smaller icon](http://smallerapp.com/favicon.ico \"Title here\"), title is optional.\n\nA ![Resize icon][2] reference style image.\n\n[2]: http://resizesafari.com/favicon.ico \"Title\"\n\n#### Inline code and Block code\n\nInline code are surround by `backtick` key. To create a block code:\n\n\tIndent each line by at least 1 tab, or 4 spaces.\n    var Mou = exactlyTheAppIwant; \n\n####  Ordered Lists\n\nOrdered lists are created using \"1.\" + Space:\n\n1. Ordered list item\n2. Ordered list item\n3. Ordered list item\n\n#### Unordered Lists\n\nUnordered list are created using \"*\" + Space:\n\n* Unordered list item\n* Unordered list item\n* Unordered list item \n\nOr using \"-\" + Space:\n\n- Unordered list item\n- Unordered list item\n- Unordered list item\n\n#### Hard Linebreak\n\nEnd a line with two or more spaces will create a hard linebreak, called `<br />` in HTML. ( Control + Return )  \nAbove line ended with 2 spaces.\n\n#### Horizontal Rules\n\nThree or more asterisks or dashes:\n\n***\n\n---\n\n- - - -\n\n#### Headers\n\nSetext-style:\n\nThis is H1\n==========\n\nThis is H2\n----------\n\natx-style:\n\n# This is H1\n## This is H2\n### This is H3\n#### This is H4\n##### This is H5\n###### This is H6\n\n\n### Extra Syntax\n\n#### Footnotes\n\nFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this:\n\nThat's some text with a footnote.[^1]\n\n[^1]: And that's the footnote.\n\n\n#### Strikethrough\n\nWrap with 2 tilde characters:\n\n~~Strikethrough~~\n\n\n#### Fenced Code Blocks\n\nStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks:\n\n```\nFenced code blocks are like Stardard Markdown’s regular code\nblocks, except that they’re not indented and instead rely on\na start and end fence lines to delimit the code block.\n```\n\n#### Tables\n\nA simple table looks like this:\n\nFirst Header | Second Header | Third Header\n------------ | ------------- | ------------\nContent Cell | Content Cell  | Content Cell\nContent Cell | Content Cell  | Content Cell\n\nIf you wish, you can add a leading and tailing pipe to each line of the table:\n\n| First Header | Second Header | Third Header |\n| ------------ | ------------- | ------------ |\n| Content Cell | Content Cell  | Content Cell |\n| Content Cell | Content Cell  | Content Cell |\n\nSpecify alignement for each column by adding colons to separator lines:\n\nFirst Header | Second Header | Third Header\n:----------- | :-----------: | -----------:\nLeft         | Center        | Right\nLeft         | Center        | Right\n\n\n### Shortcuts\n\n#### View\n\n* Toggle live preview: Shift + Cmd + I\n* Toggle Words Counter: Shift + Cmd + W\n* Toggle Transparent: Shift + Cmd + T\n* Toggle Floating: Shift + Cmd + F\n* Left/Right = 1/1: Cmd + 0\n* Left/Right = 3/1: Cmd + +\n* Left/Right = 1/3: Cmd + -\n* Toggle Writing orientation: Cmd + L\n* Toggle fullscreen: Control + Cmd + F\n\n#### Actions\n\n* Copy HTML: Option + Cmd + C\n* Strong: Select text, Cmd + B\n* Emphasize: Select text, Cmd + I\n* Inline Code: Select text, Cmd + K\n* Strikethrough: Select text, Cmd + U\n* Link: Select text, Control + Shift + L\n* Image: Select text, Control + Shift + I\n* Select Word: Control + Option + W\n* Select Line: Shift + Cmd + L\n* Select All: Cmd + A\n* Deselect All: Cmd + D\n* Convert to Uppercase: Select text, Control + U\n* Convert to Lowercase: Select text, Control + Shift + U\n* Convert to Titlecase: Select text, Control + Option + U\n* Convert to List: Select lines, Control + L\n* Convert to Blockquote: Select lines, Control + Q\n* Convert to H1: Cmd + 1\n* Convert to H2: Cmd + 2\n* Convert to H3: Cmd + 3\n* Convert to H4: Cmd + 4\n* Convert to H5: Cmd + 5\n* Convert to H6: Cmd + 6\n* Convert Spaces to Tabs: Control + [\n* Convert Tabs to Spaces: Control + ]\n* Insert Current Date: Control + Shift + 1\n* Insert Current Time: Control + Shift + 2\n* Insert entity <: Control + Shift + ,\n* Insert entity >: Control + Shift + .\n* Insert entity &: Control + Shift + 7\n* Insert entity Space: Control + Shift + Space\n* Insert Scriptogr.am Header: Control + Shift + G\n* Shift Line Left: Select lines, Cmd + [\n* Shift Line Right: Select lines, Cmd + ]\n* New Line: Cmd + Return\n* Comment: Cmd + /\n* Hard Linebreak: Control + Return\n\n#### Edit\n\n* Auto complete current word: Esc\n* Find: Cmd + F\n* Close find bar: Esc\n\n#### Post\n\n* Post on Scriptogr.am: Control + Shift + S\n* Post on Tumblr: Control + Shift + T\n\n#### Export\n\n* Export HTML: Option + Cmd + E\n* Export PDF:  Option + Cmd + P\n\n\n### And more?\n\nDon't forget to check Preferences, lots of useful options are there.\n\nFollow [@chenluois](http://twitter.com/chenluois) on Twitter for the latest news.\n\nFor feedback, use the menu `Help` - `Send Feedback`","mtime":1399454009000,"source":"source/_posts/introduction-to-mou.md","_id":"du7o5ukunnqy3hfq"},"b32eipvny32fqc1m":{"content":"title: 'ThreadLocal 那点事儿'\ndate: 2014-05-14 14:51:37\n\n---\nThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。\n\n早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的，只不过设计得有些难用，所以至今没有得到广泛使用。其实它还是挺有用的，不相信的话，我们一起来看看这个例子吧。\n\n一个序列号生成器的程序，可能同时会有多个线程并发访问它，要保证每个线程得到的序列号都是自增的，而不能相互干扰。\n\n先定义一个接口：\n\n\tpublic interface Sequence {\n\t\n\t    int getNumber();\n\t}\n\n每次调用 getNumber() 方法可获取一个序列号，下次再调用时，序列号会自增。\n\n再做一个线程类：\n\n\tpublic class ClientThread extends Thread {\n\t\n\t    private Sequence sequence;\n\t\n\t    public ClientThread(Sequence sequence) {\n\t        this.sequence = sequence;\n\t    }\n\t\n\t    @Override\n\t    public void run() {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" => \" + sequence.getNumber());\n\t\t\t}\n\t    }\n\t}\n\n在线程中连续输出三次线程名与其对应的序列号。\n\n我们先不用 ThreadLocal，来做一个实现类吧。\n\n\tpublic class SequenceA implements Sequence {\n\t\n\t    private static int number = 0;\n\t\n\t    public int getNumber() {\n\t        number = number + 1;\n\t        return number;\n\t    }\n\t\n\t    public static void main(String[] args) {\n\t        Sequence sequence = new SequenceA();\n\t\n\t        ClientThread thread1 = new ClientThread(sequence);\n\t        ClientThread thread2 = new ClientThread(sequence);\n\t        ClientThread thread3 = new ClientThread(sequence);\n\t\n\t        thread1.start();\n\t        thread2.start();\n\t        thread3.start();\n\t    }\n\t}\n\n序列号初始值是0，在 main() 方法中模拟了三个线程，运行后结果如下：\n\n\tThread-0 => 1\n\tThread-0 => 2\n\tThread-0 => 3\n\tThread-2 => 4\n\tThread-2 => 5\n\tThread-2 => 6\n\tThread-1 => 7\n\tThread-1 => 8\n\tThread-1 => 9\n\n由于线程启动顺序是随机的，所以并不是0、1、2这样的顺序，这个好理解。为什么当 Thread-0 输出了1、2、3之后，而 Thread-2 却输出了4、5、6呢？线程之间竟然共享了 static 变量！这就是所谓的“非线程安全”问题了。\n\n那么如何来保证“线程安全”呢？对应于这个案例，就是说不同的线程可拥有自己的 static 变量，如何实现呢？下面看看另外一个实现吧。\n\n\tpublic class SequenceB implements Sequence {\n\t\n\t\tprivate static ThreadLocal<Integer> numberContainer = new ThreadLocal<Integer>() {\n\t\t\t@Override\n\t\t\tprotected Integer initialValue() {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t};\n\t\n\tpublic int getNumber() {\n\t\t numberContainer.set(numberContainer.get() + 1);\n\t\t return numberContainer.get();\n\t }\n\t\n\t public static void main(String[] args) {\n\t\t Sequence sequence = new SequenceB();\n\t\n\t\t ClientThread thread1 = new ClientThread(sequence);\n\t \t ClientThread thread2 = new ClientThread(sequence);\n\t\t ClientThread thread3 = new ClientThread(sequence);\n\t\n\t\t thread1.start();\n\t\t thread2.start();\n\t\t thread3.start();\n\t\t}\n\t}\n\n通过 ThreadLocal 封装了一个 Integer 类型的 numberContainer 静态成员变量，并且初始值是0。再看 getNumber() 方法，首先从 numberContainer 中 get 出当前的值，加1，随后 set 到 numberContainer 中，最后将 numberContainer 中 get 出当前的值并返回。\n\n是不是很恶心？但是很强大！确实稍微饶了一下，我们不妨把 ThreadLocal 看成是一个容器，这样理解就简单了。所以，这里故意用 Container 这个单词作为后缀来命名 ThreadLocal 变量。\n\n运行结果如何呢？看看吧。\n\n\tThread-0 => 1\n\tThread-0 => 2\n\tThread-0 => 3\n\tThread-2 => 1\n\tThread-2 => 2\n\tThread-2 => 3\n\tThread-1 => 1\n\tThread-1 => 2\n\tThread-1 => 3\n\n每个线程相互独立了，同样是 static 变量，对于不同的线程而言，它没有被共享，而是每个线程各一份，这样也就保证了线程安全。 也就是说，TheadLocal 为每一个线程提供了一个独立的副本！\n\n搞清楚 ThreadLocal 的原理之后，有必要总结一下 ThreadLocal 的 API，其实很简单。\n\n1. public void set(T value)：将值放入线程局部变量中\n2. public T get()：从线程局部变量中获取值\n3. public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）\n4. protected T initialValue()：返回线程局部变量中的初始值（默认为 null） \n\n为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。\n\n了解了原理与这些 API，其实想想 ThreadLocal 里面不就是封装了一个 Map 吗？自己都可以写一个 ThreadLocal 了，尝试一下吧。\n\n\tpublic class MyThreadLocal<T> {\n\t\n\t    private Map<Thread, T> container = Collections.synchronizedMap(new HashMap<Thread, T>());\n\t\n\t    public void set(T value) {\n\t        container.put(Thread.currentThread(), value);\n\t    }\n\t\n\t    public T get() {\n\t        Thread thread = Thread.currentThread();\n\t        T value = container.get(thread);\n\t        if (value == null && !container.containsKey(thread)) {\n\t            value = initialValue();\n\t            container.put(thread, value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    public void remove() {\n\t        container.remove(Thread.currentThread());\n\t    }\n\t\n\t    protected T initialValue() {\n\t        return null;\n\t    }\n\t}\n\n以上完全山寨了一个 ThreadLocal，其中中定义了一个同步 Map（为什么要这样？请读者自行思考），代码应该非常容易读懂。\n\n下面用这 MyThreadLocal 再来实现一把看看。\n\n\tpublic class SequenceC implements Sequence {\n\t\n\t    private static MyThreadLocal<Integer> numberContainer = new MyThreadLocal<Integer>() {\n\t        @Override\n\t        protected Integer initialValue() {\n\t            return 0;\n\t        }\n\t    };\n\t\n\t    public int getNumber() {\n\t        numberContainer.set(numberContainer.get() + 1);\n\t        return numberContainer.get();\n\t    }\n\t\n\t    public static void main(String[] args) {\n\t        Sequence sequence = new SequenceC();\n\t\n\t        ClientThread thread1 = new ClientThread(sequence);\n\t        ClientThread thread2 = new ClientThread(sequence);\n\t        ClientThread thread3 = new ClientThread(sequence);\n\t\n\t        thread1.start();\n\t        thread2.start();\n\t        thread3.start();\n\t    }\n\t}\n\n以上代码其实就是将 ThreadLocal 替换成了 MyThreadLocal，仅此而已，运行效果和之前的一样，也是正确的。\n\n其实 ThreadLocal 可以单独成为一种设计模式，就看你怎么看了。 \n\nThreadLocal 具体有哪些使用案例呢？\n\n我想首先要说的就是：通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。\n\n如何实现呢？下回分解！\n\nThreadLocal 那点事儿（续集）\n\n注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！\n\n***\n\n本篇是《ThreadLocal 那点事儿》的续集，如果您没看上一篇，就就有点亏了。如果您错过了这一篇，那亏得就更大了。\n\n还是保持我一贯的 Style，用一个 Demo 来说话吧。用户提出一个需求：当修改产品价格的时候，需要记录操作日志，什么时候做了什么事情。\n\n想必这个案例，只要是做过应用系统的小伙伴们，都应该遇到过吧？无外乎数据库里就两张表：product 与 log，用两条 SQL 语句应该可以解决问题：\n\n\tupdate product set price = ? where id = ?\n\tinsert into log (created, description) values (?, ?)\n\nBut！要确保这两条 SQL 语句必须在同一个事务里进行提交，否则有可能 update 提交了，但 insert 却没有提交。如果这样的事情真的发生了，我们肯定会被用户指着鼻子狂骂：“为什么产品价格改了，却看不到什么时候改的呢？”。\n\n聪明的我在接到这个需求以后，是这样做的：\n\n首先，我写一个 DBUtil 的工具类，封装了数据库的常用操作： \n\n\tpublic class DBUtil {\n\t    // 数据库配置\n\t    private static final String driver = \"com.mysql.jdbc.Driver\";\n\t    private static final String url = \"jdbc:mysql://localhost:3306/demo\";\n\t    private static final String username = \"root\";\n\t    private static final String password = \"root\";\n\t\n\t    // 定义一个数据库连接\n\t    private static Connection conn = null;\n\t\n\t    // 获取连接\n\t    public static Connection getConnection() {\n\t        try {\n\t            Class.forName(driver);\n\t            conn = DriverManager.getConnection(url, username, password);\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        }\n\t        return conn;\n\t    }\n\t\n\t    // 关闭连接\n\t    public static void closeConnection() {\n\t        try {\n\t            if (conn != null) {\n\t                conn.close();\n\t            }\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        }\n\t    }\n\t}\n\n里面搞了一个 static 的 Connection，这下子数据库连接就好操作了，牛逼吧！\n\n然后，我定义了一个接口，用于给逻辑层来调用：\n\n\tpublic interface ProductService {\n\t\n\t    void updateProductPrice(long productId, int price);\n\t}\n\n根据用户提出的需求，我想这个接口完全够用了。根据 productId 去更新对应 Product 的 price，然后再插入一条数据到 log 表中。\n\n其实业务逻辑也不太复杂，于是我快速地完成了 ProductService 接口的实现类：\n\n\tpublic class ProductServiceImpl implements ProductService {\n\t\n\t    private static final String UPDATE_PRODUCT_SQL = \"update product set price = ? where id = ?\";\n\t    private static final String INSERT_LOG_SQL = \"insert into log (created, description) values (?, ?)\";\n\t\n\t    public void updateProductPrice(long productId, int price) {\n\t        try {\n\t            // 获取连接\n\t            Connection conn = DBUtil.getConnection();\n\t            conn.setAutoCommit(false); // 关闭自动提交事务（开启事务）\n\t\n\t            // 执行操作\n\t            updateProduct(conn, UPDATE_PRODUCT_SQL, productId, price); // 更新产品\n\t            insertLog(conn, INSERT_LOG_SQL, \"Create product.\"); // 插入日志\n\t\n\t            // 提交事务\n\t            conn.commit();\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            // 关闭连接\n\t            DBUtil.closeConnection();\n\t        }\n\t    }\n\t\n\t    private void updateProduct(Connection conn, String updateProductSQL, long productId, int productPrice) throws Exception {\n\t        PreparedStatement pstmt = conn.prepareStatement(updateProductSQL);\n\t        pstmt.setInt(1, productPrice);\n\t        pstmt.setLong(2, productId);\n\t        int rows = pstmt.executeUpdate();\n\t        if (rows != 0) {\n\t            System.out.println(\"Update product success!\");\n\t        }\n\t    }\n\t\n\t    private void insertLog(Connection conn, String insertLogSQL, String logDescription) throws Exception {\n\t        PreparedStatement pstmt = conn.prepareStatement(insertLogSQL);\n\t        pstmt.setString(1, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\").format(new Date()));\n\t        pstmt.setString(2, logDescription);\n\t        int rows = pstmt.executeUpdate();\n\t        if (rows != 0) {\n\t            System.out.println(\"Insert log success!\");\n\t        }\n\t    }\n\t}\n\n代码的可读性还算不错吧？这里我用到了 JDBC 的高级特性 Transaction 了。暗自庆幸了一番之后，我想是不是有必要写一个客户端，来测试一下执行结果是不是我想要的呢？ 于是我偷懒，直接在 ProductServiceImpl 中增加了一个 main() 方法：\n\n\tpublic static void main(String[] args) {\n\t    ProductService productService = new ProductServiceImpl();\n\t    productService.updateProductPrice(1, 3000);\n\t}\n\n我想让 productId 为 1 的产品的价格修改为 3000。于是我把程序跑了一遍，控制台输出：\n\n\tUpdate product success!\n\tInsert log success!\n\n应该是对了。作为一名专业的程序员，为了万无一失，我一定要到数据库里在看看。没错！product 表对应的记录更新了，log 表也插入了一条记录。这样就可以将 ProductService 接口交付给别人来调用了。\n\n几个小时过去了，QA 妹妹开始骂我：“我靠！我才模拟了 10 个请求，你这个接口怎么就挂了？说是数据库连接关闭了！”。\n\n听到这样的叫声，让我浑身打颤，立马中断了我的小视频，赶紧打开 IDE，找到了这个 ProductServiceImpl 这个实现类。好像没有 Bug 吧？但我现在不敢给她任何回应，我确实有点怕她的。\n\n我突然想起，她是用工具模拟的，也就是模拟多个线程了！那我自己也可以模拟啊，于是我写了一个线程类：\n\n\tpublic class ClientThread extends Thread {\n\t\n\t    private ProductService productService;\n\t\n\t    public ClientThread(ProductService productService) {\n\t        this.productService = productService;\n\t    }\n\t\n\t    @Override\n\t    public void run() {\n\t        System.out.println(Thread.currentThread().getName());\n\t        productService.updateProductPrice(1, 3000);\n\t    }\n\t}\n\n我用这线程去调用 ProduceService 的方法，看看是不是有问题。此时，我还要再修改一下 main() 方法：\n\n\t// public static void main(String[] args) {\n\t//     ProductService productService = new ProductServiceImpl();\n\t//     productService.updateProductPrice(1, 3000);\n\t// }\n\t    \n\tpublic static void main(String[] args) {\n\t    for (int i = 0; i < 10; i++) {\n\t        ProductService productService = new ProductServiceImpl();\n\t        ClientThread thread = new ClientThread(productService);\n\t        thread.start();\n\t    }\n\t}\n\n我也模拟 10 个线程吧，我就不信那个邪了！\n\n运行结果真的让我很晕、很晕：\n\n\tThread-1\n\tThread-3\n\tThread-5\n\tThread-7\n\tThread-9\n\tThread-0\n\tThread-2\n\tThread-4\n\tThread-6\n\tThread-8\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tcom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: No operations allowed after connection closed.\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:411)\n\tat com.mysql.jdbc.Util.getInstance(Util.java:386)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1015)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:989)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:975)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:920)\n\tat com.mysql.jdbc.ConnectionImpl.throwConnectionClosedException(ConnectionImpl.java:1304)\n\tat com.mysql.jdbc.ConnectionImpl.checkClosed(ConnectionImpl.java:1296)\n\tat com.mysql.jdbc.ConnectionImpl.commit(ConnectionImpl.java:1699)\n\tat com.smart.sample.test.transaction.solution1.ProductServiceImpl.updateProductPrice(ProductServiceImpl.java:25)\n\tat com.smart.sample.test.transaction.ClientThread.run(ClientThread.java:18)\n\n我靠！竟然在多线程的环境下报错了，果然是数据库连接关闭了。怎么回事呢？我陷入了沉思中。于是我 Copy 了一把那句报错信息，在百度、Google，还有 OSC 里都找了，解答实在是千奇百怪。\n\n我突然想起，既然是跟 Connection 有关系，那我就将主要精力放在检查 Connection 相关的代码上吧。是不是 Connection 不应该是 static 的呢？我当初设计成 static 的主要是为了让 DBUtil 的 static 方法访问起来更加方便，用 static 变量来存放 Connection 也提高了性能啊。怎么搞呢？\n\n于是我看到了 OSC 上非常火爆的一篇文章《ThreadLocal 那点事儿》，终于才让我明白了！原来要使每个线程都拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接，所以线程2就报错了。一定是这样！\n\n我赶紧将 DBUtil 给重构了：\n\n\tpublic class DBUtil {\n\t    // 数据库配置\n\t    private static final String driver = \"com.mysql.jdbc.Driver\";\n\t    private static final String url = \"jdbc:mysql://localhost:3306/demo\";\n\t    private static final String username = \"root\";\n\t    private static final String password = \"root\";\n\t\n\t    // 定义一个用于放置数据库连接的局部线程变量（使每个线程都拥有自己的连接）\n\t    private static ThreadLocal<Connection> connContainer = new ThreadLocal<Connection>();\n\t\n\t    // 获取连接\n\t    public static Connection getConnection() {\n\t        Connection conn = connContainer.get();\n\t        try {\n\t            if (conn == null) {\n\t                Class.forName(driver);\n\t                conn = DriverManager.getConnection(url, username, password);\n\t            }\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            connContainer.set(conn);\n\t        }\n\t        return conn;\n\t    }\n\t\n\t    // 关闭连接\n\t    public static void closeConnection() {\n\t        Connection conn = connContainer.get();\n\t        try {\n\t            if (conn != null) {\n\t                conn.close();\n\t            }\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            connContainer.remove();\n\t        }\n\t    }\n\t}\n\n我把 Connection 放到了 ThreadLocal 中，这样每个线程之间就隔离了，不会相互干扰了。\n\n此外，在 getConnection() 方法中，首先从 ThreadLocal 中（也就是 connContainer 中） 获取 Connection，如果没有，就通过 JDBC 来创建连接，最后再把创建好的连接放入这个 ThreadLocal 中。可以把 ThreadLocal 看做是一个容器，一点不假。\n\n同样，我也对 closeConnection() 方法做了重构，先从容器中获取 Connection，拿到了就 close 掉，最后从容器中将其 remove 掉，以保持容器的清洁。\n\n这下应该行了吧？我再次运行 main() 方法：\n\n\tThread-0\n\tThread-2\n\tThread-4\n\tThread-6\n\tThread-8\n\tThread-1\n\tThread-3\n\tThread-5\n\tThread-7\n\tThread-9\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\tUpdate product success!\n\tInsert log success!\n\n我去！总算是解决了，QA 妹妹，你应该会对我微笑一下吧？\n\n感谢您的关注，分享是一种快乐，也希望得到您的支持与批评！\n\n注意：该示例仅用于说明 TheadLocal 的基本用法。在实际工作中，推荐使用连接池来管理数据库连接。示例中的代码仅作参考，使用前请酌情考虑。","mtime":1400050940000,"source":"source/_posts/threadlocal-那点事儿.md","_id":"b32eipvny32fqc1m"},"r80xblq9tr3rqkrm":{"content":"title: Vim学习指南\ndate: 2014-05-14 13:38:38\n\n---\n英文原文：[Learn Vim Progressively](http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/)\n\n你想尽可能快地自学vim(为大家所熟知的最好的编辑器) 。这是我学习的方法：从细处入手然后慢慢掌握所有技巧。\n\nVim 六十亿美元的编辑器\n\n>设计优良，强壮，快速。\n\n学习vim并把它作为你的下一个文本编辑器，据我所知没有比它更好的编辑器，学起来难但出奇的好用。\n\n我建议你按下附4个步骤学习Vim：\n\n1. 适应\n2. 感觉舒适\n3. 感觉很好，强壮，快速\n4. 使用vim的高级技能\n\n本课程结束时你将成为一个vim高手。\n\n但在我们开始之前，先提醒一下。刚开始学习vim会有点痛苦，它很费时间，有点像玩乐器一样。不要指望能像其他编辑器一样花3天以内的时间便能很好的使用它，事实上，这肯定要花2周而不是3天。\n\n第一层次 – 适应\n===\n\n1. 安装vim\n2. 运行vim\n3. 什么也别做，读！\n\n在标准的编辑器里，写一些东西到屏幕上只需要在键盘上输入就足够了，在Vim中不是这样。Vim在普通模式里，让我们转到插入模式，键入字符i。\n\n你应该感觉好一点了，能像在标准编辑器里输入了，回到普通模式只需按ESC键即可。\n\n你现在知道了如何在插入和普通模式之间转换，下面是你在普通模式下需要记住的指令：\n\n>\n* i→ 插入模式. 按ESC键返回普通模式\n* x→ 删除光标所在的字符\n* :wq→ 保存退出(:w 保存，:q 退出)\n* dd→ 删除(拷贝)当前行\n* p→ 粘贴\n>\n推荐\n>\n* hjkl(高度推荐) → 基本的光标移动 (←↓↑→)， hj按行移动。\n* :help <command>→ 显示关于<command>的帮助，可以使用help不带<command>获得常规帮助。\n\n只有5个命令，一开始只需掌握这些，当适应了这些命令后（大概需要一天或更多的诗句），你可以转到第二层级了。\n\n但首先，稍回顾一下普通模式。在标准编辑器里，要复制的话你需要使用ctrl键（Ctrl-c）。实际上，当你按\n下ctrl键时所有的按键的意义都改变了。在vim普通模式下就像在ctrl键自动按下的情况下使用编辑器。\n\n最后的补充：\n\n* 我使用<C-λ>代替Ctrl-λ\n* 命令后附带回车，比如我若是写:q，我是指:q<enter>\n\n第二层 - 爽一把\n===\n\n你懂的，命令是由需求所定。是时候学习更多命令了。下面这些是我的建议：\n\n1. 插入模式变种命令：\n>\n\t* a→ 在光标后插入\n\t* o→ 在当前行之后插入新行\n\t* O→ 在当前行之前插入新行\n\t* cw→ 替换从光标到单词结束\n2. 基本移动命令\n>\n\t* 0→ 跳到第一列\n\t* ^→ 跳到本行第一个非空字符\n\t* $→ 跳到本行末尾\n\t* g_→ 跳到本行最后一个非空字符\n\t* /pattern→ 搜索pattern\n3. 复制/粘贴\n>\n\t* P→ 在当前位置之前粘贴，记住 p 是在当前位置之前粘贴.\n\t* yy→ 复制当前行，与dd和P命令相比更简单。\n4. 取消/恢复\n>\n\t* u→ 取消\n\t* <C-r>→ 恢复\n5. 加载/保存/退出/修改 文件(缓存)\n>\n\t* :e <文件路径>→ 打开\n\t* :w→ 保存\n\t* :saveas <文件路径>→ 保存到这个文件\n\t* :x,ZZ或者:wq→ 保存和退出 (:x 如果可能的话，只保存)\n\t* :q!→ 退出但不保存，使用:qa!，即使在缓存中还有已经修改的也会退出。\n\t* :bn(对比:bp) → 显示下一个(上一个)文件缓存\n\n花些时间学习所有这些命令。一旦完成后，你应该就能完成在像在其它编辑器中所有事情。也许，你可能还会觉得有点笨手笨脚。但是跟着我进入下一个层次，你就会发现为什么vim值得你额外付出的努力。\n\n第三层次 - 更好，更强，更快\n===\n\n恭喜进入第三层次！现在我们开始一些有趣的事。在第三层次中，我们只会谈论那些和vi编辑器兼容的命令\n\n**更好**\n\n让我们看看vim是如何帮助我们做重复工作的:\n\n1. .→ (点)会重做最后一个命令,\n2. N<命令> → 会重做这个命令N次.\n\n一些例子，打开文件然后输入:\n\n>\n* 2dd→ 会删除2行\n* 3p→ 会粘贴文本3次\n* 100idesu [ESC]→ 会写入“desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu”\n* .→ 在最后一个命令之后会在此写入100个\"desu\".\n* 3.→ 会写入3个“desu”(并不是300个, 聪明极了).\n\n**更强**\n\n掌握高效率使用vim是十分重要的。请不要跳过这节。\n\n1. NG→ 跳到第N行\n2. gg→ 是1G的快捷方式 - 跳到文件的开始\n3. G→ 跳到最后一行\n4. 单词间移动:\n\n>\n1. w→ 跳到下一个单词的开头,\n2. e→ 跳到这个单词的末尾.\n>\n默认，单词是有字母和下划线组成。这里我们所谓的单词就是由空格分隔的。如果你只想考虑单词，就使用大写的字符吧:\n>\n1. W→跳到下一个单词的开头,\n2. E→ 跳到这个单词的末尾.\n>\n![image](http://waakaakaa.qiniudn.com/19135039_AdpL.jpg)\n\n现在，我们谈论高效率移动：\n\n>\n* %: 跳到对应的(, (, [ 处.\n* *(对比#) : 跳到当前光标的下一个(上一个) 相同单词的地方\n\n信我，最后3个命令价比黄金。\n\n**更快**\n\n记住了vi移动的重要性？这里就是原因。大多数命令使用下面这种通用格式：\n\n<开始位置><命令><结束位置>\n\n例如： 0y$意味着\n\n* 0→ 跳到本行开头\n* y→ 从这里开始复制\n* $→ 直到本行结束\n\n我们也可以使用ye，从当前位置复制到单词的末尾。但是y2/foo 会一直复制到第二个foo出现的地方。\n\n但对于y（复制）， d(删除), v(visual 选择)， gU(大写)， gu(小写)等等命令都是真实的。\n\n第四层次 – Vim 超能量\n===\n\n使用上述的命令，是否觉得很爽了。但是现在，这里才是杀手锏。正因为其中有些特性，我才使用vim的。\n\n**在当前行移动:0^$g_fFtT,;**\n\n>\n* 0→ 跳到第一列\n* ^→ 跳到当前行的第一个字符\n* $→ 跳到最后一列\n* g_→ 跳到这行的最后一个字符\n* fa→ 跳到这行a字母的下一个出现的地方。（对比 ; ）会查找下一个（上一个）地方\n* t,→ 跳到，字符的前一个字符.\n* 3fa→ 在这行中查找a出现的第三个位置.\n* F 和 T→ 与f和t相似， 但是方向相反.\n>\n![image](http://waakaakaa.qiniudn.com/19135039_vFzT.jpg)\n\n一个有用的提示：dt\"→删除所有的直到”。\n\n**区域选择 ： <命令>a<对象> 或 <命令>i<对象>**\n\n这些命令仅仅能用在可视化模式的一个操作后。但是他们相当的有用。他们的主要模式有：\n\n<命令>a<对象> 和 <命令>i<对象>\n\n命令可以是任何命令，例如 , d(删除),y(拉取),v(进入可视化模式)。对象可以是: w一个单词，W一个单词 (扩展的)，s一个句子，p一个段落。而且也可以是普通的字符， 例如\"，'，)，}，]。\n\n假设现在光标在 (map (+) (\"foo\")) 这个字符串的第一个o上。\n\n>\n* vi\"→ 将会选择 foo\n* va\"→ 将会选择 \"foo\"\n* vi)→ 将会选择 \"foo\"\n* va)→ 将会选择 (\"foo\")\n* v2i)→ 将会选择 map (+) (\"foo\")\n* v2a)→ 将会选择 (map (+) (\"foo\"))\n>\n![image](http://waakaakaa.qiniudn.com/19135040_FZZt.png)\n\n**矩形选择块:<C-v>**\n\n矩形选择块能够方便的对多行代码进行注释。 如:0<C-v><C-d>I-- [ESC]\n\n>\n* ^→ 将光标定位到这行第一个非空格字符\n* <C-v>→ 选择开始位置\n* <C-d>→ 向下移动 (也可使用 jjj 或者 % ， 其他…)\n* I-- [ESC]→ 用 -- 来注释每一行\n>\n![image](http://waakaakaa.qiniudn.com/19135040_1Cyy.gif)\n\n提示：如果你的剪贴板在Windows中是非空的话，那么你就不得不使用<C-q>来代替<C-v>。\n\n**实现:<C-n>和<C-p>.**\n\n在插入模式中：只要打出单词的首字母，然后按<C-p>，神奇的事情就发生了...\n\n![image](http://waakaakaa.qiniudn.com/19135042_T1fu.gif)\n\n**宏命令 : qa 做的一些事,@a,@@**\n\nqa 把你的动作记录在了寄存器 a 中。然后@a 就会将存在寄存器中的动作重现，就好像你从新打了一边。@@是将你最后一次执行的宏命令再次执行的快捷键。\n\n>\n事例\n>\n在只有数字1的一行上， 像这样键入命令:\n>\n* qaYp<C-a>q→\n\t* qa开始记录。\n\t* Yp记录这一行。\n\t* <C-a>增加数字大小。\n\t* q停止记录。\n* @a→ 在1下面写2\n* @@→ 在2下面写3\n* 现在键入 100@@ 就将会产生一个到 103 的自增列。\n>\n![image](http://waakaakaa.qiniudn.com/19135042_jJUW.gif)\n\n**可视化模式选择： v, V, <C-v>**\n\n我们已经看到过<C-v>例子，这里还有v和V。一旦已经选择好了，你可以：\n\n>\n* J→ 让所有行连接在一起\n* <(对比>) → 向左（右）对齐.\n* =→ 自动对齐\n>\n![image](http://waakaakaa.qiniudn.com/19135043_Npsr.gif)\n\n在可视化模式所选择的行的末尾添加一些东西：\n\n>\n* <C-v>\n* 跳到目的行 (jjj 或者 <C-d> 或者 /patternor%等等…)\n* $跳到行末尾\n* A, 写入一些文本，[按] ESC 键.\n>\n![image](http://waakaakaa.qiniudn.com/19135046_NfIl.gif)\n\n**分割：： split 和 vsplit**\n\n这些是很重要的命令，所以你应该在:help split看看。\n\n>\n* :split→ 创建一个水平分割窗口t (:vsplit 创建一个竖直分割窗口)\n* <C-w><dir>:  dir是hjklor←↓↑→中任何一个。用来切换分割窗口。\n* <C-w>_(对比<C-w>|) : 用来最大化水平（竖直）分割窗口的大小\n* <C-w>+(对比<C-w>-) : 增加 (减小) 分割窗口\n>\n![image](http://waakaakaa.qiniudn.com/19135046_ivZR.gif)\n\n小结\n===\n\n这些是我经常使用的90%的命令。我建议你每天学习一到两个命令。在两到三周之后，你将会感觉到vim在你手上使用的是如此的强大。\n\n学习vim更多的是记忆训练。值得高兴的是vim诞生了一些非常好的工具和优秀的文档。当你非常熟悉大部分基本命令之后就可以使用vimtutor了。另外，你应该仔细的阅读这页 ::help usr_02.txt.\n\n然后，你要去学习了解寄存器，插件已经其它的功能。学习vim就像学钢琴一样，所有的都要掌握好。","mtime":1400047937000,"source":"source/_posts/vim学习指南.md","_id":"r80xblq9tr3rqkrm"},"re140doqyc7h562w":{"content":"title: 一种在图片里隐藏你的程序代码的技术\ndate: 2014-05-14 13:00:19\n\n---\n我最近开发了我的第一个网页游戏：[一个HTML5的视频智力游戏](http://www.patrick-wied.at/projects/html5-video-puzzle)。 开发的过程很有趣，我喜欢编程，但当实现了游戏逻辑后，我有了一个有趣的想法：为什么不想个办法把代码隐藏起来？起初我想到的是一些很简单的做法，比如禁 止上下文菜单，以防右键点击时可以查看页面源代码。但这毫无意义，右键菜单不能用，人们仍然可以通过键盘快捷键或菜单栏里的“查看源文件”来观看源代码。\n\n**一张图片能隐含千言万语**。\n\n这依赖于图片的体积。但我决定要把源代码加密存放到一张图片里。HTML5的画布(canvas)组件很适合干这种事情，因为它支持针对图像像素的 操作。一个像素由四个值(通道)来表示：红，绿，蓝和alpha通道。它们的值的分布范围是从0到255。我的Javascript代码就是一个个的字 符，每个字符都有一个ASCII对应值。ASCII值的范围也是0-255，所以，我想做的是，遍历画布上的每个像素，给每个像素设置3个代码字符的 ASCII值作为它的RGB值，你可以通过charCodeAt函数轻松的取出这些字符。\n\n>.charCodeAt(0)\n\n生成的是一张色彩斑斓、很小的图片，它就是我的程序代码  。看看吧:\n\n\n解码的时候，我只需要把这个图片画到画布上，遍历像素点，取出r,g,b值所代表的字符：\n\n>String.fromCharCode(code)\n\n把它们连接成一个大的字符串，这就是你的代码了——可执行的代码。 \n\n这样就能保护你的源代码了吗？\n\n其实不能——一个有经验的(甚至没有经验的)程序员仍然能够知道如何去解码图片，取出里面的代码，但我想这是能防止那些怀着不良商业目的人偷盗你的的代码的第一步措施——而那些能够想出如何解码的程序员(大部分)都不是来剽窃的 \n\n**这种方法的主要缺陷**\n\n这种技术只能应用在支持HTML5画布(canvas)技术的现代浏览器里，IE6、IE8 里肯定是不行的。甚至有些现代的浏览器对于图片的alpha通道的编码也有支持问题，所以，每个像素点你只能放3个字符——一个100×100大小的图片 可以存放3万个文本字符。 \n\n你还有其它简单的能防止别人拷贝你的代码的方法吗？我们当然可以把字符进行加密，但如何保证你的解密步骤能不被人轻易的破解呢？告诉我你的想法吧！\n\n[本文英文原文链接：[A technique for hiding your JavaScript Code](http://www.patrick-wied.at/blog/a-technique-for-hiding-your-javascript-code) ]","mtime":1400043812000,"source":"source/_posts/一种在图片里隐藏你的程序代码的技术.md","_id":"re140doqyc7h562w"},"6ssowrqes4he2a25":{"content":"title: 代码审查最佳实践\ndate: 2014-05-14 11:59:45\n\n---\n![image](http://waakaakaa.qiniudn.com/08215745_vKS6.png)\n\n代码审查可以帮助提高代码质量，避免由于代码习惯而造成的 bug。下面列出的这些要点因该可以作为大部分代码审查的指导，如果是 Java 应用的话，这些建议应该被视作最佳实践。\n\n文档\n\n1. Javadoc 应该在每一个类和方法中添加。\n2. 如果是修复某个 bug，应该添加 bug ID。\n3. 走捷径的方法或者复杂的逻辑要有解释。\n4. 如果代码会被公开，每个文件头都要标注版权信息。\n5. 复杂的 HTML，JavaScript，CSS 应该包含文档。\n\n功能\n\n1. 如果类似的逻辑被使用了多次，应该把它写成一个帮助类，然后在多出调用。\n2. 鼓励使用 API 而不是重复编写代码解决相同的问题。\n3. 要强调代码的单元测试。\n4. 任何新加的代码不应该破坏已有的代码。\n5. 假如是 Web 应用，JSP 不应该包含 Java 代码。\n\n安全\n\n1. 任何代码都不能执行用户的输入，除非转义过了。这个常常包含 JavaScript 的 eval 函数和 SQL 语句。\n2. 禁止那些在短时间内提交非常多请求的 IP。\n3. 任何类，变量，还有方法都应该有正确的访问域。\n4. 尽量避免使用 iframe。\n\n性能\n\n1. 所有数据库和文件操句柄在不需要的时候都应该被关闭。\n2. SQL 语句的写法会导致性能千差万别。\n3. 鼓励创建不可变（immutable）的类。\n4. 类似的逻辑代码，尽量通过 if else 语句来实现更多的重用。\n5. 尽量避免使用重对象（heavy objects）。\n6. 如果是 Web 项目，请检查是否使用了合适的图片尺寸，CSS sprites 和浏览器缓存等技术。\n7. 全局都需要的信息保存在 application context 中。\n\n编码习惯\n\n1. 没有被使用的变量要删除。\n2. 针对不同的 Exception 要用不同的 catch 语句，而不是一个 Exception 解决所有问题。\n3. 针对变量，方法和类要用相同的命名方法。\n4. 常量应该被写在独立的常量类中。\n5. 每行代码的尾部不要有多余的空格。\n6. 对于括号，循环，if语句等等要用统一的格式。\n7. 每一个单独的方法不应该超过100行。\n8. 一个单独的语句不应该超过编辑器的可视区域，它可以被拆分成几行。\n9. 检查 String 对象既不是null也不是空的最好方法是 if(“”.equals(str))\n10. 假如类有很多成员变量，并且实例化的时候只需要少数变量传入的话，最好使用静态工厂方法，而不是重载构造函数。\n11. 给方法添加适当的访问控制，而不是所有都是 public。\n12. 遵守项目中使用的框架的最佳实践建议，例如 Spring，Struts，Hibernate，jQuery。\n\n以上的某些注意点可以通过静态代码检查工具完成，例如 CheckStyle，FindBugs 和 JTest。\n\n \n\n[原文链接](http://javaexperience.com/code-review-checklist/)，[OSChina.NET](http://www.oschina.net/news/31722/code-review-best-practices) 编译","mtime":1400040063000,"source":"source/_posts/代码审查最佳实践.md","_id":"6ssowrqes4he2a25"},"kzfl73t0e12tpva6":{"content":"title: '单个 C 文件实现的 Web 服务器'\ndate: 2014-05-14 15:58:31\n\n---\n\t/*\n\t * WebServer.c\n\t *\n\t *  Created on: Nov 3, 2012\n\t *      Author: pavithra\n\t *\n\t * A web server in C language using only the standard libraries.\n\t * The port number is passed as an argument.\n\t *\n\t */\n\t\n\t#include <stdio.h>\n\t#include <unistd.h>\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <netinet/in.h>\n\t#include <fcntl.h>\n\t#include <errno.h>\n\t\n\t#define EOL \"\\r\\n\"\n\t#define EOL_SIZE 2\n\t\n\ttypedef struct {\n\t char *ext;\n\t char *mediatype;\n\t} extn;\n\t\n\t//Possible media types\n\textn extensions[] ={\n\t {\"gif\", \"image/gif\" },\n\t {\"txt\", \"text/plain\" },\n\t {\"jpg\", \"image/jpg\" },\n\t {\"jpeg\",\"image/jpeg\"},\n\t {\"png\", \"image/png\" },\n\t {\"ico\", \"image/ico\" },\n\t {\"zip\", \"image/zip\" },\n\t {\"gz\",  \"image/gz\"  },\n\t {\"tar\", \"image/tar\" },\n\t {\"htm\", \"text/html\" },\n\t {\"html\",\"text/html\" },\n\t {\"php\", \"text/html\" },\n\t {\"pdf\",\"application/pdf\"},\n\t {\"zip\",\"application/octet-stream\"},\n\t {\"rar\",\"application/octet-stream\"},\n\t {0,0} };\n\t\n\t/*\n\t A helper function\n\t */\n\tvoid error(const char *msg) {\n\t perror(msg);\n\t exit(1);\n\t}\n\t\n\t/*\n\t A helper function\n\t */\n\tint get_file_size(int fd) {\n\t struct stat stat_struct;\n\t if (fstat(fd, &stat_struct) == -1)\n\t  return (1);\n\t return (int) stat_struct.st_size;\n\t}\n\t\n\t/*\n\t A helper function\n\t */\n\tvoid send_new(int fd, char *msg) {\n\t int len = strlen(msg);\n\t if (send(fd, msg, len, 0) == -1) {\n\t  printf(\"Error in send\\n\");\n\t }\n\t}\n\t\n\t/*\n\t This function recieves the buffer\n\t until an \"End of line(EOL)\" byte is recieved\n\t */\n\tint recv_new(int fd, char *buffer) {\n\t char *p = buffer; // Use of a pointer to the buffer rather than dealing with the buffer directly\n\t int eol_matched = 0; // Use to check whether the recieved byte is matched with the buffer byte or not\n\t while (recv(fd, p, 1, 0) != 0) // Start receiving 1 byte at a time\n\t {\n\t  if (*p == EOL[eol_matched]) // if the byte matches with the first eol byte that is '\\r'\n\t    {\n\t   ++eol_matched;\n\t   if (eol_matched == EOL_SIZE) // if both the bytes matches with the EOL\n\t   {\n\t    *(p + 1 - EOL_SIZE) = '\\0'; // End the string\n\t    return (strlen(buffer)); // Return the bytes recieved\n\t   }\n\t  } else {\n\t   eol_matched = 0;\n\t  }\n\t  p++; // Increment the pointer to receive next byte\n\t }\n\t return (0);\n\t}\n\t\n\t/*\n\t A helper function: Returns the\n\t web root location.\n\t */\n\tchar* webroot() {\n\t // open the file \"conf\" for reading\n\t FILE *in = fopen(\"conf\", \"rt\");\n\t // read the first line from the file\n\t char buff[1000];\n\t fgets(buff, 1000, in);\n\t // close the stream\n\t fclose(in);\n\t char* nl_ptr = strrchr(buff, '\\n');\n\t if (nl_ptr != NULL)\n\t  *nl_ptr = '\\0';\n\t return strdup(buff);\n\t}\n\t\n\t/*\n\t Handles php requests\n\t */\n\tvoid php_cgi(char* script_path, int fd) {\n\t send_new(fd, \"HTTP/1.1 200 OK\\n Server: Web Server in C\\n Connection: close\\n\");\n\t dup2(fd, STDOUT_FILENO);\n\t char script[500];\n\t strcpy(script, \"SCRIPT_FILENAME=\");\n\t strcat(script, script_path);\n\t putenv(\"GATEWAY_INTERFACE=CGI/1.1\");\n\t putenv(script);\n\t putenv(\"QUERY_STRING=\");\n\t putenv(\"REQUEST_METHOD=GET\");\n\t putenv(\"REDIRECT_STATUS=true\");\n\t putenv(\"SERVER_PROTOCOL=HTTP/1.1\");\n\t putenv(\"REMOTE_HOST=127.0.0.1\");\n\t execl(\"/usr/bin/php-cgi\", \"php-cgi\", NULL);\n\t}\n\t\n\t/*\n\t This function parses the HTTP requests,\n\t arrange resource locations,\n\t check for supported media types,\n\t serves files in a web root,\n\t sends the HTTP error codes.\n\t */\n\tint connection(int fd) {\n\t char request[500], resource[500], *ptr;\n\t int fd1, length;\n\t if (recv_new(fd, request) == 0) {\n\t  printf(\"Recieve Failed\\n\");\n\t }\n\t printf(\"%s\\n\", request);\n\t // Check for a valid browser request\n\t ptr = strstr(request, \" HTTP/\");\n\t if (ptr == NULL) {\n\t  printf(\"NOT HTTP !\\n\");\n\t } else {\n\t  *ptr = 0;\n\t  ptr = NULL;\n\t\n\t  if (strncmp(request, \"GET \", 4) == 0) {\n\t   ptr = request + 4;\n\t  }\n\t  if (ptr == NULL) {\n\t   printf(\"Unknown Request ! \\n\");\n\t  } else {\n\t   if (ptr[strlen(ptr) - 1] == '/') {\n\t    strcat(ptr, \"index.html\");\n\t   }\n\t   strcpy(resource, webroot());\n\t   strcat(resource, ptr);\n\t   char* s = strchr(ptr, '.');\n\t   int i;\n\t   for (i = 0; extensions[i].ext != NULL; i++) {\n\t    if (strcmp(s + 1, extensions[i].ext) == 0) {\n\t     fd1 = open(resource, O_RDONLY, 0);\n\t     printf(\"Opening \\\"%s\\\"\\n\", resource);\n\t     if (fd1 == -1) {\n\t      printf(\"404 File not found Error\\n\");\n\t      send_new(fd, \"HTTP/1.1 404 Not Found\\r\\n\");\n\t      send_new(fd, \"Server : Web Server in C\\r\\n\\r\\n\");\n\t      send_new(fd, \"<html><head><title>404 Not Found</head></title>\");\n\t      send_new(fd, \"<body><p>404 Not Found: The requested resource could not be found!</p></body></html>\");\n\t      //Handling php requests\n\t     } else if (strcmp(extensions[i].ext, \"php\") == 0) {\n\t      php_cgi(resource, fd);\n\t      sleep(1);\n\t      close(fd);\n\t      exit(1);\n\t     } else {\n\t      printf(\"200 OK, Content-Type: %s\\n\\n\",\n\t        extensions[i].mediatype);\n\t      send_new(fd, \"HTTP/1.1 200 OK\\r\\n\");\n\t      send_new(fd, \"Server : Web Server in C\\r\\n\\r\\n\");\n\t      if (ptr == request + 4) // if it is a GET request\n\t        {\n\t       if ((length = get_file_size(fd1)) == -1)\n\t        printf(\"Error in getting size !\\n\");\n\t       size_t total_bytes_sent = 0;\n\t       ssize_t bytes_sent;\n\t       while (total_bytes_sent < length) {\n\t        //Zero copy optimization\n\t        if ((bytes_sent = sendfile(fd, fd1, 0,\n\t          length - total_bytes_sent)) <= 0) {\n\t         if (errno == EINTR || errno == EAGAIN) {\n\t          continue;\n\t         }\n\t         perror(\"sendfile\");\n\t         return -1;\n\t        }\n\t        total_bytes_sent += bytes_sent;\n\t       }\n\t\n\t      }\n\t     }\n\t     break;\n\t    }\n\t    int size = sizeof(extensions) / sizeof(extensions[0]);\n\t    if (i == size - 2) {\n\t     printf(\"415 Unsupported Media Type\\n\");\n\t     send_new(fd, \"HTTP/1.1 415 Unsupported Media Type\\r\\n\");\n\t     send_new(fd, \"Server : Web Server in C\\r\\n\\r\\n\");\n\t     send_new(fd, \"<html><head><title>415 Unsupported Media Type</head></title>\");\n\t     send_new(fd, \"<body><p>415 Unsupported Media Type!</p></body></html>\");\n\t    }\n\t   }\n\t\n\t   close(fd);\n\t  }\n\t }\n\t shutdown(fd, SHUT_RDWR);\n\t}\n\t\n\tint main(int argc, char *argv[]) {\n\t int sockfd, newsockfd, portno, pid;\n\t socklen_t clilen;\n\t struct sockaddr_in serv_addr, cli_addr;\n\t\n\t if (argc < 2) {\n\t  fprintf(stderr, \"ERROR, no port provided\\n\");\n\t  exit(1);\n\t }\n\t sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\t if (sockfd < 0)\n\t  error(\"ERROR opening socket\");\n\t bzero((char *) &serv_addr, sizeof(serv_addr));\n\t portno = atoi(argv[1]);\n\t serv_addr.sin_family = AF_INET;\n\t serv_addr.sin_addr.s_addr = INADDR_ANY;\n\t serv_addr.sin_port = htons(portno);\n\t if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)\n\t  error(\"ERROR on binding\");\n\t listen(sockfd, 5);\n\t clilen = sizeof(cli_addr);\n\t /*\n\t  Server runs forever, forking off a separate\n\t  process for each connection.\n\t  */\n\t while (1) {\n\t  newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n\t  if (newsockfd < 0)\n\t   error(\"ERROR on accept\");\n\t  pid = fork();\n\t  if (pid < 0)\n\t   error(\"ERROR on fork\");\n\t  if (pid == 0) {\n\t   close(sockfd);\n\t   connection(newsockfd);\n\t   exit(0);\n\t  } else\n\t   close(newsockfd);\n\t } /* end of while */\n\t close(sockfd);\n\t return 0; /* we never get here */\n\t}","mtime":1400054422000,"source":"source/_posts/单个-c-文件实现的-web-服务器.md","_id":"kzfl73t0e12tpva6"},"wn3m927xz9zs7kdf":{"content":"title: '妈咪，我找到了! -- 15个实用的Linux find命令示例'\ndate: 2014-05-14 14:20:06\n\n---\n除了在一个目录结构下查找文件这种基本的操作，你还可以用find命令实现一些实用的操作，使你的命令行之旅更加简易。\n\n本文将介绍15种无论是于新手还是老鸟都非常有用的Linux find命令。\n\n首先，在你的home目录下面创建下面的空文件，来测试下面的find命令示例。\n\n\t# vim create_sample_files.sh\n\ttouch MybashProgram.sh\n\ttouch mycprogram.c\n\ttouch MyCProgram.c\n\ttouch Program.c\n\t\n\tmkdir backup\n\tcd backup\n\t\n\ttouch MybashProgram.sh\n\ttouch mycprogram.c\n\ttouch MyCProgram.c\n\ttouch Program.c\n\t\n\t# chmod +x create_sample_files.sh\n\t\n\t# ./create_sample_files.sh\n\t\n\t# ls -R\n\t.:\n\tbackup                  MybashProgram.sh  MyCProgram.c\n\tcreate_sample_files.sh  mycprogram.c      Program.c\n\t\n\t./backup:\n\tMybashProgram.sh  mycprogram.c  MyCProgram.c  Program.c\n\n**1. 用文件名查找文件**\n\n这是find命令的一个基本用法。下面的例子展示了用MyCProgram.c作为查找名在当前目录及其子目录中查找文件的方法。\n\n\t# find -name \"MyCProgram.c\"\n\t./backup/MyCProgram.c\n\t./MyCProgram.c\n\n**2.用文件名查找文件，忽略大小写**\n\n这是find命令的一个基本用法。下面的例子展示了用MyCProgram.c作为查找名在当前目录及其子目录中查找文件的方法，忽略了大小写。\n\n\t# find -iname \"MyCProgram.c\"\n\t./mycprogram.c\n\t./backup/mycprogram.c\n\t./backup/MyCProgram.c\n\t./MyCProgram.c\n\n**3. 使用mindepth和maxdepth限定搜索指定目录的深度**\n\n在root目录及其子目录下查找passwd文件。\n\n\t# find / -name passwd\n\t./usr/share/doc/nss_ldap-253/pam.d/passwd\n\t./usr/bin/passwd\n\t./etc/pam.d/passwd\n\t./etc/passwd\n\n在root目录及其1层深的子目录中查找passwd. (例如root — level 1, and one sub-directory — level 2)\n\n\t# find -maxdepth 2 -name passwd\n\t./etc/passwd\n\n在root目录下及其最大两层深度的子目录中查找passwd文件. (例如 root — level 1, and two sub-directories — level 2 and 3 )\n\n\t# find / -maxdepth 3 -name passwd\n\t./usr/bin/passwd\n\t./etc/pam.d/passwd\n\t./etc/passwd\n\n在第二层子目录和第四层子目录之间查找passwd文件。\n\n\t# find -mindepth 3 -maxdepth 5 -name passwd\n\t./usr/bin/passwd\n\t./etc/pam.d/passwd\n\n**4. 在find命令查找到的文件上执行命令**\n\n下面的例子展示了find命令来计算所有不区分大小写的文件名为“MyCProgram.c”的文件的MD5验证和。{}将会被当前文件名取代。\n\n\tfind -iname \"MyCProgram.c\" -exec md5sum {} \\;\n\td41d8cd98f00b204e9800998ecf8427e  ./mycprogram.c\n\td41d8cd98f00b204e9800998ecf8427e  ./backup/mycprogram.c\n\td41d8cd98f00b204e9800998ecf8427e  ./backup/MyCProgram.c\n\td41d8cd98f00b204e9800998ecf8427e  ./MyCProgram.c\n\n**5. 相反匹配**\n\n显示所有的名字不是MyCProgram.c的文件或者目录。由于maxdepth是1，所以只会显示当前目录下的文件和目录。\n\n\tfind -maxdepth 1 -not -iname \"MyCProgram.c\"\n\t.\n\t./MybashProgram.sh\n\t./create_sample_files.sh\n\t./backup\n\t./Program.c\n\n**6. 使用inode编号查找文件**\n\n任何一个文件都有一个独一无二的inode编号，借此我们可以区分文件。创建两个名字相似的文件，例如一个有空格结尾，一个没有。\n\n\ttouch \"test-file-name\"\n\n\t# touch \"test-file-name \"\n\t[Note: There is a space at the end]\n\t\n\t# ls -1 test*\n\ttest-file-name\n\ttest-file-name\n\n从ls的输出不能区分哪个文件有空格结尾。使用选项-i，可以看到文件的inode编号，借此可以区分这两个文件。\n\n\tls -i1 test*\n\t16187429 test-file-name\n\t16187430 test-file-name\n\n你可以如下面所示在find命令中指定inode编号。在此，find命令用inode编号重命名了一个文件。\n\n\tfind -inum 16187430 -exec mv {} new-test-file-name \\;\n\t\n\t# ls -i1 *test*\n\t16187430 new-test-file-name\n\t16187429 test-file-name\n\n你可以在你想对那些像上面一样的糟糕命名的文件做某些操作时使用这一技术。例如，名为file?.txt的文件名字中有一个特殊字符。若你想执行“rm file?.txt”，下面所示的所有三个文件都会被删除。所以，采用下面的步骤来删除\"file?.txt\"文件。\n\n\tls\n\tfile1.txt  file2.txt  file?.txt\n\n找到每一个文件的inode编号。\n\n\tls -i1\n\t804178 file1.txt\n\t804179 file2.txt\n\t804180 file?.txt\n\n如下所示： 使用inode编号来删除那些具有特殊符号的文件名。\n\n\tfind -inum 804180 -exec rm {} \\;\n\t\n\t# ls\n\tfile1.txt  file2.txt\n\t[Note: The file with name \"file?.txt\" is now removed]\n\n**7. 根据文件权限查找文件**\n\n下面的操作时合理的：\n\n* 找到具有指定权限的文件\n* 忽略其他权限位，检查是否和指定权限匹配\n* 根据给定的八进制/符号表达的权限搜索\n\n此例中，假设目录包含以下文件。注意这些文件的权限不同。\n\n\tls -l\n\ttotal 0\n\t-rwxrwxrwx 1 root root 0 2009-02-19 20:31 all_for_all\n\t-rw-r--r-- 1 root root 0 2009-02-19 20:30 everybody_read\n\t---------- 1 root root 0 2009-02-19 20:31 no_for_all\n\t-rw------- 1 root root 0 2009-02-19 20:29 ordinary_file\n\t-rw-r----- 1 root root 0 2009-02-19 20:27 others_can_also_read\n\t----r----- 1 root root 0 2009-02-19 20:27 others_can_only_read\n\n找到具有组读权限的文件。使用下面的命令来找到当前目录下对同组用户具有读权限的文件，忽略该文件的其他权限。\n\n\tfind . -perm -g=r -type f -exec ls -l {} \\;\n\t-rw-r--r-- 1 root root 0 2009-02-19 20:30 ./everybody_read\n\t-rwxrwxrwx 1 root root 0 2009-02-19 20:31 ./all_for_all\n\t----r----- 1 root root 0 2009-02-19 20:27 ./others_can_only_read\n\t-rw-r----- 1 root root 0 2009-02-19 20:27 ./others_can_also_read\n\n找到对组用户具有只读权限的文件。\n\n\tfind . -perm g=r -type f -exec ls -l {} \\;\n\t----r----- 1 root root 0 2009-02-19 20:27 ./others_can_only_read\n\t\n找到对组用户具有只读权限的文件(使用八进制权限形式)。\n\n\tfind . -perm 040 -type f -exec ls -l {} \\;\n\t----r----- 1 root root 0 2009-02-19 20:27 ./others_can_only_read\n\n**8. 找到home目录及子目录下所有的空文件(0字节文件)**\n\n下面命令的输出文件绝大多数都是锁定文件盒其他程序创建的place hoders\n\n\tfind ~ -empty\n\n只列出你home目录里的空文件。\n\n\tfind . -maxdepth 1 -empty\n\n只列出当年目录下的非隐藏空文件。\n\n\tfind . -maxdepth 1 -empty -not -name \".*\"\n\n**9. 查找5个最大的文件**\n\n下面的命令列出当前目录及子目录下的5个最大的文件。这会需要一点时间，取决于命令需要处理的文件数量。\n\n\tfind . -type f -exec ls -s {} \\; | sort -n -r | head -5\n\n**10. 查找5个最小的文件**\n\n方法同查找5个最大的文件类似，区别只是sort的顺序是降序。\n\n\tfind . -type f -exec ls -s {} \\; | sort -n  | head -5\n\n上面的命令中，很可能你看到的只是空文件(0字节文件)。如此，你可以使用下面的命令列出最小的文件，而不是0字节文件。\n\n\tfind . -not -empty -type f -exec ls -s {} \\; | sort -n  | head -5\n\n**11. 使用-type查找指定文件类型的文件**\n\n只查找socket文件\n\n\tfind . -type s\n\n查找所有的目录\n\n\tfind . -type d\n\n查找所有的一般文件\n\n\tfind . -type f\n\n查找所有的隐藏文件\n\n\tfind . -type f -name \".*\"\n\n查找所有的隐藏目录\n\n\tfind -type d -name \".*\"\n\n**12. 通过和其他文件比较修改时间查找文件**\n\n显示在指定文件之后做出修改的文件。下面的find命令将显示所有的在ordinary_file之后创建修改的文件。\n\n\tls -lrt\n\ttotal 0\n\t-rw-r----- 1 root root 0 2009-02-19 20:27 others_can_also_read\n\t----r----- 1 root root 0 2009-02-19 20:27 others_can_only_read\n\t-rw------- 1 root root 0 2009-02-19 20:29 ordinary_file\n\t-rw-r--r-- 1 root root 0 2009-02-19 20:30 everybody_read\n\t-rwxrwxrwx 1 root root 0 2009-02-19 20:31 all_for_all\n\t---------- 1 root root 0 2009-02-19 20:31 no_for_all\n\t\n\t# find -newer ordinary_file\n\t.\n\t./everybody_read\n\t./all_for_all\n\t./no_for_all\n\n**13. 通过文件大小查找文件**\n\n使用-size选项可以通过文件大小查找文件。\n\n查找比指定文件大的文件\n\n\tfind ~ -size +100M\n\n查找比指定文件小的文件\n\n\tfind ~ -size -100M\n\n查找符合给定大小的文件\n\n\tfind ~ -size 100M\n\n注意: – 指比给定尺寸小，+ 指比给定尺寸大。没有符号代表和给定尺寸完全一样大。\n\n**14. 给常用find操作取别名**\n\n若你发现有些东西很有用，你可以给他取别名。并且在任何你希望的地方执行。\n\n常用的删除a.out文件。\n\n\talias rmao=\"find . -iname a.out -exec rm {} \\;\"\n\t# rmao\n\n删除c程序产生的core文件。\n\n\talias rmc=\"find . -iname core -exec rm {} \\;\"\n\t# rmc\n\n**15. 用find命令删除大型打包文件**\n\n下面的命令删除大于100M的*.zip文件。\n\n\tfind / -type f -name *.zip -size +100M -exec rm -i {} \\;\"\n\n用别名rm100m删除所有大雨100M的*.tar文件。使用同样的思想可以创建rm1g,rm2g,rm5g的一类别名来删除所有大于1G,2G,5G的文件。\n\n\talias rm100m=\"find / -type f -name *.tar -size +100M -exec rm -i {} \\;\"\n\t# alias rm1g=\"find / -type f -name *.tar -size +1G -exec rm -i {} \\;\"\n\t# alias rm2g=\"find / -type f -name *.tar -size +2G -exec rm -i {} \\;\"\n\t# alias rm5g=\"find / -type f -name *.tar -size +5G -exec rm -i {} \\;\"\n\t\n\t# rm100m\n\t# rm1g\n\t# rm2g\n\t# rm5g\n\nFind命令示例(第二部分)\n\n若你喜欢这篇关于find命令的Mommy文章，别忘了看看第二部分的关于find命令的Daddy文章。[爹地，我找到了!, 15个极好的Linux find命令示例](http://www.oschina.net/translate/15-practical-unix-linux-find-command-examples-part-2)","mtime":1400049173000,"source":"source/_posts/妈咪，我找到了!----15个实用的linux-find命令示例.md","_id":"wn3m927xz9zs7kdf"},"ru9oqafd3y9aw6qa":{"content":"title: 最常被程序员们谎称读过的计算机书籍\ndate: 2014-05-14 11:12:05\n\n---\n马克·吐温曾经说过，所谓经典小说，就是指很多人希望读过，但很少人真正花时间去读的小说。这种说法同样适用于“经典”的计算机书籍。\n\n在[Stack Overflow](http://stackoverflow.com/)(以及其它很多软件论坛)上，诸如”[程序员最应该读的计算机书籍有哪些?](http://www.aqee.net/what-is-the-single-most-influential-book-every-programmer-should-read/)“这样的问题会周期性的出现。这样的问题不断的被提出、被回答，只是形式不同罢了。相同的几本书总是会出现在清单的前几名内，所以，如果想知道人们谈论的都是些什么，你有必要去读一读这些书的。\n\n大多数程序员真正读过的计算机书籍\n\n1. 代码大全(Code Complete)——两届Software Jolt Award震撼大奖得主！\n2. 程序员修炼之道（The Pragmatic Programmer）\n3. C程序设计语言( C Programming Language)(第2版)\n4. 重构:改善既有代码的设计（Refactoring: Improving the Design of Existing Code）\n5. 人月神话（The Mythical Man-Month）\n6. 编码——隐匿在计算机软硬件背后的语言（Code: The Hidden Language of Computer Hardware and Software）\n7. Head First 设计模式（Head First Design Patterns）\n8. 编程珠玑（Programming Pearls）\n9. Effective Java中文版（Effective Java (2nd Edition)）or Effective C++（第三版）中文版\n10. Test Driven Development: By Example\n\n上面的这些书我自己都读过，所以我不难相信很多不是很优秀的程序员也都读过它们。如果你对编程有足够的兴趣，能够来到这里读这篇博客，你很可能读过 其中的大部分，甚至还有很多不在这个清单中的，所以我就不浪费时间每本书都评论一番了。我想说的是，这个清单上的每本书都是它各自领域里的奇书。所以，很 多有愿望不断提高自己的编程技术的程序员都读过这些书，这就不足为怪了。\n\n在人们备受推崇的计算机书籍中，还有一类书受到了独特的待遇。我称下面这个清单为“最常被程序员们谎称读过的计算机书籍”。这并不是说推荐这些书的 人都没有真正读过它们。我只是有相当的信心怀疑更多的人只是在口头上宣称读过下列书籍，而实际上很少人真正读过它们。下面就是这个清单。\n\n**最常被程序员们谎称读过的计算机书籍**\n\n1. **算法导论（Introduction to Algorithms）(CLRS)** 这本书的名称是所有出版过的计算机书籍中最让人误解一个。它被广泛的使用在很多大学里，通常被当作毕业生必需的算法课程。于是，只要在大学里上过计算机课 程的学生几乎都有一本这样的书。然而，除非你拥有计算机硕士学位(而且是算法研究领域的)，我怀疑你顶多只读过算法导论（Introduction to Algorithms）里节选的几章内容。这个书名让人误解，是因为”Introduction”这个词让人以为它很适合初级程序员。实际上不是。这本书对算法做尽可能详尽综合的介绍，就像其它一些随处可见的类似的书一样。请不要再把这本书推荐给初学者。\n2. **编译原理(Compilers: Principles, Techniques, and Tools)(the Dragon Book)**.这本恐龙封面的书涵盖了开发一个编译器你所需要的全部的知识。它的内容包括词汇分析，语法分析，类型检查，代码优化，以及其它很多高深的题 目。请不要把这本书推荐给初级程序员，他们需要的只是分析简单的包含数学公式或HTML的字符串。除非你真的需要实现一个能够实用的编译器(或解释器)， 你根本不需要掌握这本“恐龙”书的全部强大威力。把它推荐给一个遇到简单文本分析问题的人，这证明你根本没有读过它。\n3. **计算机程序设计艺术(The Art of Computer Programming)(TAOCP)** 我经常听到人们把这本书描述为“每个程序员必读”的系列计算机书籍。我认为这明显不是实情。在我说出这样大不敬的话、被你们用板砖拍死之前，请让我做解释 一下。这不是一本让你一页一页翻着读的书。这是一本参考大全书。把它放在你的书架上看起来会很不错(实际上也它确实很好)，但如果想把它通读一遍，你需要 几年时间，而且最后什么都没记住。这并不是说手边放这样一本书没有什么价值。它是一本参考书，当我遇到难题，走投无路时，很多次我都在这本书里找到办法。 但这本书终究是被我当作参考书。它复杂难懂，很理论，里面的例子都是汇编语言的。好的一面是，如果你想在这本书里寻找针对某一问题的解决方案，如果你找不 到，那就说明这个问题无解。它是一本对它所涉及到的领域做了最最详尽介绍的一本书。\n4. **Design Patterns: Elements of Reusable Object-Oriented Software(Gang of Four)**这本书是唯一一本在这个清单里我从头到尾读过的书，读的结果是，我不知道该把这本书归到哪个类别。它出现在这个清单里，并不是因为我认为只有很少人真正读过它。很多人都读过。只是因为有更多推荐过这本书的人自己却没有读过。Design Patterns这边书的问题在于，很多书里给出的信息，你在其它很多地方都能看到。这样就使得一个初学者在维基百科上读了几篇关于设计模式的内容后，就敢在面试中宣称自己看过这本书。这就是为什么Singleton成 了一种新的全局变量的原因。如果有更多的人花时间读过这本也叫做Gang of Four的书的原著，那世界上就不会有这么多人会把17种设计模式硬塞到一个日志(logging)框架里了。这本书最精彩的部分是每章里描述如何正确的 使用一种模式的段落。遗憾的是，这些精华却在很多其它设计模式资料里被漏掉了。\n5. **C++程序设计语言(The C++ Programming Language)**这本书不像一本编程教材，更像一本编程语言参考。有很多的迹象表明有人确实读过这本书，否则我们不可能有这么多的C++ 编译器可选择。编程初学者(或者甚至其它语言的专家)，如果想学C++，不应该直接去啃C++程序设计语言(The C++ Programming Language)这本书。告诉他们去读《C++ Primer中文版》。\n\n正如我之前说的，我知道你们当中会有一些人真正的读过这些书。那这篇文章不是针对你的，针对的是那些企图通过假装读过这些书来表现自己的民众。 如果你自己没有读过这些计算机书籍，请不要推荐给别人。这样做会耽误别人的时间，误人子弟，因为一些阅历更丰富的人可能会有更好的书(更针对某一领域，更容易理解，跟某种编程语言或某种编程水平更契合的书)来推荐。除此之外，你也能避免被那些真正读过计算机程序设计艺术(The Art of Computer Programming)的人用MMIX知识给拷问住造成的尴尬(如果你不知道我在说什么，那我指的就是你)。\n\n[本文英文原文链接：[Books Programmers Claim to Have Read](http://www.billthelizard.com/2008/12/books-programmers-dont-really-read.html) ]","mtime":1400037391000,"source":"source/_posts/最常被程序员们谎称读过的计算机书籍.md","_id":"ru9oqafd3y9aw6qa"},"exr0jzt317dpllxi":{"content":"title: 漫画：如果用编程语言来写作文\ndate: 2014-05-14 16:02:40\n\n---\n如果说这世界上有一种东西太多了，那它就是广告。如果说这世界上还有另外一种东西太多了，那就是对软件开发的类比。\n\n这是《软件开发如同越狱》这篇文章里的一段话，说的不假，人们喜欢拿编程语言说事儿，但可惜这篇文章的这个类比的并不形象。不过也有好的类比，比如《如果编程语言是一条船… 》，这篇文章就很有意思，而且还配了图。今天的这个漫画书有点纯搞笑的意思了，用编程语言来写作文，会写出什么效果？看看老师的反应就知道了。\n\n![image](http://waakaakaa.qiniudn.com/10070749_5T5H.png)","mtime":1400054589000,"source":"source/_posts/漫画：如果用编程语言来写作文.md","_id":"exr0jzt317dpllxi"},"j129khojw890n4u1":{"content":"title: '爹地，我找到了! -- 15个极好的Linux find命令示例'\ndate: 2014-05-14 14:34:41\n\n---\n前阵子，我们审查了15件实事 find命令的例子（第一部分）。查找命令可以做很多比只是在寻找基于名称的文件 （第2部分）在这篇文章中，让我们来讨论15高级find命令的例子， 包括-根据它访问，修改或改变的时间查找文件，查找文件相比之下，执行操作找到的文件等， 拉梅什纳塔拉詹：这是我的照片中的可爱的小女儿。她很高兴地发现在加州长滩水族馆海狮。 \n\n**基于访问/修改/更改时间查找文件**\n\n你可以找到基于以下三个文件的时间属性的文件。\n\n* 访问时间的文件。文件访问时，访问时间得到更新。\n* 的文件的修改时间。文件内容修改时，修改时间得到更新。\n* 更改文件的时间。更改时间时，被更新的inode数据的变化。\n\n在下面的例子中，min选项之间的差异和时间选项是参数。\n\n* 分论点将它的参数为分钟。例如，60分钟（1小时）= 60分钟。\n* 时间参数，将它的参数为24小时。例如，时间2 = 2 * 24小时（2天）。\n* 虽然这样做的24个小时计算，小数部分都将被忽略，所以25小时为24小时，和47小时取为24小时，仅48小时为48小时。要获得更清晰的参考atime的部分find命令的手册页。\n\n**例1：找到在1个小时内被更改的文件**\n\n想要通过文件修改时间找出文件，可以使用参数 -mmin -mtime。下面是man手册中有关mmin和mtime的定义。\n\n* -mmin n 文件最后一次修改是在n分钟之内\n* -mtime n 文件最后一次修改是在 n*24小时之内（译者注：也就是n天了呗）\n\n执行下面例子中的命令，将会找到当前目录以及其子目录下，最近一次修改时间在1个小时（60分钟）之内的文件或目录\n\n\t# find . -mmin -60\n\n同样的方式，执行下面例子中的命令，将会找到24小时（1天）内修改了的文件（文件系统根目录 / 下）\n\n\t# find / -mtime -1\n\n**例2：找到1个小时内被访问过的文件**\n\n想要通过文件访问时间找出文件，可以使用参数 -amin -atime。下面是man手册中有关amin和atime的定义。\n\n* -amin n 文件最后一次访问是在n分钟之内\n* -atime n 文件最后一次访问是在 n*24小时之内\n\n执行下面例子中的命令，将会找到当前目录以及其子目录下，最近一次访问时间在1个小时（60分钟）之内的文件或目录\n\n\t# find . -amin -60\n\n同样的方式，执行下面例子中的命令，将会找到24小时（1天）内被访问了的文件（文件系统根目录 / 下）\n\n\t# find / -atime -1\n\n**例3：查找一个小时内状态被改变的文件**\n\n（译者注：这里的改变更第1个例子的更改文件内容时间是不同概念，这里是更改的是文件inode的数据，比如文件的权限，所属人等等信息）\n\n要查找文件的inode的更改时间，使用-cmin和-ctime选项\n\n* -cmin n  文件的状态在n分钟内被改变\n* -ctime n  文件状态在n*24小时内（也就是n天内）被改变\n\n（译者注：如果上面的n为-n形式，则表示n分钟/天之内，n为+n则表示n分钟/天之前）\n\n下面的例子在当前目录和其子目录下面查找一个小时内文件状态改变的文件（也就是60分钟内）：\n\n\t# find . -cmin -60\n\n同样的道理，下面的例子在根目录/及其子目录下一天内（24小时内）文件状态被改变的文件列表：\n\n\t# find / -ctime -1\n\n**例4：搜索仅仅限定于文件，不显示文件夹**\n\n上面的例子搜索出来不仅仅有文件，还会显示文件夹。因为当一个文件被访问的时候，它所处的文件夹也会被访问，如果你对文件夹不感兴趣，那么可以使用 -type f 选项\n\n下面的例子会显示30分钟内被修改过的文件，文件夹不显示：\n\n\t# find /etc/sysconfig -amin -30\n\t.\n\t./console\n\t./network-scripts\n\t./i18n\n\t./rhn\n\t./rhn/clientCaps.d\n\t./networking\n\t./networking/profiles\n\t./networking/profiles/default\n\t./networking/profiles/default/resolv.conf\n\t./networking/profiles/default/hosts\n\t./networking/devices\n\t./apm-scripts\n\t[注: 上面的输出包含了文件和文件夹]\n\t\n\t# find /etc/sysconfig -amin -30 -type f\n\t./i18n\n\t./networking/profiles/default/resolv.conf\n\t./networking/profiles/default/hosts\n\t[注: 上面的输出仅仅包含文件]\n\n**例5： 仅仅查找非隐藏的文件（不显示隐藏文件）：**\n\n如果我们查找的时候不想隐藏文件也显示出来，可以使用下面的正则式查找：\n\n下面的命令会显示当前目录及其子目录下15分钟内文件内容被修改过的文件，并且只列出非隐藏文件。也就是说，以.开头的文件时不会显示出来的\n\n\t# find . -mmin -15 \\( ! -regex \".*/\\..*\" \\)\n\n基于文件比较的查找命令\n\n我们平时通过更别的东西进行比较，会更容易记住一些事情。比如说我想找出在我编辑test文件之后编辑过的文件。你可以通过test这个文件的编辑时间作为比较基准去查找之后编辑过的文件：\n\n**例6： 查找文件修改时间在某一文件修改后的文件：**\n\n\t语法： find -newer FILE\n\n下面的例子显示在/etc/passwd修改之后被修改过的文件。对于系统管理员，想知道你新增了一个用户后去跟踪系统的活动状态是很有帮助的（万一那新用户不老实，一上来就乱搞，你很快就知道了  ^_^）：\n\n\t# find -newer /etc/passwd\n\n**例7：查找文件访问时间在某一文件的修改时间之后的文件：**\n\n\t# find -newer /etc/passwd\n\n下面的例子显示所有在/etc/hosts文件被修改后被访问到的文件。如果你新增了一个主机/端口记录在/etc/hosts文件中，你很可能很想知道在那之后有什么文件被访问到了，下面是这个命令：\n\n\t# find -anewer /etc/hosts\n\n**例8：查找状态改变时间在某个文件修改时间之后的文件：**\n\n\t语法： find -cnewer FILE\n\n下面的例子显示在修改文件/etc/fstab之后所有文件状态改变过的文件。如果你在/etc/fstab新增了一个挂载点，你很可能想知道之后哪些文件的状态发生了改变，这时候你可以使用如下命令：\n\n\t# find -cnewer /etc/fstab\n\n在查找到的文件列表结果上直接执行命令：\n\n这之前你已经看到了如果通过find命令去查找各种条件的文件列表。如果你对这些find命令还不熟悉，我建议你看完上面的第一部分\n\n接下来这部分我们向你介绍如果在find命令上执行各种不同的命令，也就是说如何去操作find命令查找出来的文件列表。\n\n我们能在find命令查找出来的文件名列表上指定任意的操作：\n\n\t# find <CONDITION to Find files> -exec <OPERATION> \\;\n\n其中的OPERATION可以是任意的命令，下面列举一下比较常用的：\n\n*  rm 命令，用于删除find查找出来的文件\n*  mv 命令，用于重命名查找出的文件\n*  ls -l 命令，显示查找出的文件的详细信息\n*  md5sum， 对查找出的文件进行md5sum运算，可以获得一个字符串，用于检测文件内容的合法性\n*  wc 命令，用于统计计算文件的单词数量，文件大小等待\n*  执行任何Unix的shell命令\n*  执行你自己写的shell脚本，参数就是每个查找出来的文件名\n\n**例9：在find命令输出上使用 ls -l， 列举出1小时内被编辑过的文件的详细信息**\n\n\t# find -mmin -60\n\t./cron\n\t./secure\n\t\n\t# find -mmin -60 -exec ls -l {} \\;\n\t-rw-------  1 root root 1028 Jun 21 15:01 ./cron\n\t-rw-------  1 root root 831752 Jun 21 15:42 ./secure\n\n**例10：仅仅在当前文件系统中搜索**\n\n系统管理员有时候仅仅想在/挂载的文件系统分区上搜索，而不想去搜索其他的挂载分区，比如/home/挂载分区。如果你有多个分区被挂载了，你想在/下搜索，一般可以按下面的这样做\n\n下面这个命令会搜索根目录/及其子目录下所有.log结尾的文件名。如果你有多个分区在/下面，那么这个搜索会去搜索所有的被挂载的分区：\n\n\t# find / -name \"*.log\"\n\n如果我们使用-xdev选项，那么仅仅会在在当前文件系统中搜索，下面是在xdev的man page上面找到的一段-xdev的定义：\n\n* -xdev Don’t descend directories on other filesystems.\n\n下面的命令会在/目录及其子目录下搜索当前文件系统(也就是/挂载的文件系统)中所有以.log结尾的文件，也就是说如果你有多个分区挂载在/下面，下面的搜索不会去搜索其他的分区的（比如/home/）\n\n\t# find / -xdev -name \"*.log\"\n\n**例11： 在同一个命令中使用多个{}**\n\nlinux手册说命令中只能使用一个{}，不过你可以像下面这样在同一个命令中使用多个{}\n\n\t# find -name \"*.txt\" cp {} {}.bkup \\;\n\n注意，在同一个命令中使用这个{}是可以的，但是在不同的命令里就不行了，也就是说，如果你想象下面这样重命名文件是行不通的\n\n\tfind -name \"*.txt\" -exec mv {} `basename {} .htm`.html \\;\n\n**例12： 使用多个{}实例**\n\n你可以像下面这样写一个shell脚本去模拟上面那个重命名的例子\n\n\t# mv \"$1\" \"`basename \"$1\" .htm`.html\"\n\n上面的双引号是为了防止文件名中出现的空格，不加的话会有问题。然后你把这个shell脚本保存为mv.sh，你可以像下面这样使用find命令了\n\n\tfind -name \"*.html\" -exec ./mv.sh '{}' \\;\n\n所以，任何情况下你在find命令执行中想使用同一个文件名多次的话，先写一个脚本，然后在find中通过-exec执行这个脚本，把文件名参数传递进去就行，这是最简单的办法\n\n**例13： 将错误重定向到/dev/nul**\n\n重定向错误输出一般不是什么好的想法。一个有经验的程序员懂得在终端显示错误并及时修正它是很重要的。\n\n尤其是在find命令中重定向错误不是个好的实践。 但是如果你确实不想看到那些烦人的错误，想把错误都重定向到null设备中（也就是linux上的黑洞装置，任何丢进去的东西消失的无影无踪了）。你可以像下面这样做\n\n\tfind -name \"*.txt\" 2>>/dev/null\n\n有时候这是很有用的。比如，如果你想通过你自己的账号在/目录下查找所有的*.conf文件，你会得到很多很多的\"Permission denied\"的错误消息， 就像下面这样：\n\n\t$ find / -name \"*.conf\"\n\t/sbin/generate-modprobe.conf\n\tfind: /tmp/orbit-root: Permission denied\n\tfind: /tmp/ssh-gccBMp5019: Permission denied\n\tfind: /tmp/keyring-5iqiGo: Permission denied\n\tfind: /var/log/httpd: Permission denied\n\tfind: /var/log/ppp: Permission denied\n\t/boot/grub/grub.conf\n\tfind: /var/log/audit: Permission denied\n\tfind: /var/log/squid: Permission denied\n\tfind: /var/log/samba: Permission denied\n\tfind: /var/cache/alchemist/printconf.rpm/wm: Permission denied\n\t[Note: There are two valid *.conf files burned in the \"Permission denied\" messages]\n\n你说烦人不？所以，如果你只想看到find命令真实的查找结果而不是这些\"Permission denied\"错误消息，你可以将这些错误消息重定向到/dev/null中去\n\n\t$ find / -name \"*.conf\" 2>>/dev/null\n\t/sbin/generate-modprobe.conf\n\t/boot/grub/grub.conf\n\t[Note: All the \"Permission denied\" messages are not displayed]\n\n**例14： 将文件名中的空格换成下划线**\n\n你从网上下载下来的音频文件的文件名很多都带有空格。但是带有空格的文件名在linux(类Unix)系统里面是很不好的。你可以使用find然后后面加上rename命令的替换功能去重命名这些文件，将空格转换成下划线\n\n下面显示怎样将所有mp3文件的文件名中的空格换成_\n\n\t$ find . -type f -iname “*.mp3″ -exec rename “s/ /_/g” {} \\;\n\n**例15： 在find结果中同时执行两条命令**\n\n在find的man page页面中，下面是一次文件查找遍历中使用两条命令的语法举例\n\n下面的find命令的例子，遍历文件系统一次，列出拥有setuid属性的文件和目录，写入/root/suid.txt文件， 如果文件大小超过100M，将其记录到/root/big.txt中\n\n\t# find / \\( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\\n' \\) , \\\n\t\\( -size +100M -fprintf /root/big.txt '%-10s %p\\n' \\)\n","mtime":1400050049000,"source":"source/_posts/爹地，我找到了!----15个极好的linux-find命令示例.md","_id":"j129khojw890n4u1"},"kzer3c5rwbkvns82":{"content":"title: '通天塔导游 - 细数各种编程语言优缺点'\ndate: 2014-05-14 11:17:16\n\n---\n![image](http://waakaakaa.qiniudn.com/151449_fUz3_28.jpg)\n\n(译注：圣经记载：在远古的时候，人类都使用一种语言，全世界的人决定一起造一座通天的塔，就是巴别塔，后来被上帝知道了，上帝就让人们使用不同的 语言，这个塔就没能造起来。 巴别塔不建自毁，与其说上帝的分化将人类的语言复杂化，不如说是人类自身心灵和谐不再的分崩离析。之所以后来有了翻译，不仅是为了加强人类之间的交流，更 寄达了一种愿望，希望能以此消除人际的隔阂，获求来自心灵的和谐及慰藉。真正的译者，把握血脉，抚平创痕，通传天籁，开启心门。)\n\n这是我写的旋风式的编程语言简介—我本来为亚马逊开发者杂志本月的期刊写的，但是发现我写的东西没法…见人。\n\n首先，我偶尔一不小心口出脏话，或者对上帝不恭的话，所以对很官方很正式的亚马逊上发表是不合适的; 所以我就把它塞到我的博客里了，我的博客反正没人看的。除了你以外。是的，只有你会看，你好啊。\n\n其次，这是一项进行中的工程，现在只是东打一耙西搞一下，还没有精加工过的。又一个把它写到博客里的很大的理由。不需要很好，或很完整。就是我今天想说的一些话。请随便！\n\n我的旋风式简介会讲C，C++，Lisp，Java，Perl，(我们在亚马逊用到的所有语言)，Ruby (我就是喜欢)，和Python，把Python加进来是因为—好吧，你看了就知道了，现在我可不说。\n\nC\n===\n\n你必须懂C。为哈? 因为出于所有现实的理由，这个世界上你过去，现在，将来会用到的每一台计算机都是一台冯·诺曼机器，而C是一种轻量级的，很有表达力的语法，能很好的展现冯·诺曼机器的能力。\n\n冯·诺曼架构就是你每天都用的计算机的架构的标准：一个CPU，内存，硬盘，一条总线。多核计算机并没有带来本质上的变化。冯·诺曼机是一个很方便，很便宜，上世纪五十年代的实现图灵机的技术，图灵机是执行计算的最知名的抽象模型。\n\n世 上还有其他的计算的机器。比如，Lisp机器，是上世纪50年代对Lisp计算模型的实现。Lisp模型是基于lambda代数的一种计算语言表示法，后 者是与图灵机同构的一种模型。不像图灵机，lambda代数能被人类读和写。但是这二者是同等能力的。它们同样精确的表示了计算机能干什么。\n\nLisp机现在不是很流行了，除了在跳蚤市场里。从谁更受欢迎来说，冯·诺曼机器赢了。还有一些其他的计算机，比如神经网络计算机，译者也不知道怎么翻的计算机(cellular automata)，但是这些都不够大众化，至少现在是这样的。\n\n所以你必须知道C。\n\n还 有一个你必须知道C的原因是，Unix是用C写的。巧的是，Windows也是。基本上所有的其他操作系统都是用C写的。因为这些操作系统都是冯·诺曼机 的操作系统，你还能用别的吗? 任何跟C很不一样的东西都会跟硬件的实际能力相差太远而导致无法满足性能上的需要，至少对一个操作系统来说是这样—至少在上个世纪是这样，碰巧这些系统都 是上个世纪的。\n\n你还应该知道Lisp。你不必用它来干实际工作，虽然它在很多GNU的软件里都会很用得着。尤其是，你应该学会Scheme，Lisp的一种小巧化的，纯洁的方言。GNU的版本叫Guile。\n\n他们在麻省理工和加州伯克利教新学生一到两个学期的Scheme，这些学生都对他们为哈要学这么奇怪的语言抓破脑袋。实话实说，作为第一门学习的语言，这是一个很烂的选择，第二门也是很烂。你应该学会它，最终，但不是作为第一门或第二门语言。\n\n这是很难的哦。这是很大的一步。学会怎么用Lisp写出像C语言的程序是不够的，那没有意义。C和Lisp一个就像红外线，一个就像紫外线，它们分布在光谱的最两端。它俩一个牛逼的地方刚好是另一个傻逼了的地方。\n\n如 果说，C是最靠近计算机是如何工作的语言模型，Lisp就是最能反映计算(注意，这里没有了“机”字，计算机和计算是很不同的！译者注)是如何工作的模 型。你不需要懂很多Lisp，真的。紧咬Scheme就哦了，因为它是最简单最干净的。其他的Lisp已经发展成了很大，很复杂(很好很强大? 译者：-)的编程环境，就像C++和Java，要有很多库啊，工具啊等等之类。那些，你不需要知道。但是你应该能用Scheme写程序。如果你能够做出 The Little Schemer和The Seasoned Schemer这两本书里的所有习题，你懂得就够多了，我认为。\n\n但是对于你天天要做的编程工作，你应该基于以下条款选择你的语言：库，文档，工具支持，操作系统集成，资源，和一堆其他的东西。这些条款跟计算机如何工作关系很小，但是跟人类如何工作关系甚大。\n\n人们还在用很直白的C语言写东西。很多东西。你应该懂C！\n\nC++\n===\n\nC++ 是地球上最蠢的语言，即使是从蠢这个字的真正意义上出发。C++很无厘头。它不知道自己是什么东西。它没有内视(面向对象里的一个概念，译者注)。C也没 有，但是C不是“面向对象”的，而面向对象很大程度上是关于要让你的程序知道它自己。对象就像演员。所以面向对象语言应该有运行时的自省机制，知道自己是 个什么类的对象。C++不是这样的，真的，你不会那样用它。\n\n关于C：写一个C的编译器是那么的简单，以至于你可以用C写一个关于C的工 具，用起来就像是有内省机制。而C++呢，基本上是不可解析的，所以如果你想写一个很牛逼的工具用来—比如，告诉你你的虚函数的原型，或者帮你重构你的代 码，你将不得不依赖别人的工具集，因为你自己在除非脑子进屎的情况下是根本不会去写一个C++的解析器的。而市面上所有的C++的解析器都很傻逼。\n\nC++很蠢，你不能用蠢语言创造一个好系统。语言决定世界，蠢语言决定蠢世界。\n\n所有的计算都基于抽象。你用低级的东西创造出高级的东西。但是你不能用分子创造出一个城市。尝试使用太低级别的抽象只会给你带来麻烦。\n\n我们就惹上麻烦了 (是指亚马逊的员工，还是所有C++的程序员? 我也不知道，译者注)。\n\n理智的情况下，你用C写的最大的东东就是一个操作系统。而操作系统其实不是很大的，真的。它们看起来很大，但那是因为它们有很多应用软件，操作系统本身的内核是蛮小的。\n\n你 用C++能写的最大的东东是…也是操作系统。好吧，或许稍微再大点儿。让我们说，再大三倍吧。或者10倍吧。但是操作系统内核最多也就，那啥，一百万行代 码? 所以我说你能用C++写的最大的系统大概也就是一千万行代码吧，再大的话就开始不行了，这玩意儿你没法控制了，就像恐怖片里的…\n\n我说的一千万行是指如果你那时候还能让你的系统编译通过的话。\n\n我们(在亚马逊，译者注)有五千万行C++代码。不，现在还要更多了。我已经不知道有多少行了。上个圣诞节是五千万行，那是九个月前，而它以每季度八百万行的规模增长。增长率本身也增长，妈呀。\n\n我们想这个系统里干点啥好像要一万年。一个亚马逊工程师有一次这样描述我们的代码库：“一座很大的屎山，你见过的最大的山，每次你想修正一个bug，你的工作就是爬到屎山的正中心去。”\n\n伙计们，那哥们可是在四年前说的这话。他现在已经到更环保绿色的牧场上去了。真是太可惜了，他可是个实实在在的高手啊。\n\n这 都是C++的错。别跟我争论。就是的。我们用的是世上最蠢的语言。这简直有点老板级的蠢，你说呢? (译者注，meta在计算机术语里通常表示更高一个层次，比如，meta-language，比普通的language高一个层次，意思是关于语言的语 言。哲学里应该会经常用到这个词。我不懂哲学，但是我觉得老板们总是比我们高一级，所以meta-dump我就翻译成老板级的蠢喽。：-)\n\n说 了以上这些难听的话，话得说回来了。用C++写出漂亮的代码显然是可以的，我的意思是说，这样的代码应该大部分还是C，偶尔很有品味的，很有节制的用一点 C++。但是这种代码几乎从来不会被写出来。C++是个很好玩的游乐场，而如果你把它玩儿得门儿清的话你会觉得自己特牛，所以你总是被诱惑把你知道的所有 的东西都用上。但是那是很难做好的，因为从一开始这个语言就太狗屎了，最终，你会弄得一塌糊涂，即使你很能干。\n\n我知道，我说的都是异端邪 说，该被钉到十字架上的。随便吧。我在大学里的时候老喜欢C++了，因为我那时候就只知道这一门语言。当我听到我的语言教授，Craig Chambers，绝对的厌憎C++，我想：“为啥呢? 我觉得它挺好的啊”。而当我听到STL(标准模板库)的发明者被采访时说他恨OOP(面向对象编程)时，我更是认为他肯定是磕药了。怎么会有人恨OOP 呢，而这个人竟然还是STL的发明者?\n\n亲不敬，熟生厌(语出圣经，译者注)。说的是在大多数情况下，跟一件事物熟悉了之后你就失去对它的膜拜尊敬了; 在计算机语言里情况不是这样的。光对一门语言熟悉不会导致你看轻这门语言。你必须成为另一门更优秀的语言的专家(才能让你明白原来那门语言有多么多的问题)。\n\n所 以如果你不喜欢我针对C++大放厥词，请你去学另一门语言并成为一个专家(我推荐Lisp)，只有那时你才有足够的武器与我争论。然而，那时你将不会跟我 争了。你上了我的当了。你也会跟我一样变得不喜欢C++了，你或许会觉得我这个人很恶心，把你骗得不喜欢自己曾经的最爱了。所以或许你应该把我说的一切都 忘了。C++挺好的其实，真的。它就是很棒棒(译者注，作者在这里用了ducky，这是一个女性喜欢用的夸某物好的词，近来也为玻璃们喜爱)。忘了我说的 话。C++不错的。\n\nLisp\n===\n\n(我打赌这一节会让你觉得惊讶，即使你已经关注我的博客有一阵了 (译者注，作者也可能是说，即使你成为亚马逊的员工有一阵了)。)\n\n亚马逊创业之初，我们有很多明星级的工程师。我不认识他们所有人，但是我认识几个。\n\n比如? Shel Kaphan。大拿。Greg Linden。大拿。Eric Benson。即使在他加入亚马逊之前就已经有自己响亮的名气了。也是大拿。\n\n他 们写了Obidos服务器。是Obidos让亚马逊成功的。只是后来那些生产大便很拿手的工程师，网页开发者，搞前端的人—这些人因为生产大便很拿手而总 是能让经理们满意—只是在后来这些人把Obidos搞糟了。(他们的大便)把整条河都堵了，打个比方说的话。但是Obidos是亚马逊最初的成功的一块关 键的基石。\n\n这些最早的牛人们在亚马逊神圣的代码库里只允许两种语言：C 和 Lisp。\n\n你自己去想吧。\n\n当 然，他们所有人都使用Emacs。靠，Eric Benson是XEmacs的作者之一。这个世界上所有伟大的工程师都在用Emacs[注1]。那种世界因你而不同级别的伟大。不是坐在你旁边的格子里的 那哥们那种伟大。也不是Fred，走廊尽头那哥们。我说的是我们这个行业里最伟大的软件开发者，那些能改变这个工业的面貌的人。像James Gosling们(Java语言设计者)，Donald Knuth们(这个人没有听说过的话赶紧改行吧，别搞计算机了)，Paul Graham们[注2]，Jamie Zawinski们，Eric Benson们。真正的工程师用Emacs。你必须很有点聪明才能把Emacs用好，而如果你能成为一个Emacs大师的话它会给你难以置信的牛力。有机 会的话你应该站到Paul Nordstrom的肩后看看他是怎么工作的，如果你不相信我的话。对那些一辈子都在用烂Visual。Net之类的集成开发环境的人来说，一定会大开眼 界的。\n\nEmacs是那种你可以用100年的编辑器。\n\nShel，Eric，Greg，和其他像他们那样的人，我没有足够幸运能跟他们直接一起工作：他们禁止在这里使用C++，他们禁止使用Perl。(或者Java，为完整起见)。他们是明白人。\n\n现在我们都在用C++，Java和Perl了，所有的代码都用这些语言。我们的前辈们已经到更环保的牧场上去了 (指没有大便的牧场，译者注)。\n\nShel 用C写了Mailman，客服部的人把它用Lisp封装了一下。Emacs-Lisp。你不需要知道Mailman是什么东西。除非你是个Amazon的 老员工，或许不是搞技术的，而且你曾经不得不让客户哈皮 (只有在这种情况下你才需要知道Mailman，译者注)。不是间接的，因为你用C++写的一个狗屎功能跑不起来了，让客户很生气，于是你不得不去搞定它 以恢复客户的哈皮度。不，我是说直接的，意思是，你必须跟他们聊。我们可爱的，不识字的，呱呱其谈的，心地善良的，充满希望的，困惑的，能帮点小忙的，愤 怒的，哈皮的客户们，真正的客户们，那些从咱们这里买东西的人，我们的客户们。(如果你必须跟他们打交道的话，)那你就会知道Mailman这个东西。\n\nMailman是客服部的客户电子邮件处理软件，我们用了它有…四，五年? 反正是很长时间。它是用Emacs写的，所有人都爱死它了。\n\n人 们现在还很爱它。直到今天，我依旧不得不听我们一些非技术员工跟我长篇大论的叨叨他们是多么的怀念Mailman。我可绝不是满嘴喷粪。上个圣诞节我参加 了一个Amazon的派对，一个我不知道自己怎么会被邀请的派对，里面全是些西装笔挺的商务人士，谁都长得比我帅，比我光鲜。以及一些我在公司里曾经打过 交道的人(这句不知道怎么译)。四个美女认出了我是在客服部里干的，把我包围了，跟我说了十五分钟她们是多么的怀念Mailman和Emacs，而现在的 亚马逊(我们用JSP花了好多年准备换掉Mailman的那一套软件)是怎么的不能满足她们，让她们觉得跟以前一样爽。\n\n这一切都太梦幻了，我觉得她们可能是喝多了。\n\nShel 是个天才。Emacs是天才。连非技术人员都爱Emacs。我现在就是在Emacs里打这些文字。我绝不情愿在任何其他地方打字。这不只是关于让你的效率 得到飞跃，通过那些地球上其他地方找不到的快捷键和文本编辑功能。我每分钟打一百三到一百四十个英文单词，在Emacs里，当我在写没有格式要求的文本的 时候。我测过这个时间速度。自己写了一个测打字速度的Emacs应用。但我想跟你说的不只是这个。\n\nEmacs有的是一种你叫不出名字来的品质。\n\n我 们现在不用Mailman了。那是因为我们有一种叫得出名字的品质—就是，烂。我们很烂。我们(当时)找不到Emacs-Lisp足够牛的人把 Mailman继续搞下去。今天这应该不难了; 亚马逊现在到处都是Emacs Lisp的黑客。但是在那时候，客服部的人没法从别人那里得到帮助。于是他们就用他们当时手头有的资源去搞这件事。他们当时没有足够多的Emacs- Lisp的人。有一段时间，他们甚至找来Bob Glickstein当合同工，那个给O'Reilly写了那本Gnu Emacs扩展的书的家伙，坐在一个小办公室里给Emacs写Mailman的扩展。\n\n客服应用部是Amazon的第一个两块比萨饼的团队 (我也不知道什么意思，看下文)。这个团队是完全自立的。不管是那时还是现在。没人跟他们说话，没人帮他们。没有枪，没有炮，他们自己造。他们没有网页工 程师，没有支持工程师。屁也没有。有的只是一堆骨灰级的工程师和一个能带新人的文化。这就是他们需要的一切了。\n\n但他们最终不得不让Mailman光荣退休。妈哎。而我呢今天还听到人们说他们是多么的怀念它。甚至在派对上。\n\n我想今天按人头比例来说，客服部仍然拥有比亚马逊任何其他团队更多的Lisp黑客。可能他们用到Lisp的机会不多了，但是Eric Raymond说过，即使你很少用Lisp写程序，学习Lisp会是意义深远的一个经历，能让你下辈子都成为一个更好的工程师。\n\n卡尔，宗教现在已经不是大众的精神鸦片了。现在鸦片是集成开发环境了。(卡尔。马克思。这个人不知道的话应该打屁屁)。\n\nJava\n===\n\nJava是过去的10年中计算行业里发生过的最好的同时也是最坏的事。\n\n一 方面，Java把你从C++编程的很多枯燥易错的细节中解救出来了。没有数组越界了，没有core dump了。抛出来的异常能让你精确定位到出错的那一行代码，而且99%的时候都是正确的那一行出错了的代码。对象们在需要的时候能智能地把它们自己打印 出来。等等等等。\n\n另一方面，除了是一种语言，一个虚拟机，一个巨无霸的类库，一个安全模型，一个可移植的字节码格式，Java还是一个宗教。邪教。所以你不能太相信对它太虔诚的人。想要招一个好的Java工程师是一项很有技术挑战的活。\n\n但是总的来说，Java是软件工程史上的一大进步。\n\n从 C++到Java不只是语法上的改变。这是一种需要一段时间去好好体会的一种震撼性的世界观的转变。这有点像突然你被配了一个执行助理。你知道老总们为什 么总是好像有时间去开会，总是知道公司现在运行的情况，总是写出很酷酷的文档吗? 老总们常常忘记其实他们不是一个人在战斗，他们都是两个全职的人，他们和他们的执行助理们。有一个执行助理把你从琐事中解救出来让你有时间去思考那些真的 需要你去解决的问题; 没有的话你将不得不花一半的时间在那些无聊的世俗的事情上。切换到Java编程语言就把你变成了两个程序员—一个处理那些你不需要关心的东西，另一个可以 集中精力在问题本身上。这是一个很震人的改变，一个你应该很快就能习惯能喜欢上的改变。\n\n就像Jamie Zawinski(Netscape牛人，开发Mozilla浏览器，好像学历是高中毕业?)在他著名的“Java真烂”那篇文章里说的：“先说那些好东 西：Java没有free()函数。我必须一开始就承认，其他的东西都没什么了不起。(没有free)是能让我原谅其他所有东西的特性，不管其他东西有多 烂。讲完这一点后，我的文章里其他一切几乎都完全没有重要性了。”\n\nJamie的文章写在1997年，按Java年来算的话是很早以前了，跟他写这篇文章时比Java已经有很大的改善; 一些他抱怨的东西甚至已经被fix了。\n\n但是大多数还是没有被fix。Java作为一门语言还是有点烂。但就如Jamie指出的，Java“是今天为止最好的语言。我的意思是说，它是今天市面上那些烂得底儿掉地一堆语言比起来有那么一点能被我接受。”\n\n真的，你应该读读他那篇文章。\n\nJava几乎每一方面都很好，除了它的语言本身，而这是JWZ抱怨的主要对象。但那是一个很大的抱怨。再好的库也救不了一个烂语言。相信我：你可能比我知道多得多的东西，但是我知道好兵救不了烂将。在Geoworks搞了五年汇编语言都会了我这个道理。\n\n跟C++比，Java作为一个语言还过得去。好吧，别扯了，Java要好很多。因为它有(内建)的字符串。哥们，你说一个没有内建的字符串的语言是人用的吗。\n\n但是Java跟C++比少了一些好东西，比如(函数调用时)传引用，栈上的对象，typedef，宏，以及运算符重载。一些时不时地会很称手的东西。\n\n哦， 还有多重继承，我现在老了，反而挺欣赏了的多重继承。如果你认为我这个观点僵硬不灵活的家伙是多态教义很好的反例的话，我倒是可以给你举几个为什么你需要 多态继承的好例子，或者至少像Ruby那样的mixin或者自动的派遣。下次问问我白龙马的事情。今天我要告诉你为什么Java的interface是个 烂货。\n\n几年前Gosling自己都说，如果一切都能重来的话，他不会搞出个interface的概念。\n\n但是那正是Java的问题。当James说出那句话的时候，人们被雷到了。我甚至能感觉到那股雷劲儿，能感觉到Sun公司市场部和法务部的鸟人是多么想把James灭口，然后告诉大家他没那么说过。\n\nJava 的问题就是人们都被那帮人搞的广告效应蒙住了眼。C++，Perl，任何流行语言都有这个问题。这是很严重的，因为如果没有一些说大话吹牛逼的广告，一个 语言是不会流行起来的。所以如果一个语言的设计者说他的语言没有被设计得很完美的话，就是赶紧用麻醉枪射击这胡说八道的家伙并关闭会议的时候了。\n\n语言们需要放点儿卫星才能活，我只希望人们不要被卫星耀瞎了眼。\n\n我 学了面向对象编程， 我自己也对此大吹大擂。当我加入亚马逊时，我不能告诉你我有什么智慧或者经验，但我可以给你背诵出所有关于OOP的魔咒。多重继承是邪恶的，因为大家都这 么说; 运算符重载是邪恶的，诸如此类。我甚至有点模糊地知道为什么是邪恶的，但实际上不知道。后来我明白了，这些都不邪恶，不是烂玩意儿，烂的是开发者，是我。 我现在还是烂，但是希望每年都不烂一点起来。\n\n上礼拜我碰到一个来面试的，他告诉我多继是邪恶的，因为，比如，你可以从头，胳膊，腿，躯干 多重继承出一个人来。他既是对的，又是错的。那样的多继情形当然邪恶，但那都是因为他自己太邪恶了。那样继承出来的“东西”远远就能看见有多蠢，如果他还 把这玩意儿弄进门来那就更邪恶了。\n\n不良开发者，占了这世上开发者的大多数，他们能用你扔给他们随便什么语言写出不良的代码。\n\n说 了这些，还是得说回来，多继不是请客吃饭那么轻松的事儿; mixin看起来是更好的解决方案，但是还没人完美的解决这个问题。但我还是认为Java比C++好，即使它没有多继。因为我知道不管我的出发点是多么 好，某一天我还是会被一堆不懂怎么写好代码的人包围，让他们用Java比用C++会带来更少的伤害。\n\n此外，Java除了语言本身外还有老多其他的重要有用的东西。且Java语言本身也在进化，虽然像冰川一样慢，所以我们还是能看到希望。Java正是我们应该在亚马逊推荐使用的语言。\n\n你就是得小心点儿，因为各其他任何语言一样，你能很容易找出一堆人，他们很懂一门语言及其编程环境，但对品味，计算或者其他任何重要的东西却一无所知。\n\n当你有怀疑时，还是雇那种会好几门语言的Java程序员，那种厌憎J2EE/EJB之类松松跨跨的所谓框架的，那种使用Emacs的。这都是一些实战经验。\n\nPerl\n===\n\nPerl，怎么说呢?\n\nPerl是个老朋友。老老朋友。我开始写Perl代码的时候，可能是1995年? 而它为我很好的服务了差不多10年的时间。\n\n它就像你骑了十万二十万英里的老自行车，你心里永远有一块地方装着它，虽然现在你已经换了一辆更加现代化的只有五磅重的自行车，而且这一辆也不像老的那辆顶得你屁眼疼了。\n\nPerl受欢迎原因有仨：\n\n用Perl你很快就能搞定你的问题。而这是最终的衡量标准。\nPerl 有世上最好的市场推广。你可以写一本介绍他们市场推广有多绝的书。Sun公司砸大笔钱给Java推市场，Perl在受欢迎程度来说能跟Java齐头并进， 但Perl纯粹是依靠Larry Wall和他那帮哥们的三寸不烂之舌做市场。哈佛商学院的人应该去研究Perl的市场是怎么做出来的。真的让人瞠目结舌。\n直到差不多，呃，现在，Perl没有真正的竞争者。\n有 比Perl“好”的语言。操，有很多比Perl好的语言，如果你定义“好”为“不是给疯子用的”的话。Lisp，Smalltalk，Python，妈 呀，我可能可以列出二三十种比Perl“好”的语言。从这些语言不像这个夏天在台湾街头爆了肚皮的抹香鲸这个角度来说。鲸鱼肠子到处都是，汽车上，机车 上，行人身上。这就是Perl。让人着迷，真的。\n\n但是Perl有很多很多好的特性，直到最近，都是其他语言没有的。它们弥补了Perl肠子在外的不足。你可以从爆了肚皮的鲸鱼可以做很多有用的东西出来，比如香水。这很有用。Perl也是这样。\n\n当其他的那些语言(尤其是Lisp和Smalltalk)都想假装操作系统并不存在，列表(Lisp的)和对象(Smalltalk的)就是把屎搞出来的唯一存在，Perl却走了截然相反的路子。Larry说：Unix和字符串是搞出屎来的唯一存在。\n\n对很多任务来说，他绝对是正确的。所以Perl绝对是Unix系统管理和字符串处理的史上最强语言，除了一个，刚出来的一个，从哥斯拉(电影哥斯拉看过没)之地出来的一个。我一会儿会讲到那一个。\n\n可 惜，Larry太太太太在意Unix系统管理和字符串处理以致他压根忘了列表和对象，等他明白过来想改正的时候已经晚了。实际上，在Perl早期的…好 吧，对鲸鱼肠子我实在不想用“设计”这个词，就说生命周期中吧，他犯的几个关键错误让把列表和对象加进来变得如此尴尬，以致Perl已经进化成一个真正的 Rube Goldberg机器，至少当你想在Perl里用列表和对象的时候。(Rube Goldberg是一漫画家，常画一些很复杂的机器，但只完成简单的工作，比如一个小球滚过很多关卡，最后把门打开。译者注)。\n\n列表和对象也他妈的是很重要的，Larry！(farging应该是作者不想说fucking那么直白，译者注)\n\nPerl 没法表达列表因为Larry一早犯了一个悲剧性的愚蠢的错误，把列表全抹平。于是(1，2，(3，4))魔术般地变成(1，2，3，4)。不是说你会想让 它这样工作，而是Larry刚好那天在搞一个这样会更方便的问题。于是Perl的数据结构从此就变得爆炸了的鲸鱼了。\n\n今天你看Perl的 书，小教程或PPT的时候，不花三分之一的时间在“引用”上是不可能的。这就是Larry可怜的，坏了的，Goldberg(漫画家，想起来没? 译者注)式的对他那抹平列表的疯狂错误的解决方案。但是Perl的市场宣传做得那么难以置信地好以致它让你觉得这是你身上发生过的最好的东西。你可以对任 何东西取它的引用。这很有趣！闻起来也很香（说肠子呢，译者注，呵呵）！\n\nPerl不能支持面向对象编程因为Larry压根不相信这玩意 儿。这可能没什么大不了; 我也不是很确定我是不是信这个OOP。但是那么为啥他又要试着把对象加进Perl呢? Perl的面向对象是个半成品，且在Perl社区里没多少人重视。它就是不像字符串处理或Unix集成那样充满灵感。\n\n当然了，Perl还 有其他很多怪怪的特性。比如它的“上下文”，这是Larry要有N个变量名字空间的喜剧式决定的一个恐怖片式的产物。这些空间由sigil来区分(就是 Perl里变量名前面的‘$’，‘@’，‘%’字符)，看着像是从shell脚本里拷贝来的。在Perl里，所有的运算符，所有的函数，所有的操作其行为 都是六取一的随机的，取决于当前的“上下文”。没有一些规则或助记法能帮你搞定这些特定操作在特定上下文里的特定行为。你得把它们全记在脑子里。\n\n想要个例子? 这儿有一个：在一个值量(scalar，对应于vector，向量)上下文里对一个哈希取值你得到一个字符串，里面是个分数，分子是目前已分配的键，分母是总共有多少个桶。鲸鱼肠子，我告诉你。\n\n但就像我说的—直到最近，没啥能像Perl那样把屎搞定。\n\nRuby\n===\n\n每 过15年左右，一门语言就会被更好的代替。C被C++代替，至少对大应用开发而又需要性能和数据类型的人们来说。C++被Java代替，而Java无疑在 7年后又会被更好的东西代替—好吧，我说的是完全代替C++的7年后，这到目前为止还没有发生，主要是因为微软能在Java霸占桌面系统之前狙击它。但是 在服务器上的应用而言，C++的阵地已经慢慢让给Java了。\n\nPerl有一天也会消逝。那是因为一门新的语言Ruby刚刚终于被翻译成英 语了。没错，它是在日本发明的，这么多地儿，没想到日本人搞出来了，还以为他们只是硬件和制造上占有名气，而不是他们的软件业，所以大家都跟你一样惊奇。 为什么呢，大家可能都在想。但是我认为这都是跟打字有关。我根本不能想象他们以前能打字打得足够快，英文字母只有26个，他们却有上万个字。但是 Emacs几年前支持多字节字符了，所以我猜他们现在打字速度他妈的快多了。(所以能搞出Ruby来了，译者猜作者是这个意思) (是的，他们也用Emacs—事实上日本人负责了Emacs多字节支持的大部工作，而且搞得坚不可摧。)\n\n不管怎么样，Ruby从Perl那里偷师了所有的好东西; 实际上，Matz，Ruby的作者(Yukihiro Matsumoto，如果我没记错的话，但是他外号“Matz”)，觉得他从Perl那里偷的有点太多了，他的鞋上也粘了些鲸鱼肠子。但是只是一丢丢。\n\n最重要的是，Ruby拿来了Perl的串处理和Unix集成，一点没改，就是说语法都是一样的，于是乎啥也不说了，你就拥有了Perl最好的那部分。这是个不错的开局，特别是如果你不把Perl剩下的东西也拿进来的话。\n\n但是之后Matz还从Lisp那里拿来的最好的列表处理，Smalltalk和其他语言那里拿来了最好的面向对象，CLU那里拿来了最好的迭代器，以及基本上是每个人每个事的最好的东西。\n\n而 他让这些东西全部都跑起来，跑得那么顺，你都不会注意到这些东西在那儿。我比其他任何语言都快就学会了Ruby，我总共会三十到四十门语言; 而我花了大概三天时间就能用Ruby比Perl还流畅地工作了，当了八年的Perl黑客后。这些东西是这么的和谐你都能自己猜它们是怎么工作的，而且大多 数时候你都能猜对。漂亮。有趣。靠谱。\n\n如果把语言比成自行车，那么AWK就是一辆粉系的儿童自行车，前面有个白色小框，还插块小 旗，Perl就是沙滩车(还记得那有多酷吧? 唉。)，而Ruby则是一辆七千五美金的钛合金山地自行车。从Perl飞跃到Ruby意义不下于从C++到Java的飞跃。却没有任何缺陷，因为Ruby 几乎是Perl功能的一个超集，而Java却拿掉了一些人们想要的东西，且没有真正的提供一个替代品。\n\n下次我会写更多关于Ruby的东 西。我先需要灵感。去读读Lucky Stiff的(poignant) guide to Ruby吧。那本书是一本有灵感的书。真的，读一下。超赞。我不理解产生它的那种头脑，但它很有趣，很犀利，且全是关于Ruby的。好像。你会看到的。\n\nPython\n===\n\n啊，Python怎么说呢，一个不错的语言，这么多年来一直旁边在等待它的机会? Python社区很长时间以来是那些勇敢地吞下红药片从Perl骇客帝国中醒来的人的避难营。\n\n啊，有点像Smalltalk的人们，他们永远在等待替代C++，没想到半路杀出Java一下把它们操翻了，漂亮地，永久地。哎哟。Ruby正在对Python做着同样的事，现在，今天。可能会在一夜之间吧。\n\nPython本来可以统治世界，可惜它有两个致命缺陷：空格，和冷淡。\n\n空 格很简单，就是说Python是用缩进来表达代码块之间的嵌套。它强制你必须按一定格式把所有的东西缩进，他们这样做是为了让所有人写的代码看上去一样。 不料蛮多程序员讨厌这点，因为他们觉得自己的自由被拿走了; 感觉就像Python侵犯了宪法赋予他们的可以随便缩进格式和全写在一行上的权利。\n\nPython 的作者，Guido Van Rossum，也在早期犯过一些很傻地技术错误—没有像Larry的失误那么严重，但是还是有几个。比如，最早Python没有字面变量范围，但它同时也 没有动态变量范围，而动态变量范围可能会有它一些问题，但它还是有用的。Python却没有这些，只有全局的和本地(函数)的两种范围。所以即使它是一个 真正的OO系统，类甚至不能访问它们自己的动态成员变量。你必须给成员函数传“self”参数，一大堆self参数很快就会把你搞疯掉，即使你不在意空格 问题。\n\n等等之类。\n\n但在我看来，Python不行其实是因为冷淡。这阻止了它成为首选脚本语言，或者首选一切语言。靠，人们现在还在用Tcl作嵌入解释执行器，虽然Python比Tcl好得不要太多—除了，我说，这个冷淡问题。\n\n此处开始我不知所云。呵呵，这样吧，把原文贴在最后面。\n\n注1，Eric告诉我当时几乎全是Jamie Zawinski，当他们在Lucid工作的时候。\n\n注2，我写了这个之后很多人告诉我Paul Graham是用VI的，想不到。\n\n注3，为了有据可查，我个人根本不介意空格问题。我认为因为这个而不喜欢Python是很傻的。我只是说有一堆比例让人惊奇的其他工程师讨厌空格问题。\n\nWhat's the frost thing, you ask? Well, I used to have a lot of exceptionally mean stuff written here, but since Python's actually quite pleasant to work with (if you can overlook its warts), I no longer think it's such a great idea to bash on Pythonistas。The \"frost thing\" is just that they used to have a tendency to be a bit, well, frosty。Why?\n\nBecause they were so tired of hearing about the whitespace thing！\n\nI think that's why Python never reached Perl's level of popularity, but maybe I'm just imagining things。\n\nCoda\n\nThat was the ADJ article I really wanted to write。Or at least something like it。For some reason, though, my true feelings only seem to come out during insomniac attacks between 3am and 6am。Time for bed！2 hours 'til my next meeting。\n\n这才是我真正想给亚马逊开发者杂志写的文章。或者至少是这样的。出于某些原因，我的真感情好像只有在我凌晨三点到六点失眠的时候都会流露。该睡觉了！我下个会议再过两小时就开始了。\n\n(发布于2004年9月，小小的更新在3/28/2006)\n\n本文转载自：http://code.google.com/p/windows-config/wiki/TourDeBabel","mtime":1400038587000,"source":"source/_posts/通天塔导游---细数各种编程语言优缺点.md","_id":"kzer3c5rwbkvns82"},"pepx9re4phu5c15g":{"content":"title: '龙纹身女孩和 SQL'\ndate: 2014-05-14 11:39:02\n\n---\n我喜欢大卫·芬奇(David Fincher)拍的电影《龙纹身女孩》，他成功的把小说《龙纹身女孩》搬上了荧幕，超出了我的预期。我本以为这又是一部肤浅的、愤世嫉俗的用来敛钱的好莱坞电影，事实情况却是，这是一部情节紧张，能引起共鸣的电影，只是里面的淫杀犯罪让人毛骨悚然。我最喜欢的一个情节是龙纹身女孩用SQL来查找40年前的凶杀案的过程。\n\n![image](http://waakaakaa.qiniudn.com/07063334_bQur.jpg)\n\n我们从电影里可以看到她使用笔记本电脑，轻而易举的进入瑞典警察局数据库，当她敲入像‘unsolved(未破案)’和‘decapitation(斩首)’等关键词时，屏幕上翻滚着绿色的检索出的信息，虽然我们看不清她使用的完整的查询语句：\n\n![image](http://waakaakaa.qiniudn.com/07063335_Gdmf.jpg)\n\n处于一种天生的好奇，我忍不住截取了这些镜头画面，用Photoshop拼接了一下，下面是我得到的结果：\n\n![image](http://waakaakaa.qiniudn.com/07063335_FVKP.jpg)\n\n你马上能发现，这不是Oracle SQL——很显然 AS 关键字在Oracle里不能用在表假名上。事实上，如果我们回去看看她那个令人兴奋的查询结果输出时，你会看到 mysql 的提示符，而且还有 use [dbname] 连接数据库的语法，下面是一个更详细的画面：\n\n![image](http://waakaakaa.qiniudn.com/07063335_0rrP.jpg)\n\n我们实际上可以把她用的left join关键词表的SQL语句整理出来。\n\n最终我们获得了一个全屏的输出结果信息：\n\n![image](http://waakaakaa.qiniudn.com/07063336_bdtZ.jpg)\n\n下面就是我们Oracle“WTF研究会”部门重新构造出的她使用的SQL：\n\n\tSELECT DISTINCT v.fname, v.lname, i.year, i.location, i.report_file\n\tFROM   Incident AS i\n    \t   LEFT JOIN V(ictim?)...  -- presumably v.incident_id = i.id\n    \t   LEFT JOIN Keyword AS k ON k.incident_id = i.id\n\tWHERE  i.year BETWEEN 1947 AND 1966\n\tAND    i.type = 'HOMICIDE'\n\tAND    v.sex = 'F'\n\tAND    i.status = 'UNSOLVED'\n\tAND    ...\n    \t   OR v.fname IN ('Mari', 'Magda')\n    \t   OR SUBSTR ...\n\tAND    (k.keyword IN ('rape', 'decapitation', 'dismemberment', 'fire', \t'altar', 'priest', 'prostitute')\n    \t   ...\n    \t   AND SUBSTR(v.fname, 1, 1) = 'R' AND SUBSTR(v.lname, 1, 1) = 'L');\n\n\t+--------+---------+------+-----------+----------------------------------+\n\t| fname  | name    | year | location  | report_file                      |\n\t+--------+---------+------+-----------+----------------------------------+\n\t| Anna   | Wedin   | 1956 | Mark      | FULL POLICE REPORT NOT DIGITIZED |\n\t| Linda  | Janson  | 1955 | Mariestad | FULL POLICE REPORT NOT DIGITIZED |\n\t| Simone | Grau    | 1958 | Goteborg  | FULL POLICE REPORT NOT DIGITIZED |\n\t| Lea    | Persson | 1962 | Uddevalla | FULL POLICE REPORT NOT DIGITIZED |\n\t| Kajsa  | Severin | 1962 | Dals-Ed   | FULL POLICE REPORT NOT DIGITIZED |\n\t+--------+---------+------+-----------+----------------------------------+\n\n你也许会很惊讶，很奇怪，这样一个顶级的黑客为什么要outer-join的方式连接Victims(被害人)表和Keywords(关键词)表呢，还使用这样的文字过滤方式，岂不知MySQL里是有 like 语法的，更奇怪的是输出结果里根本没有姓和名分别以’R L’打头的受害人。\n\n[本文英文原文链接：[The Girl With The ANSI Tattoo](http://oracle-wtf.blogspot.co.uk/2012/05/girl-with-ansi-tattoo.html) ]","mtime":1400039247000,"source":"source/_posts/龙纹身女孩和-sql.md","_id":"pepx9re4phu5c15g"},"0yzoqiba8icpgk9k":{"content":"title: 想提升工作效率，就別再做这七件事\ndate: 2014-05-13 22:05:07\ntags:\n\n---\n原文出处： [medium](https://medium.com/business-marketing/a988c17383a6)   译文出处： [inside - elaine](http://www.inside.com.tw/2014/05/06/7-things-you-need-to-stop-doing-to-be-more-productive)。\n\n试想一位小公司老板每日孜孜不倦地工作，为何不能从为数众多的竞争者脱颖而出？\n\n一位创业家可以不眠不休一天工作24 小时，整整一周不休假。 然而，时间有限，且竞争者却永远可以投入更多钱与心力，让竞争更剧烈。 那么，为什么某些小型新创公司可以完成许多大型企业无法完成的事情呢？\n\n* Instagram──只有13 名员工却被Facebook 用几十亿买下的公司。\n* Snapchat──只有30 名员工却拒绝科技巨人Facebook、Google 的并购交易。\n\n它们的成功部分来自于幸运──其余则是因为效率 。\n\n![image](http://waakaakaa.qiniudn.com/13070427_yMGK.jpg)\n\n>成功的关键不是努力工作，而是用聪明的方式工作。\n\n有效率并不是指良好的时间管理，而是──管理您的精力。 人们都需要学习如何花费最少的精力能够得到最大效益。\n\n要提升生产力，下面这些事情绝对要避免：\n\n一、停止加班，提升效率！\n===\n\n1926年，福特汽车工业亨利福特（Henry Ford）执行了一项实验发现有趣的结果：当把一日的工时从10 小时降到8 小时，从一周工作6 天减少至一周5 天，人们的生产力将会提高（注一）。\n\n![image](http://waakaakaa.qiniudn.com/13070428_YiKB.jpg)\n\n当您工作得越多，不论是短期或长期而言，您的效率、生产力都会降低。 1980 年由The Business Roundtable 的一篇研究〈Scheduled Overtime Effect on Construction Projects〉指出（注二）：\n\n>当每周工作时间超过60 小时，并持续超过两个月，生产力下降的累积效应将使完工日期推迟，而人数相同但每周只工作40 小时的团队执行同样工作，甚至还会更早完工。\n\n在AlterNet的一篇文章中，Sara Robinson回顾美军执行的一项研究，这项发现「每晚都减少1小时睡眠，持续一周，将导致认知功能退化，等同于喝酒使血液酒精浓度升高至0.10 。\n\n>当个人过于劳累，使其以比平常还要负面的角度看事情，导致普遍地心情低落。 比心情更重要的是，其思维往往伴随着减少「主动思考与行动」──包括控制冲动、自我感觉良好、同情他人与情绪智力──的意愿（注三）。\n\n维持高程度的生产力，避免让自己过度工作并睡眠充足很重要。 下次您思想为何工作缺乏生产力，原因很简单，您有可能缺乏睡眠。\n\n二、不要太常说「yes」\n===\n\n根据80/20 法则（Pareto Principle），20% 的努力创造80% 的成果，20% 的成果消耗80% 的时间。 不是努力工作，我们应该把注意力放在创造80% 的结果并放弃其余的。 我们应该把更多时间放在最重要的任务。 我们应该停止对低效能与无效能的任务说：「好的，我来做」 。\n\n>「成功的人」与「非常成功的人」之间的差异在于，非常成功的人对几乎所有的事情都说不。\n— Warren Buffet\n\n激发一个问题：什么事情要说yes，什么事情说no？ 如果您不能想出某些值得花时间的地方，就考虑作个小测试找出答案：追踪您作的所有事情，可能的话持续优化处理的过程。\n\n通常人们说「yes」的频率比实际上应该的次数还要多，因为说「yes」比说「no」要简单太多，没有想要当坏人。\n\n![image](http://waakaakaa.qiniudn.com/13070428_cBNK.jpg)\n\n2012 研究发表在Journal of Consumer Research，研究者将120 个学生分成两组。 一组被训练为说「我不能（I can’t）」，然而其他被训练为「我不要（I don’t）」。 结果很有趣：\n\n>对自己说「我不能吃X」的学生，61% 都会选择吃巧克力糖，同时，对自己说「我不要吃X」的学生，只有36 % 会选择吃巧克力糖。 光是简单的词汇替换，就能显著增加人们选择更健康食品的机率。 （延伸阅读： [拒当YES MAN，说「不」让生活更美好](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://www.inside.com.tw/2013/10/29/a-scientific-guide-to-effectively-saying-no&usg=ALkJrhgMw7cVfeXo4d_hKEbt95D-zMiMGQ) 。）\n\n三、停止什么都事必躬亲，让其他人帮忙\n===\n\n在我职涯的某个点，我管理一个非常大的社群，而我无法处理得很好。 我试图每一件事情都自己来。 我疲倦不堪，但社群最终接管我的职责并自行治理。 因此我也学习到社群的力量，以及为什么品牌需要使用者创造的内容（user-generated content）。\n\n消费者知道他们想要什么，以及他们想要如何让它更好，更甚于任何行销人员。 根据[Octoly](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://www.reelseo.com/earned-media-rankings-youtube-octoly/&usg=ALkJrhgzhU-mCRf3wGDSLoVVuvTFdroUwg) ，一支使用者自制影片的观看次数要比品牌自制影片多上十倍。 当寻找关于一个特定品牌的资讯，超过半数（51 %）的美国人相信使用者自制内容大过于品牌官网（16%）与媒体报导（14 %），对行销人员来说，寻求社群的帮忙至关重要。\n\n![image](http://waakaakaa.qiniudn.com/13070428_SSg9.jpg)\n\n除此之外， 当您需要时，很重要地是愿意求助，让其他人来帮您。 因为这样可以让您有更多时间将焦点放在更重要的任务上。\n\n大多数的时候，即使您的朋友不能帮助您提升生产力。 光是陪在您身边就足够， 研究证实：分心的人在其他人也在场的情况，尽管那些人没有协助或指导，也可以完成更多的工作事项。\n\n四、停止完美主义\n===\n\nDalhousie University心理学教授Simon Sherry博士Simon Sherry执行一项完美主义与生产力的研究 ，她指出：我们发现完美主义是绊倒教授的研究生产力的大石头。 完美主义倾向越高的教授就越没有效率。\n\n当一位完美主义者有以下问题：\n\n他们在一项花费的时间比任务要求所花费的时间还多。\n他们会拖延并等到最佳的时刻。 在企业中，如果这是最完美的时刻，就代表已经太迟了。\n他们过度聚焦在细节，反而忽略整体。\n\n五、停止作重复的事情，并使它自动化\n===\n\n根据一项Tethy Solutions的研究 ，一个5人团队分别花3%、20%、25%、30%与70%的时间处理相同的事情，导入工作自动化软体两个月后，分别将处理重复事情的时间降至3%、10%、15%、15% 与10%。\n\n![image](http://waakaakaa.qiniudn.com/13070428_tuQA.jpg)\n\n人们时常忘记时间就是金钱，因此经常土法炼钢地处理事情，因为这样比较容易，且不需要花费心力研究。 假设您办了一个Instagram 活动，号召网友上传的照片总数只有30 张，您可以手动一张一张处理。 但如果总共有从5个不同平台上传的30000张照片与影片时，您就需要一个好的数位管理系统了（例如[Filemobile](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://www.filemobile.com/&usg=ALkJrhiH_0Hf9V6834m_3cfnbJrlPZ0B4Q) ）。\n\n给行销人员的小撇步 ：到GitHub或Google app script library,通常会发现免费且可马上使用的开源程式码，让您找到省去手动处理重覆工作的软体/程式。\n\n六、停止猜测，并开始用数据支撑决策\n===\n\n如果您可以在搜寻引擎上优化网站，那么您也可以优化您的人生，让它成长并发挥最大的潜能。\n\n不同领域的研究其实都可供参考，举例来说，宾州州立大学心理系助理教授Robert Matchock 所执行的研究发现，大部分的人们最容易分心的时间是从中午到下午四点。 此数据便提供您作工作相关决策的考量。 假使您无法从现有研究找到答案，那么您也可以自行执行简单的测试。\n\n举例来说，Filemobile就制定了许多测试，试图找出[如何优化Twitter的图片呈现](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://blog.filemobile.com/twitter-image-preview/&usg=ALkJrhhq8qKSuTXA5DdkH3vMrob9nwYdcQ) 。\n\n不断询问您自己：要如何测量并优化所有事情呢？\n\n七、停止工作，并拥有无所事事的时间\n===\n\n大部分的人都没有了解到，当我们专注在某件事上，基本上就像是把自己锁在一个箱子里。 很重要的是要每隔一段时间离开工作现场，享受独处的时光。 独处时光对大脑与灵魂都有益处（注四）：\n\n>一项哈佛研究指出，当人们相信他们是单独经验某项事情时，脑海的记忆会更持久且更精确。 另外一个研究也指出体验相当程度的孤独会让一个人更能够同理他人……相当程度的孤独可以帮助青少年改善心情与获得好成绩。\n\n我们不会因为熬夜而更有效率。 就像是生命中的每件事情，需要耗费心力。 如果您什么都不做只是坐着等，不会有什么改变，所以我们要更了解自己的限制与潜能，并将精力作有效的配置，过一个更成功、更快乐的人生。\n\n注释：\n\n注一、注二：Calculating Loss of Productivity Due to Overtime Using Published Charts — Fact or Fiction\n\n注三： [The Secret World of Sleep: The Surprising Science of the Mind at Rest](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://www.amazon.ca/The-Secret-World-Sleep-Surprising/dp/0230107591&usg=ALkJrhgXdjeqJJv7m0F5gnGL2Gv2WMOF_w)\n\n注四： [The power of lonely](http://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=zh-CN&tl=zh-CN&u=http://www.boston.com/bostonglobe/ideas/articles/2011/03/06/the_power_of_lonely/&usg=ALkJrhgbCWPtJybh1b8ljBHlC7hyg2yXYA)","mtime":1399990828000,"source":"source/_posts/想提升工作效率，就別再做这七件事.md","_id":"0yzoqiba8icpgk9k"},"pb2uq1sn34tzw7ua":{"content":"title: 转载：hexo你的博客\ndate: 2014-05-07 14:09:48\n\n\n---\n原文链接：<http://ibruce.info/2013/11/22/hexo-your-blog/>\n\n一直纠结于哪里写博客，曾用过新浪博客，百度空间，JavaEye，LOFTER，OSChina，cnblogs，CSDN，自搭WordPress，都不满意。再后来也弄过Jekyll和Octopress，觉累不爱。\n\n直到多看了一眼hexo，这个逼格极高的程序猿写作方式，我喜欢。就连hexo的发音都像是**黑客哦**！如果你跟我一样纠结哪里写博，那就来到GitHub吧，让我们一起hexo！H人希绝对不会让你失望，相信很快hexo就会流行起来。\n\nhexo出自台湾大学生[tommy351](http://twitter.com/tommy351)之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ [Hexo颯爽登場](http://zespia.tw/blog/2012/10/11/hexo-debut)。\n\n* *如果你对默认配置满意，只需几个命令便可秒搭一个hexo。*\n* *如果你跟我一样喜欢折腾下，30分钟也足够个性化。*\n* *如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。* \n\n搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。\n\n只需要几个简单命令，你就可以完成一切。\n\n\thexo n #写文章\n\thexo g #生成\n\thexo d #部署 # 可与hexo g合并为 hexo d -g\n\n下面逐步介绍，进入正题。\n\n<!--more-->\n\n***\n\n环境准备\n=======\n\n**安装Node**\n\n到[Node.js](http://nodejs.org/)官网下载相应平台的[最新版本](http://nodejs.org/download)，一路安装即可。我用的是[node-v0.10.22-x86.msi](http://nodejs.org/dist/v0.10.22/node-v0.10.22-x86.msi)\n\n**安装Git**\n\nGit的客户端很多，我用的是[msysgit](http://code.google.com/p/msysgit)，喜欢用绿色版本[Portable application for official Git for Windows 1.8.4](http://code.google.com/p/msysgit/downloads/detail?name=PortableGit-1.8.4-preview20130916.7z)，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n\n**安装Sublime（可选）**\n\n[Sublime Text 2](http://www.sublimetext.com/)在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的[Sublime Text 3](http://www.sublimetext.com/3)。我用绿色版本[Portable Sublime Text 2.0.2.zip](http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.zip)。\n\n> 本屌是穷码畜，对于高大上的Mac码帅用户请移步：[hexo installation](http://zespia.tw/hexo/docs/installation.html)\n\nGitHub\n======\n\n> GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。\n\n* 首先注册一个『GitHub』帐号，已有的默认默认请忽略\n* 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』\n* 添加SSH公钥到『Account settings -> SSH Keys -> Add SSH Key』\n\n![my GitHub Pages](http://bruce.u.qiniudn.com/2013/11/22/hexo-your-blog/my-github-pages.jpg)\n\n前两步忽略，只说第三步，**添加SSH-Key**。\n\n首先设置你的用户名密码：\n\n\tgit config --global user.email \"bu.ru@qq.com\"\n\tgit config --global user.name \"bruce-sha\"\n\n生成密钥：\n\n\tssh-keygen -t rsa -C \"bu.ru@qq.com\"\n\n输入文件路径：\n\n\tH:\\hexo\\blog>ssh-keygen -t rsa -C \"bu.ru@qq.com\"\n\tGenerating public/private rsa key pair.\n\tEnter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh\n\tEnter passphrase (empty for no passphrase):\n\tEnter same passphrase again:\n\tYour identification has been saved in H:\\git\\myssh\\ssh.\n\tYour public key has been saved in H:\\git\\myssh\\ssh.pub.\n\tThe key fingerprint is:\n\tb0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com\n\n> 有个bug，文件路径中的盘符H必须大写，否则会报错。\n\n上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：\n\n1. 用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到[Add SSH Key](http://github.com/settings/ssh)\n2. 将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4\\.ssh\n\n![Add SSH Keys](http://bruce.u.qiniudn.com/2013/11/22/hexo-your-blog/add-ssh-keys.jpg)\n\n最后可以验证一下：\n\n\tssh -T git@github.com\n\t\n若有问题，请重新设置。常见错误请参考：\n\n[GitHub Help - Generating SSH Keys](http://help.github.com/articles/generating-ssh-keys)\n\n[GitHub Help - Error Permission denied (publickey)](http://help.github.com/articles/error-permission-denied-publickey)\n\n安装\n====\n\nNode和Git都安装好后，可执行如下命令安装hexo：\n\n\tnpm install -g hexo\n\t\n初始化\n=====\n\n然后，执行init命令初始化hexo到你指定的目录：\n\n\thexo init <folder>\n\n> 也可以cd到目标目录，执行hexo init。\n\n好啦，至此，全部安装工作已经完成！\n\n生成静态页面\n=====\n\ncd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。\n\n\thexo generate\n\t\n> 命令必须在init目录下执行，否则不成功，但是也不报错。\n\n> 当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。\n\n本地启动\n====\n\n执行如下命令，启动本地服务，进行文章预览调试。\n\n\thexo server\n\t\n浏览器输入[http://localhost:4000](http://localhost:4000/)就可以看到效果。\n\n> 请使用高级浏览器，否则可能…你懂的！\n\n写文章\n====\n\n执行new命令，生成指定名称的文章至hexo\\source\\_posts\\postName.md。\n\n\thexo new [layout] \"postName\" #新建文章\n\t\n其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags:\n\t---\n\n> 请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。\n\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\n\n\ttitle: { { title } }\n\tdate: { { date } }\n\tcategories: \n\ttags: \n\t---\n\npostName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用\"将其包围，postName可以为中文。\n\n> 注意，所有文件：后面都必须有个空格，不然会报错。\n\n看一下刚才生成的文件hexo\\source\\_posts\\postName.md，内容如下：\n\n\ttitle: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中\n\tdate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\n\tcategories: #文章分类目录，可以为空，注意:后面有个空格\n\ttags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n\t---\n\t这里开始使用markdown格式输入你的正文。\n\n接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章[Markdown简明语法](http://bruce-sha.github.io/2013/11/26/markdown/)。\n\n**fancybox**\n\n可能有人对这个[Reading](http://bruce-sha.github.io/reading/)页面中图片的[fancybox](http://fancyapps.com/fancybox/)效果感兴趣，这个是怎么做的呢。\n\n很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：\n\n\tlayout: photo\n\ttitle: 我的阅历\n\tdate: 2085-01-16 07:33:44\n\ttags: [hexo]\n\tphotos:\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\t- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n\n> 经过测试，文件头上的layout: photo可以省略。\n\n不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md\n\n\tlayout: { { layout } }\n\ttitle: { { title } }\n\tdate: { { date } }\n\ttags: \n\tphotos: \n\t- \n\t---\n\n然后每次可以执行带layout的new命令生成照片文章：\n\n\thexo new photo \"photoPostName\" #新建照片文章\n\t\n**description**\n\nmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。\n\n\ttitle: hexo你的博客\n\tdate: 2013-11-22 17:11:54\n\tcategories: default\n\ttags: [hexo]\n\tdescription: 你对本页的描述\n\t---\n\n> hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。\n\n**文章摘要**\n\n在需要显示摘要的地方添加如下代码即可：\n\n\t以上是摘要\n\t<!--more-->\n\t以下是余下全文\n\nmore以上内容即是文章摘要，在主页显示，more以下内容点击『> Read More』链接打开全文才显示。\n\n>hexo中所有文件的编码格式均是UTF-8。\n\n主题安装\n====\n\n萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表[Hexo Themes](http://github.com/tommy351/hexo/wiki/Themes)。\n\n我比较喜欢[pacman](http://github.com/A-limon/pacman)，[modernist](http://github.com/heroicyang/hexo-theme-modernist)、[ishgo](http://github.com/DavidKk/Hexo.ishgo)，[raytaylorism](http://github.com/raytaylorlin/hexo-theme-raytaylorism)。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。\n\n安装主题的方法就是一句git命令：\n\n\tgit clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n\t\n> 目录是否是modernist无所谓，只要与_config.yml文件一致即可。\n\n安装完成后，打开hexo\\_config.yml，修改主题为modernist\n\n\ttheme: modernist\n\n打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：\n\n\tmenu: #配置页头显示哪些菜单\n\t#  Home: /\n\t  Archives: /archives\n\t  Reading: /reading\n\t  About: /about\n\t#  Guestbook: /about\n\n\texcerpt_link: Read More #摘要链接文字\n\tarchive_yearly: false #按年存档\n\n\twidgets: #配置页脚显示哪些小挂件\n\t  - category\n\t#  - tag\n\t  - tagcloud\n\t  - recent_posts\n\t#  - blogroll\n\n\tblogrolls: #友情链接\n\t  - bruce sha's duapp wordpress: http://ibruce.duapp.com\n\t  - bruce sha's javaeye: http://buru.iteye.com\n\t  - bruce sha's oschina blog: http://my.oschina.net/buru\n\t  - bruce sha's baidu space: http://hi.baidu.com/iburu\n\n\tfancybox: true #是否开启fancybox效果\n\n\tduoshuo_shortname: buru #多说账号\n\n\tgoogle_analytics:\n\trss:\n\n更新主题\n\n\tcd themes/modernist\n\tgit pull\n\n评论框\n====\n\n静态博客要使用第三方评论系统，hexo默认集成的是[Disqus](http://disqus.com/)，因为你懂的，所以国内的话还是建议用[多说](http://duoshuo.com/)。\n\n直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的**基本设置->域名**中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以[参考这里](http://dev.duoshuo.com/docs/4ff1cfd0397309552c000017)，我是在[HeroicYang](http://gist.github.com/heroicyang/5644407)的基础上修改的。\n\n如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout\\_partial\\comment.ejs里面，如下：\n\n\t<% if (config.disqus_shortname && page.comments){ %>\n\t<section id=\"comment\">\n\t  #你的通用代码\n\t<% } %>\n\n自定义页面\n====\n\n执行new page命令\n\n\thexo new page \"about\"\n\t\n在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。\n\n上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。\n\n> 因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。\n\n404页面\n====\n\nGitHub Pages [自定义404页面](http://help.github.com/articles/custom-404-pages)非常容易，直接在根目录下创建自己的**404.html**就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。\n其实，404页面可以做更多有意义的事，来做个404公益项目吧。现在，看下我的404页面[一个ibruce.info上不存在的页面](http://ibruce.info/nothing)，做点有意义的事情，也对得起这个域名。\n目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。\n\n* [腾讯公益404](http://www.qq.com/404)\n* [404公益_益云(公益互联网)社会创新中心](http://yibo.iyiyun.com/Index/web404)\n* [失蹤兒童少年資料管理中心404](http://404page.missingkids.org.tw/)\n\n图床\n===\n\n考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。\n\n免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，不够的话点这个[活动页面](http://ibruce.info/2013/11/22/hexo-your-blog/)，也可通过邀请好友获得奖励，我也求一下[七牛邀请](http://portal.qiniu.com/signup?code=3lqr4z3p7clea)。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里[关于key-value存储系统](http://kb.qiniu.com/key-value-system)。\n\n七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇[Linux中国采用七牛云存储支撑图片访问](http://linux.cn/thread/11986/1/1)。\n\n如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。\n\n>如果你对七牛web版的文件管理界面不满意，可以用官方的[七牛云存储工具](http://docs.qiniu.com/tools/v6/index.html)。\n\n您还可以使用如下图床服务 [FarBox](http://www.farbox.com/)，[Dropbox](http://www.dropbox.com/)，[又拍云](http://www.upyun.com/)。\n\n申请域名（可选）\n===\n\nGitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。\n\n如果你对上述域名不满意，可以到[狗爹](http://www.godaddy.com/)上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。\n\n**GoDaddy**\n\n买域名首选狗爹，国内的服务商大家都懂的。\n\n目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到[独特优惠码](http://www.dute.me/)找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。\n付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。\n\n>建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。\n\n**DNSPod**\n\nGoDaddy的NameServers有时会被墙，因此墙裂推荐国内的[DNSPod](http://www.dnspod.cn/)解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。\n\n两步设置就可以搞定，怎么操作参考[Godaddy注册商域名修改DNS地址](http://support.dnspod.cn/Kb/showarticle/tsid/42)。\n\n命令\n===\n\n**常用命令：**\n\n\thexo new \"postName\" #新建文章\n\thexo new page \"pageName\" #新建页面\n\thexo generate #生成静态页面至public目录\n\thexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\thexo deploy #将.deploy目录部署到GitHub\n\t\n**常用复合命令：**\n\n\thexo deploy -g\n\thexo server -g\n\n**简写：**\n\n\thexo n == hexo new\n\thexo g == hexo generate\n\thexo s == hexo server\n\thexo d == hexo deploy\n\n***\n\n**至此，基本操作介绍完毕，以下内容普通用户无需了解。**\n\n***\n\n目录介绍\n===\n\n默认目录结构：\n\n\t.\n\t├── .deploy\n\t├── public\n\t├── scaffolds\n\t├── scripts\n\t├── source\n\t|   ├── _drafts\n\t|   └── _posts\n\t├── themes\n\t├── _config.yml\n\t└── package.json\n\n* .deploy：执行hexo deploy命令部署到GitHub上的内容目录\n* public：执行hexo generate命令，输出的静态网页内容目录\n* scaffolds：layout模板文件目录，其中的md文件可以添加编辑\n* scripts：扩展脚本目录，这里可以自定义一些javascript脚本\n* source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。\n\t- _drafts：草稿文章\n\t- _posts：发布文章\n* themes：主题文件目录\n* _config.yml：全局配置文件，大多数的设置都在这里\n* package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮\n\n接下来是重头戏_config.yml，做个简单说明：\n\n\t# Hexo Configuration\n\t## Docs: http://zespia.tw/hexo/docs/configure.html\n\t## Source: https://github.com/tommy351/hexo/\n\n\t# Site #整站的基本信息\n\ttitle: 不如 #网站标题\n\tsubtitle: 码农，程序猿，未来的昏析师 #网站副标题\n\tdescription: bruce sha's blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head->meta中可看到\n\tauthor: bruce #网站作者，在下方显示\n\temail: bu.ru@qq.com #联系邮箱\n\tlanguage: zh-CN #语言\n\n\t# URL #域名和文件结构\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://ibruce.info #你的域名\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\ttag_dir: tags\n\tarchive_dir: archives\n\tcategory_dir: categories\n\tcode_dir: downloads/code\n\n\t# Writing #写文章选项\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post #默认layout方式\n\tauto_spacing: false # Add spaces between asian characters and western characters\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tmax_open_file: 100\n\tmulti_thread: true\n\tfilename_case: 0\n\trender_drafts: false\n\thighlight: #代码高亮\n\t  enable: true #是否启用\n\t  line_number: false #是否显示行号\n\t  tab_replace:\n\n\t# Category & Tag #分类与标签\n\tdefault_category: uncategorized # default\n\tcategory_map:\n\ttag_map:\n\n\t# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\n\t# Server #本地服务参数\n\t## Hexo uses Connect as a server\n\t## You can customize the logger format as defined in\n\t## http://www.senchalabs.org/connect/logger.html\n\tport: 4000\n\tlogger: true\n\tlogger_format:\n\n\t# Date / Time format #日期显示格式\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: MMM D YYYY\n\ttime_format: H:mm:ss\n\n\t# Pagination #分页设置\n\t## Set per_page to 0 to disable pagination\n\tper_page: 10 #每页10篇文章\n\tpagination_dir: page\n\n\t# Disqus #社会化评论disqus，我使用多说，在主题中配置\n\tdisqus_shortname:\n\n\t# Extensions #插件，暂时未安装插件\n\t## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n\t## Themes: https://github.com/tommy351/hexo/wiki/Themes\n\t## 主题\n\ttheme: modernist # raytaylorism # pacman # modernist # light\n\texclude_generator:\n\n\t# Deployment #部署\n\t## Docs: http://zespia.tw/hexo/docs/deploy.html\n\tdeploy:\n\t  type: github\n\t  repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库\n\t  \n修改局部页面\n===\n\n页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\你使用的主题\\中，以modernist主题为例：\n\n\t.\n\t├── languages          #多语言\n\t|   ├── default.yml    #默认语言\n\t|   └── zh-CN.yml      #中文语言\n\t├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制\n\t|   ├── _partial       #局部的布局，此目录下的*.ejs是对头尾等局部的控制\n\t|   └── _widget        #小挂件的布局，页面下方小挂件的控制\n\t├── source             #源码\n\t|   ├── css            #css源码 \n\t|   |   ├── _base      #*.styl基础css\n\t|   |   ├── _partial   #*.styl局部css\n\t|   |   ├── fonts      #字体\n\t|   |   ├── images     #图片\n\t|   |   └── style.styl #*.styl引入需要的css源码\n\t|   ├── fancybox       #fancybox效果源码\n\t|   └── js             #javascript源代码\n\t├── _config.yml        #主题配置文件\n\t└── README.md          #用GitHub的都知道\n\n如果你需要修改头部，直接修改hexo\\themes\\modernist\\layout\\_partial\\header.ejs，比如头上加个搜索框：\n\n\t<div>\n\t<form class=\"search\" action=\"//google.com/search\" method=\"get\" accept-charset=\"utf-8\">\n\t <input type=\"search\" name=\"q\" id=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" maxlength=\"20\" placeholder=\"Search\" />\n\t <input type=\"hidden\" name=\"q\" value=\"site:<%- config.url.replace(/^https?:\\/\\//, '') %>\">\n\t</form>\n\t</div>\n\n将如上代码加入即可，您需要修改css以便这个搜索框比较美观。\n\n再如，你要修改页脚版权信息，直接编辑hexo\\themes\\modernist\\layout\\_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。\n\n统计\n===\n\n因Google Analytics偶尔被墙，故用百度统计，以modernist主题为例，介绍如何添加。\n\n编辑文件hexo\\themes\\modernist\\_config.yml，增加配置选项：\n\n\tbaidu_tongji: true\n\n新建文件hexo\\themes\\modernist\\layout\\_partial\\baidu_tongji.ejs，内容如下：\n\n\t<% if (theme.baidu_tongji){ %>\n\t<script type=\"text/javascript\">\n\t#你的百度统计代码\n\t</script>\n\t<% } %>\n\n>注册并登录百度统计获取你的统计代码。\n\n编辑文件hexo\\themes\\modernist\\layout\\_partial\\head.ejs，在『/head』之前增加：\n\n\t<%- partial('baidu_tongji') %>\n\n重新生成并部署你的站点。\n\n>不出意外的话，在你的站点的每个页面的左上角都会看到一个恶心的百度LOGO。你只能在『百度统计首页->网站列表->获取代码->系统管理设置->统计图标设置->显示图标』，把那个勾去掉。百度真是恶心，我准备还是用Google Analytics。\n\n分享\n===\n\n我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加：\n\n* 在hexo\\themes\\modernist\\layout\\_partial\\post下新建jiathis.ejs文件。\n* 注册加网获得你的分享代码，写入jiathis.ejs。\n* 在hexo\\themes\\modernist\\layout\\_partial\\article.ejs中，添加<%-partial(‘post/jiathis’)%>。\n\n分享服务还可以使用如下企业提供的技术[加网](http://www.jiathis.com/)，[bShare](http://www.bshare.cn/)，[百度分享](http://share.baidu.com/)。\n\n网站图标\n===\n\n看一下hexo\\themes\\modernist\\layout\\_partial\\head.ejs，找到这句：\n\n\t<link rel=\"icon\" type=\"image/x-icon\" href=\"<%- config.root %>favicon.ico\">\n\n你懂的，将你的favicon.ico放到工程根目录下即可，也就是hexo\\source目录。可以在Faviconer制作你的ico图标，国内有[比特虫](http://www.bitbug.net/)。\n\n自定义挂件\n===\n\n除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\\themes\\modernist\\layout\\_widget\\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\\themes\\modernist\\_config.yml中配置。\n\n\twidgets:\n\t  - myWidget\n\n用上述方法可以添加新浪微博小挂件。\n\n* 生成自己的[微博组件](http://open.weibo.com/widgets?cat=wb)。\n* 添加hexo\\themes\\modernist\\layout\\_widget\\weibo.ejs文件。\n* 配置hexo\\themes\\modernist\\_config.yml。\n\n插件\n===\n\n安装插件：\n\n\tnpm install <plugin-name> --save\n\n启用插件：在*hexo\\_config.yml文件添加：\n\n\tplugins:\n\t- <plugin-name>  #插件名\n\n升级插件：\n\n\tnpm update\n\n卸载插件：\n\n\tnpm uninstall <plugin-name>\n\n**RSS插件**\n\n将上述命令中的『plugin-name』，替换为hexo-generator-feed。一旦安装完成，你可以在配置显示你站点的RSS，文件路径\\atom.xml。\n\n你可以用rss作为迁移工具，用如下命令读取其他位置的rss：\n\n\thexo migrate rss <source>\n\n>『source』是本地或网络文件路径。\n\n**Sitemap插件**\n\n将上述命令中的『plugin-name』，替换为hexo-generator-sitemap。你可以将你站点地图提交给搜索引擎，文件路径\\sitemap.xml。\n\n更多插件的安装方法，请参考[官方Wiki](http://github.com/tommy351/hexo/wiki/Plugins)。\n\n>如果你按照上述步骤做，但插件不起作用，没有生成atom.xml和sitemap.xml，也没有报错，那么你应该cd到你的hexo初始化目录，在该目录下重新安装插件，重试。\n\n迁移\n===\n\nhexo支持从其他类型站点迁移，如通用RSS，Jekyll，Octopress，WordPress等，这一部分我没试过。请参考官方文档[Hexo Migration](http://zespia.tw/hexo/docs/migration.html)。\n\n搜索引擎\n===\n\n你可以到[屈站长](http://www.sousuoyinqingtijiao.com/)提交你的站点给搜索引擎。其他内容如添加站点或页面的description，提交Sitemap，添加百度统计，Google Analytics等等，参考本文其他章节的内容，不再一一阐述。\n\n更新\n===\n\n更新hexo：\n\n\tnpm update -g hexo\n\n更新主题：\n\n\tcd themes/你的主题\n\tgit pull\n\n更新插件：\n\n\tnpm update\n\n干掉IE\n===\n\nKill IE6 提示的javascript代码，请自行搜索。\n\n换机器\n===\n\n你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，[Hexo 服务器端布署及 Dropbox 同步](http://lucifr.com/2013/06/02/hexo-on-cloud-with-dropbox-and-vps/)。\n\n我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。\n\n统计功能\n===\n\n[为hexo博客添加访问次数统计功能](http://bruce-sha.github.io/2013/12/22/count-views-of-hexo)\n\n其它\n===\n\n**网站加速**\n[Webluker-CDN 网站加速 免费CDN DNS解析](http://www.webluker.com/)\n[Webluker-FAQ索引](http://blog.webluker.com/)\n\n**网站监控**\n[监控宝-网站监控 网页监控 服务器监控](http://www.jiankongbao.com/)\n[监控宝-常见问题](http://www.jiankongbao.com/faq)\n\n>DNSPod本身就有D监控可用。\n\n**站长工具**\n\n[谷歌站长工具](http://www.google.com/intl/zh-CN/webmasters)\n[百度站长工具](http://zhanzhang.baidu.com/)\n[站长之家工具](http://tool.chinaz.com/)\n[360搜索站长平台](http://zhanzhang.so.com/)\n[360网站安全检测](http://webscan.360.cn/)\n[奇云测](http://ce.cloud.360.cn/index)\n[360云监控](http://jk.cloud.360.cn/)\n\n**SEO**\n[谷歌搜索引擎优化初学者指南.PDF](http://www.google.com/intl/zh-CN/webmasters/docs/search-engine-optimization-starter-guide-zh-cn.pdf)\n\n**数据统计**\n[百度统计](http://tongji.baidu.com/)\n[Google Analytics](http://www.google.com/analytics/web/?hl=zh-CN)\n\n**企业邮箱**\n[腾讯企业邮箱](http://exmail.qq.com/)\n[在DNSPod域名解析商处如何设置企业邮箱](http://service.exmail.qq.com/cgi-bin/help?subtype=1&&id=20012&&no=1000931)\n\n**图片生成**\n[邮箱地址生成图片](http://pic.sdodo.com/tool/mailpic)\n[MakePic.com邮址图片生成](http://www.makepic.com/email.php)\n\n**徽章生成**\n[Logo Creatr](http://creatr.cc/creatr)\n[Web 2.0 Logo Creator](http://www.simwebsol.com/imagetool) (可能需翻墙)\n\n**文章推荐/猜你喜欢**\n[无觅关联推荐](http://www.wumii.com/widget/relatedItems)\n[友荐](http://www.ujian.cc/)\n[乐知推荐](http://www.lezhi.me/)\n[百度推荐](http://tuijian.baidu.com/)\n\n**广告**\n[百度联盟](http://union.baidu.com/)\n\n不足\n===\n\n* 配置文件缺少空格会报错\n* 报错不能得到精确定位，只能靠经验\n* 换台机器写文章不好处理\n* 如何统计总来访数和单页文章阅读次数，请参考[为hexo博客添加访问次数统计功能](http://bruce-sha.github.io/2013/12/22/count-views-of-hexo)。\n\n结束\n===\n\n我的博客[『ibruce.info』](http://bruce-sha.github.io/)基本算是免费做出来的，为报答开源社区，特写这篇文章，由于水平有限，错误之处在所难免，请诸位多多包涵，不吝指点。\n\n在此一并感谢[GitHub](http://github.com/)，[Hexo](http://github.com/tommy351/hexo)，[Modernist](http://github.com/heroicyang/hexo-theme-modernist)，[七牛](http://www.qiniu.com/)，[多说](http://duoshuo.com/)，[公益404](http://www.qq.com/404)，[GoDaddy](http://www.godaddy.com/)，[DNSPod](http://www.dnspod.cn/)，[百度统计](http://tongji.baidu.com/)，[Google Analytics](http://www.google.com/analytics/web/?hl=zh-CN)，以及[Node.js](http://nodejs.org/)，[MSYSGit](https://code.google.com/p/msysgit)，[Sublime Text 2](http://www.sublimetext.com/)，最后感谢[Markdown](http://xbeta.org/wiki/show/Markdown)。\n\n>关于以上内容的任何问题，您都可以对[bruce](http://bruce-sha.github.io/2013/11/22/hexo-your-blog)留言或邮件<bu.ru@qq.com>。\n\n参考文献\n===\n\n1. [Hexo](http://zespia.tw/hexo)\n2. [使用Hexo在Github上搭建个人博客](http://www.7yeshu.com/2013/09/03/hexo)\n3. [hexo教程](http://sys.la/2013/09/07/hexo)\n4. [hexo系列教程：（四）hexo博客的优化技巧](http://zipperary.com/2013/05/30/hexo-guide-4)\n5. [hexo系列教程：（五）hexo博客的优化技巧续](http://zipperary.com/2013/06/02/hexo-guide-5)\n6. [_折腾了个新主题](http://heroicyang.com/2013/05/22/hexo-theme-modernist)\n7. [使用hexo搭建博客](http://yangjian.me/workspace/building-blog-with-hexo)\n8. [从Octopress到Hexo](http://lucifr.com/2013/01/02/from-octopress-to-hexo)\n9. [搞定Hexo](http://blog.archean.me/2013/10/20/fulfil-with-hexo-theme)\n10. [Hello World by Hexo](http://mekong.github.io/2013/06/hello-world)\n11. [hexo的代码高亮](http://popozhu.github.io/2013/06/15/hexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE)\n12. [用Hexo快速打造静态博客_](http://blog.ishgo.cn/2013/09/15/ishgohexo%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98)\n13. [使用Sublime Text 2 编辑Markdown](http://www.ituring.com.cn/article/6815)\n14. [给hexo添加一个404页面](http://jiabin.tk/2013/07/01/add-page-404-for-my-blog)\n15. [GotGitHub](http://www.worldhello.net/gotgithub/index.html)\n16. [搭建一个免费的，无限流量的Blog — github Pages和Jekyll入门](http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html)\n17. [Godaddy注册商域名修改DNS地址](https://support.dnspod.cn/Kb/showarticle/tsid/42)\n18. [WordPress中使用七牛云存储加速图片等静态文件访问速度](http://devework.com/wordpress-qiniu.html)\n19. [怎样搭建一个自有域名的WordPress博客](http://www.zhihu.com/question/19594033?group_id=121391355)\n20. [Hexo服务器端布署及Dropbox同步](http://lucifr.com/2013/06/02/hexo-on-cloud-with-dropbox-and-vps)","mtime":1399454030000,"source":"source/_posts/转载：hexo你的博客.md","_id":"pb2uq1sn34tzw7ua"},"iwalx996pivp0yxf":{"content":"<%- partial('_partial/archive', {pagination: config.archive, index: true}) %>","mtime":1399382133000,"source":"themes/modernist/layout/archive.ejs","_id":"iwalx996pivp0yxf"},"zjpws440ijpttfwt":{"content":"<%- partial('_partial/archive', {pagination: 2, index: true}) %>","mtime":1399382133000,"source":"themes/modernist/layout/index.ejs","_id":"zjpws440ijpttfwt"},"je4lvxyb68q49d20":{"content":"<%- partial('_partial/head') %>\n<body>\n  <div class=\"wrapper\">\n    <%- partial('_partial/header') %>\n    <div class=\"content\"><%- body %></div>\n  </div>\n  <footer id=\"footer\"><%- partial('_partial/footer') %></footer>\n  <%- partial('_partial/after-footer') %>\n</body>\n</html>","mtime":1399382133000,"source":"themes/modernist/layout/layout.ejs","_id":"je4lvxyb68q49d20"},"ikx9n4nxmvt4hdd0":{"content":"<%- partial('_partial/article', {post: page, index: false}) %>","mtime":1399382133000,"source":"themes/modernist/layout/page.ejs","_id":"ikx9n4nxmvt4hdd0"},"dz1pkk3augd5bupg":{"content":"<%- partial('_partial/article', {post: page, index: false}) %>","mtime":1399382133000,"source":"themes/modernist/layout/post.ejs","_id":"dz1pkk3augd5bupg"},"cu6hgif6njlcrv1h":{"content":"<%- partial('_partial/archive', {pagination: config.tag, index: true}) %>","mtime":1399382133000,"source":"themes/modernist/layout/tag.ejs","_id":"cu6hgif6njlcrv1h"},"r0bg2rx6nufsdcmb":{"content":"<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js\"></script>\n<script src=\"<%- config.root %>js/scale.fix.js\"></script>\n<script src=\"<%- config.root %>js/jquery.imagesloaded.min.js\"></script>\n<script src=\"<%- config.root %>js/gallery.js\"></script>\n\n<% if (config.disqus_shortname){ %>\n<script type=\"text/javascript\">\n  var disqus_shortname = '<%= config.disqus_shortname %>';\n\n  (function(){\n    var dsq = document.createElement('script');\n    dsq.type = 'text/javascript';\n    dsq.async = true;\n    dsq.src = 'http://' + disqus_shortname + '.disqus.com/<% if (page.comments){ %>embed.js<% } else { %>count.js<% } %>';\n    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n  }());\n</script>\n<% } else if (theme.duoshuo_shortname){ %>\n<script type=\"text/javascript\">\n  var duoshuoQuery = { short_name: '<%= theme.duoshuo_shortname %>' };\n  (function() {\n    var ds = document.createElement('script');\n    ds.type = 'text/javascript';\n    ds.async = true;\n    ds.src = 'http://static.duoshuo.com/embed.js';\n    ds.charset = 'UTF-8';\n    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);\n  })();\n</script>\n<% } %>\n\n<% if (theme.fancybox){ %>\n<link rel=\"stylesheet\" href=\"<%- config.root %>fancybox/jquery.fancybox.css\" media=\"screen\" type=\"text/css\">\n<script src=\"<%- config.root %>fancybox/jquery.fancybox.pack.js\"></script>\n<script type=\"text/javascript\">\n  (function($){\n    $('.fancybox').fancybox();\n  })(jQuery);\n</script>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/after-footer.ejs","_id":"r0bg2rx6nufsdcmb"},"jtdw06z704a06vti":{"content":"<article class=\"<%= post.layout %>\">\n  <header>\n    <%- partial('post/date', { date_format: theme.archive_date_format }) %>\n    <%- partial('post/title') %>\n  </header>\n</article>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/archive-post.ejs","_id":"jtdw06z704a06vti"},"3tr5zsxp4e6dfzil":{"content":"<%\nvar title = '', classes = 'archives-title';\n\nif (is_category()) {\n  title = page.category;\n  classes += ' category';\n} else if (is_tag()) {\n  title = page.tag;\n  classes += ' tag';\n} else if (is_archive()) {\n  if (is_year()) {\n    title = page.year;\n  } else if (is_month()) {\n    title = page.year + page.month;\n  }\n}\n%>\n\n<% if (title) { %>\n<h2 class=\"<%= classes %>\"><span><%= title %></span></h2>\n<% } %>\n\n<% if (pagination == 2){ %>\n  <% page.posts.each(function(post){ %>\n    <%- partial('article', {post: post, index: true}) %>\n  <% }); %>\n\n  <%- partial('pagination') %>\n<% } else { %>\n  <% var last; %>\n  <% page.posts.each(function(post, i){ %>\n    <% var year = post.date.year(); %>\n    <% if (last != year){ %>\n      <% if (last != null){ %>\n        </div></section>\n      <% } %>\n      <% last = year; %>\n      <section class=\"archives-wrapper\">\n        <% if (!title) { %>\n        <h2 class=\"archives-title archives-year\">\n          <a href=\"<%- config.root %>archives/<%= year %>\"><%= year %></a>\n        </h2>\n        <% } %>\n        <div class=\"archives\">\n    <% } %>\n    <%- partial('archive-post', {post: post}) %>\n  <% }) %>\n  <% if (page.posts.length){ %>\n    </div></section>\n  <% } %>\n<% } %>\n","mtime":1399382133000,"source":"themes/modernist/layout/_partial/archive.ejs","_id":"3tr5zsxp4e6dfzil"},"ahz8jmwccjxhx1kd":{"content":"<article class=\"<%= post.layout %>\">\n  <header>\n    <% if (post.layout != 'page'){ %>\n      <div class=\"icon\"></div>\n      <%- partial('post/date', { date_format: config.date_format }) %>\n    <% } %>\n    <%- partial('post/title') %>\n  </header>\n  <% if (post.photos && post.photos.length > 0){ %>\n    <%- partial('post/gallery') %>\n  <% } %>\n  <div class=\"entry\">\n    <% if (post.excerpt && index){ %>\n      <%- post.excerpt %>\n    <% } else { %>\n      <%- post.content %>\n    <% } %>\n  </div>\n  <footer<% if (index) { %> class=\"end-sep\"<% } %>>\n    <% if (index){ %>\n      <% if (post.excerpt){ %>\n        <div class=\"alignleft\">\n          <a href=\"<%- config.root %><%- post.path %>#more\" class=\"more-link\"><%= __('excerpt_title') %></a>\n        </div>\n      <% } %>\n      <% if (post.comment && config.disqus_shortname){ %>\n      <div class=\"alignright\">\n        <a href=\"<%- post.permalink %>#disqus_thread\" class=\"comment-link\">Comments</a>\n      </div>\n      <% } %>\n    <% } else { %>\n      <%- partial('post/category') %>\n      <%- partial('post/tag') %>\n    <% } %>\n    <div class=\"clearfix\"></div>\n  </footer>\n</article>\n\n<%- partial('comment') %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/article.ejs","_id":"ahz8jmwccjxhx1kd"},"xw4jhj8x5kmmyghm":{"content":"<% if (config.disqus_shortname && page.comments){ %>\n<section id=\"comment\">\n  <h1 class=\"title\"><%= __('comment') %></h1>\n  <div id=\"disqus_thread\">\n    <noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n  </div>\n</section>\n<% } else if (theme.duoshuo_shortname && page.comments){ %>\n<section id=\"comment\">\n  <h1 class=\"title\"><%= __('comment') %></h1>\n  <div class=\"ds-thread\" data-title=\"<%= post.title %>\">\n  </div>\n</section>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/comment.ejs","_id":"xw4jhj8x5kmmyghm"},"h6qko1c1qpy46zjh":{"content":"<div class=\"copyright\">\n  <% if (config.author){ %>\n  &copy; <%= new Date().getFullYear() %> <a href=\"<%- config.root %>\"><%= config.author %></a>\n  <% } else { %>\n  &copy; <%= new Date().getFullYear() %> <a href=\"<%- config.root %>\"><%= config.title %></a>\n  <% } %>\n</div>\n<div class=\"theme-copyright\">\n  Theme by <a href=\"https://github.com/orderedlist\" target=\"_blank\">orderedlist</a>\n   | \n  Redesign by <a href=\"http://heroicyang.com/\" target=\"_blank\">Heroic Yang</a>\n</div>\n<div class=\"clearfix\"></div>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/footer.ejs","_id":"h6qko1c1qpy46zjh"},"wuo1ungiy62tmpff":{"content":"<% if (theme.google_analytics){ %>\n<script type=\"text/javascript\">\n  var _gaq = _gaq || [];\n  _gaq.push(['_setAccount', '<%= theme.google_analytics %>']);\n  _gaq.push(['_trackPageview']);\n\n  (function() {\n    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n  })();\n</script>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/google-analytics.ejs","_id":"wuo1ungiy62tmpff"},"fx4v9t4odbpg2rcs":{"content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"chrome=1\">\n  <%\n  var title = page.title;\n  \n  if (is_archive()) {\n    title = __('archive_title');\n\n    if (is_month()) {\n      title += ': ' + page.year + '/' + page.month;\n    } else if (is_year()) {\n      title += ': ' + page.year;\n    }\n  } else if (is_category()) {\n    title = __('category_title') + ': ' + page.category;\n  } else if (is_tag()) {\n    title = __('tag_title') + ': ' + page.tag;\n  }\n\n  var description = page.description || '';\n  if (!description) {\n    if (page.excerpt) {\n      description = strip_html(page.excerpt);\n    } else if (page.content) {\n      description = strip_html(page.content);\n    }\n  }\n  description = description.substring(0, 200).replace(/^\\s+|\\s+$/g, '');\n  %>\n  <title><% if (title) { %><%= title %> | <% } %><%= config.title %></title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n  <% if (config.author){ %>\n    <meta name=\"author\" content=\"<%= config.author %>\">\n  <% } %>\n  <% if (description){ %>\n    <meta name=\"description\" content=\"<%= description %>\">\n  <% } %>\n  <%- open_graph() %>\n  <% if (theme.rss){ %>\n    <link rel=\"alternate\" href=\"<%- theme.rss %>\" title=\"<%= config.title %>\" type=\"application/atom+xml\">\n  <% } %>\n  <% if (theme.favicon){ %>\n    <link rel=\"icon\" type=\"image/x-icon\" href=\"<%- theme.favicon %>\">\n  <% } %>\n  <%- css('css/style.css') %>\n  <!--[if lt IE 9]><script src=\"//html5shiv.googlecode.com/svn/trunk/html5.js\"></script><![endif]-->\n  <%- partial('google-analytics') %>\n</head>\n","mtime":1399382133000,"source":"themes/modernist/layout/_partial/head.ejs","_id":"fx4v9t4odbpg2rcs"},"lhqykki9klkt24ji":{"content":"<header id=\"header\">\n  <div class=\"title\">\n    <h1><a href=\"<%- config.root %>\"><%= config.title %></a></h1>\n    <p><a href=\"<%- config.root %>\"><% if (config.subtitle){ %><%= config.subtitle %><% } %></a></p>\n  </div>\n  <nav class=\"nav\">\n    <ul>\n      <% for (var i in theme.menu){ %>\n        <li><a href=\"<%- theme.menu[i] %>\"><%= i %></a></li>\n      <% } %>\n      <% if (theme.rss) { %>\n        <li><a href=\"<%- theme.rss %>\"><%- __('rss_title') %></a></li>\n      <% } %>\n    </ul>\n    <div class=\"clearfix\"></div>\n  </nav>\n  <div class=\"clearfix\"></div>\n</header>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/header.ejs","_id":"lhqykki9klkt24ji"},"jmronzmqrh1b3mg7":{"content":"<nav id=\"pagination\">\n  <% if (page.prev){ %>\n    <a href=\"<%- config.root %><%- page.prev_link %>\" class=\"prev\"><%= __('prev') %></a>\n  <% } %>\n  <% if (page.next){ %>\n    <a href=\"<%- config.root %><%- page.next_link %>\" class=\"next\"><%= __('next') %></a>\n  <% } %>\n  <div class=\"clearfix\"></div>\n</nav>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/pagination.ejs","_id":"jmronzmqrh1b3mg7"},"7lvjl9o20rpsfp5j":{"content":"<% if (post.categories && post.categories.length > 0){ %>\n  <div class=\"categories\">\n    <%- list_categories(post.categories, {\n      show_count: false,\n      class: 'categories',\n      style: 'none'\n    }) %>\n  </div>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/post/category.ejs","_id":"7lvjl9o20rpsfp5j"},"sqlp91idrc7hvr4p":{"content":"<a href=\"<%- config.root %><%- post.path %>\">\n  <time datetime=\"<%= date_xml(post.date) %>\">\n    <%= date(post.date, date_format) %>\n  </time>\n</a>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/post/date.ejs","_id":"sqlp91idrc7hvr4p"},"x5yb6gvbum5c80se":{"content":"<div class=\"gallery\">\n  <div class=\"photoset\">\n    <% if (post.photos.length){ %>\n      <% post.photos.forEach(function(photo){ %>\n        <img src=\"<%- photo %>\">\n      <% }); %>\n    <% } else { %>\n      <img src=\"<%- post.photos %>\">\n    <% } %>\n  </div>\n  <div class=\"control\">\n    <div class=\"prev\"></div>\n    <div class=\"next\"></div>\n  </div>\n</div>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/post/gallery.ejs","_id":"x5yb6gvbum5c80se"},"hfcc7ta4zcagrcut":{"content":"<% if (post.tags && post.tags.length > 0){ %>\n  <div class=\"tags\">\n    <%- list_tags(post.tags, {\n      show_count: false,\n      style: 'none',\n      class: 'tags'\n    }) %>\n  </div>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/post/tag.ejs","_id":"hfcc7ta4zcagrcut"},"ywkctzi688y6fyus":{"content":"<% if (post.link){ %>\n  <h1 class=\"title\"><a href=\"<%- post.link %>\" target=\"_blank\"><%= post.title %></a></h1>\n<% } else { %>\n  <% if (index){ %>\n    <h1 class=\"title\"><a href=\"<%- config.root %><%- post.path %>\"><%= post.title %></a></h1>\n  <% } else { %>\n    <h1 class=\"title\"><%= post.title %></h1>\n  <% } %>\n<% } %>","mtime":1399382133000,"source":"themes/modernist/layout/_partial/post/title.ejs","_id":"ywkctzi688y6fyus"}}}