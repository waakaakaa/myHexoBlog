<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>归档: 2014 | 挖之家</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Xin Zhang">
  
  
  <meta content="website" property="og:type">
<meta content="挖之家" property="og:title">
<meta content="http://waakaakaa.github.io/archives/2014/page/2/" property="og:url">
<meta property="og:image">
<meta content="挖之家" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">挖之家</a></h1>
    <p><a href="/">太阳每天都是欣的</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">


<h2 class="archives-title"><span>2014</span></h2>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/tcp三次握手四次挥手详解/">
  <time datetime="2014-05-14T07:51:16.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/tcp三次握手四次挥手详解/">TCP三次握手/四次挥手详解</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>一，TCP(Transmission Control Protocol)　传输控制协议</strong></p>
<p>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p>
<p><strong>二，三次握手过程</strong></p>
<p>第一次握手：主机A发送位码为SYN＝1，随机产生seq =X 的数据包到服务器，主机B由SYN=1知道，A要求建立联机。（A处于SYN - SENT，B处于LISTEN）</p>
<p><img src="http://waakaakaa.qiniudn.com/021331_vUTD_264328.png" alt="image"></p>
<p>第二次握手： 主机B收到请求（根据SYN=1）后要确认联机信息，向A发送ack =(X+1),SYN=1,ACK=1,随机产生seq=Y的包 。（B处于SYN — RECEIVED）</p>
<p><img src="http://waakaakaa.qiniudn.com/021343_N70t_264328.png" alt="image"></p>
<p>第三次握手：主机A收到后检查ack是否正确，即第一次发送的seq+1,以及位码ACK是否为1，若正确，主机A会再发送ack =(Y+1),ACK=1，主机B收到后确认seq值与ack=1则连接建立成功。（记住此时SYN！=1）  （A发送完ESTABLISHED，B接受到为ESTABLISHED）</p>
<p><img src="http://waakaakaa.qiniudn.com/021354_IPUM_264328.png" alt="image"></p>
<p>完成三次握手，主机A与主机B开始传送数据。一个完整的三次握手也就是 请求—-应答—-再次确认</p>
<p><strong>三，四次挥手：</strong></p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p>
<p>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li><p>客户端A发送一个FIN=1，用来关闭客户A到服务器B的数据传送。  （此时A处于FIN - WAIT-1，等待B的FIN=1）</p>
</li>
<li><p>服务器B收到这个FIN=1，它发回一个ACK=1，确认序号：X+1。   （此时B处于CLOSE - WAIT-1）</p>
</li>
<li><p>服务器B发送完数据，发送一个FIN=1给客户端A。（此时B处于LAST - ACK，A处于FIN - WAIT-2）</p>
</li>
<li><p>客户端A发回ACK=1报文确认，并将确认序号设置为收到序号加1   （此时A处于TIME - WAIT，B处于CLOSEED）</p>
</li>
</ol>
<p><strong>四，问题汇总</strong></p>
<p><strong>1. 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>
<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。</p>
<p>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送，但未必所有的数据都全部发送给对方，所以你未必会马上关闭SOCKET，也即你可能还需要发送一些数据给对方，之后再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<p><strong>2. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</strong></p>
<p>这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；</p>
<p>但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
<p><strong>3. 什么是2MSL</strong></p>
<p>MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>因为TCP报文（segment）是IP数据报（datagram）的数据部分，而IP头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<p>RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等</p>
<p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间。</p>
<p>等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。</p>
<p>在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。</p>
<p>当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<p>TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p>
<p><strong>4. SYN攻击</strong></p>
<p>在三次握手过程中，服务器【发送SYN-ACK之后，收到客户端的ACK之前】的TCP连接称为半连接(half-open connect)。此时服务器处于SYN_RECV状态，当收到ACK后，服务器转入ESTABLISHED状态.</p>
<p>SYN攻击就是：攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复ACK确认包，并等待客户的确认从而建立连接。由于源地址是不存在的，不会再发送ACK确认包，所以服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p>SYN攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p>
<p>在Linux下可以如下命令检测是否被Syn攻击：netstat  -n  -p  TCP | grep SYN_RECV</p>
<p>一般较新的TCP/IP协议栈都对这一过程进行修正来防范SYN攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等。但是不能完全防范syn攻击。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/aop-那点事儿/">
  <time datetime="2014-05-14T07:08:13.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/aop-那点事儿/">AOP 那点事儿</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>又是一个周末，刚给宝宝喂完牛奶，终于让她睡着了。所以现在我才能腾出手来，坐在电脑面前给大家写这篇文章。</p>
<p>今天我要和大家分享的是 AOP（Aspect-Oriented Programming）这个东西，名字与 OOP 仅差一个字母，其实它是对 OOP 编程方式的一种补充，并非是取而代之。翻译过来就是“面向方面编程”，可我更倾向于翻译为“面向切面编程”。它听起有些的神秘，为什么呢？当你看完这篇文章的时候，就会知道，我们做的很重要的工作就是去写这个“切面” 。那么什么是“切面”呢？</p>
<p>没错！就是用一把刀来切一坨面。注意，相对于面而言，我们一定是横着来切它，这简称为“横切”。可以把一段代码想象成一坨面，同样也可以用一把刀来横切它，下面要做的就是如何去实现这把刀！</p>
<p>需要澄清的是，这个概念不是由 Rod Johnson（老罗）提出的。其实很早以前就有了，目前最知名最强大的 Java 开源项目就是 AspectJ 了，然而它的前身是 AspectWerkz（该项目已经在 2005 年停止更新），这才是 AOP 的老祖宗。老罗（一个头发秃得和我老爸有一拼的天才）写了一个叫做 Spring 框架，从此一炮走红，成为了 Spring 之父。他在自己的 IOC 的基础之上，又实现了一套 AOP 的框架，后来仿佛发现自己越来越走进深渊里，在不能自拔的时候，有人建议他还是集成 AspectJ 吧，他在万般无奈之下才接受了该建议。于是，我们现在用得最多的想必就是 Spring + AspectJ 这种 AOP 框架了。</p>
<p>那么 AOP 到底是什么？如何去使用它？本文将逐步带您进入 AOP 的世界，让您感受到前所未有的畅快！</p>
<p>不过在开始讲解 AOP 之前，我想有必要回忆一下这段代码：</p>
<p><strong>1. 写死代码</strong></p>
<p>先来一个接口：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Greeting {

    <span class="keyword">void</span> sayHello(String name);

}
</code></pre><p>还有一个实现类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String name) {
        before();
        System.out.println(<span class="string">"Hello! "</span> + name);
        after();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>before() 与 after() 方法写死在 sayHello() 方法体中了，这样的代码的味道非常不好。如果哪位仁兄大量写了这样的代码，肯定要被你的架构师骂个够呛。</p>
<p>比如：我们要统计每个方法的执行时间，以对性能作出评估，那是不是要在每个方法的一头一尾都做点手脚呢？</p>
<p>再比如：我们要写一个 JDBC 程序，那是不是也要在方法的开头去连接数据库，方法的末尾去关闭数据库连接呢？</p>
<p>这样的代码只会把程序员累死，把架构师气死！</p>
<p>一定要想办法对上面的代码进行重构，首先给出三个解决方案：</p>
<p><strong>2. 静态代理</strong></p>
<p>最简单的解决方案就是使用静态代理模式了，我们单独为 GreetingImpl 这个类写一个代理类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingProxy</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    <span class="keyword">private</span> GreetingImpl greetingImpl;

    <span class="keyword">public</span> <span class="title">GreetingProxy</span>(GreetingImpl greetingImpl) {
        <span class="keyword">this</span>.greetingImpl = greetingImpl;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String name) {
        before();
        greetingImpl.sayHello(name);
        after();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>就用这个 GreetingProxy 去代理 GreetingImpl，下面看看客户端如何来调用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Greeting greetingProxy = <span class="keyword">new</span> GreetingProxy(<span class="keyword">new</span> GreetingImpl());
        greetingProxy.sayHello(<span class="string">"Jack"</span>);
    }
}
</code></pre><p>这样写没错，但是有个问题，XxxProxy 这样的类会越来越多，如何才能将这些代理类尽可能减少呢？最好只有一个代理类。</p>
<p>这时我们就需要使用 JDK 提供的动态代理了。 </p>
<p><strong>3. JDK 动态代理</strong></p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> {</span>

    <span class="keyword">private</span> Object target;

    <span class="keyword">public</span> <span class="title">JDKDynamicProxy</span>(Object target) {
        <span class="keyword">this</span>.target = target;
    }

    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    <span class="keyword">public</span> &lt;T&gt; T <span class="title">getProxy</span>() {
        <span class="keyword">return</span> (T) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            <span class="keyword">this</span>
        );
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Object <span class="title">invoke</span>(Object proxy, Method method, Object[] args) <span class="keyword">throws</span> Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        <span class="keyword">return</span> result;
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>客户端是这样调用的：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Greeting greeting = <span class="keyword">new</span> JDKDynamicProxy(<span class="keyword">new</span> GreetingImpl()).getProxy();
        greeting.sayHello(<span class="string">"Jack"</span>);
    }
}
</code></pre><p>这样所有的代理类都合并到动态代理类中了，但这样做仍然存在一个问题：JDK 给我们提供的动态代理只能代理接口，而不能代理没有接口的类。有什么方法可以解决呢？</p>
<p><strong>4. CGLib 动态代理</strong></p>
<p>我们使用开源的 CGLib 类库可以代理没有接口的类，这样就弥补了 JDK 的不足。CGLib 动态代理类是这样玩的：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibDynamicProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> CGLibDynamicProxy instance = <span class="keyword">new</span> CGLibDynamicProxy();

    <span class="keyword">private</span> <span class="title">CGLibDynamicProxy</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> CGLibDynamicProxy <span class="title">getInstance</span>() {
        <span class="keyword">return</span> instance;
    }

    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    <span class="keyword">public</span> &lt;T&gt; T <span class="title">getProxy</span>(Class&lt;T&gt; cls) {
        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Object <span class="title">intercept</span>(Object target, Method method, Object[] args, MethodProxy proxy) <span class="keyword">throws</span> Throwable {
        before();
        Object result = proxy.invokeSuper(target, args);
        after();
        <span class="keyword">return</span> result;
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>以上代码中了 Singleton 模式，那么客户端调用也更加轻松了：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class);
        greeting.sayHello(<span class="string">"Jack"</span>);
    }
}
</code></pre><p>到此为止，我们能做的都做了，问题似乎全部都解决了。但事情总不会那么完美，而我们一定要追求完美！</p>
<p>老罗搞出了一个 AOP 框架，能否做到完美而优雅呢？请大家继续往下看吧！</p>
<p><strong>5. Spring AOP：前置增强、后置增强、环绕增强（编程式）</strong></p>
<p>在 Spring AOP 的世界里，与 AOP 相关的术语实在太多，往往也是我们的“拦路虎”，不管是看那本书或是技术文档，在开头都要将这些术语逐个灌输给读者。我想这完全是在吓唬人了，其实没那么复杂的，大家放轻松一点。</p>
<p>我们上面例子中提到的 before() 方法，在 Spring AOP 里就叫 Before Advice（前置增强）。有些人将 Advice 直译为“通知”，我想这是不太合适的，因为它根本就没有“通知”的含义，而是对原有代码功能的一种“增强”。再说，CGLib 中也有一个 Enhancer 类，它就是一个增强类。</p>
<p>此外，像 after() 这样的方法就叫 After Advice（后置增强），因为它放在后面来增强代码的功能。</p>
<p>如果能把 before() 与 after() 合并在一起，那就叫 Around Advice（环绕增强），就像汉堡一样，中间夹一根火腿。</p>
<p>这三个概念是不是轻松地理解了呢？如果是，那就继续吧！</p>
<p>我们下面要做的就是去实现这些所谓的“增强类”，让他们横切到代码中，而不是将这些写死在代码中。</p>
<p>先来一个前置增强类吧：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(Method method, Object[] args, Object target) <span class="keyword">throws</span> Throwable {
        System.out.println(<span class="string">"Before"</span>);
    }
}
</code></pre><p>注意：这个类实现了 org.springframework.aop.MethodBeforeAdvice 接口，我们将需要增强的代码放入其中。</p>
<p>再来一个后置增强类吧：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAfterAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span>(Object result, Method method, Object[] args, Object target) <span class="keyword">throws</span> Throwable {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>类似地，这个类实现了 org.springframework.aop.AfterReturningAdvice 接口。</p>
<p>最后用一个客户端来把它们集成起来，看看如何调用吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();     <span class="comment">// 创建代理工厂</span>
        proxyFactory.setTarget(<span class="keyword">new</span> GreetingImpl());         <span class="comment">// 射入目标类对象</span>
        proxyFactory.addAdvice(<span class="keyword">new</span> GreetingBeforeAdvice()); <span class="comment">// 添加前置增强</span>
        proxyFactory.addAdvice(<span class="keyword">new</span> GreetingAfterAdvice());  <span class="comment">// 添加后置增强 </span>

        Greeting greeting = (Greeting) proxyFactory.getProxy(); <span class="comment">// 从代理工厂中获取代理</span>
        greeting.sayHello(<span class="string">"Jack"</span>);                              <span class="comment">// 调用代理的方法</span>
    }
}
</code></pre><p>请仔细阅读以上代码及其注释，您会发现，其实 Spring AOP 还是挺简单的，对吗？</p>
<p>当然，我们完全可以只定义一个增强类，让它同时实现 MethodBeforeAdvice 与 AfterReturningAdvice 这两个接口，如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingBeforeAndAfterAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>, <span class="title">AfterReturningAdvice</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(Method method, Object[] args, Object target) <span class="keyword">throws</span> Throwable {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span>(Object result, Method method, Object[] args, Object target) <span class="keyword">throws</span> Throwable {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>这样我们只需要使用一行代码，同时就可以添加前置与后置增强：</p>
<pre><code>proxyFactory.addAdvice(<span class="keyword">new</span> GreetingBeforeAndAfterAdvice());
</code></pre><p>刚才有提到“环绕增强”，其实这个东西可以把“前置增强”与“后置增强”的功能给合并起来，无需让我们同时实现以上两个接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Object <span class="title">invoke</span>(MethodInvocation invocation) <span class="keyword">throws</span> Throwable {
        before();
        Object result = invocation.proceed();
        after();
        <span class="keyword">return</span> result;
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>环绕增强类需要实现 org.aopalliance.intercept.MethodInterceptor 接口。注意，这个接口不是 Spring 提供的，它是 AOP 联盟（一个很牛逼的联盟）写的，Spring 只是借用了它。</p>
<p>在客户端中同样也需要将该增强类的对象添加到代理工厂中：</p>
<pre><code>proxyFactory.addAdvice(<span class="keyword">new</span> GreetingAroundAdvice());
</code></pre><p>好了，这就是 Spring AOP 的基本用法，但这只是“编程式”而已。Spring AOP 如果只是这样，那就太傻逼了，它曾经也是一度宣传用 Spring 配置文件的方式来定义 Bean 对象，把代码中的 new 操作全部解脱出来。</p>
<p><strong>6.   Spring AOP：前置增强、后置增强、环绕增强（声明式）</strong></p>
<p>先看 Spring 配置文件是如何写的吧：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>

    <span class="comment">&lt;!-- 扫描指定包（将 @Component 注解的类自动定义为 Spring Bean） --&gt;</span>
    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"aop.demo"</span>/&gt;</span>

    <span class="comment">&lt;!-- 配置一个代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interfaces"</span> <span class="attribute">value</span>=<span class="value">"aop.Greeting"</span>/&gt;</span> <span class="comment">&lt;!-- 需要代理的接口 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"greetingImpl"</span>/&gt;</span>       <span class="comment">&lt;!-- 接口实现类 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span>&gt;</span>                 <span class="comment">&lt;!-- 拦截器名称（也就是增强类名称，Spring Bean 的 id） --&gt;</span>
            <span class="tag">&lt;<span class="title">list</span>&gt;</span>
                <span class="tag">&lt;<span class="title">value</span>&gt;</span>greetingAroundAdvice<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>一定要阅读以上代码的注释，其实使用 ProxyFactoryBean 就可以取代前面的 ProxyFactory，其实它们俩就一回事儿。我认为 interceptorNames 应该改名为 adviceNames 或许会更容易让人理解，不就是往这个属性里面添加增强类吗？</p>
<p>此外，如果只有一个增强类，可以使用以下方法来简化：</p>
<pre><code><span class="keyword">...</span>

    &lt;bean id=<span class="string">"greetingProxy"</span> class=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;
        &lt;property name=<span class="string">"interfaces"</span> value=<span class="string">"aop.Greeting"</span>/&gt;
        &lt;property name=<span class="string">"target"</span> ref=<span class="string">"greetingImpl"</span>/&gt;
        &lt;property name=<span class="string">"interceptorNames"</span> value=<span class="string">"greetingAroundAdvice"</span>/&gt; &lt;!-- 注意这行配置 --&gt;
    &lt;/bean&gt;

<span class="keyword">...</span>
</code></pre><p>还需要注意的是，这里使用了 Spring 2.5+ 的特性“Bean 扫描”，这样我们就无需在 Spring 配置文件里不断地定义 <bean id="xxx" class="xxx"/> 了，从而解脱了我们的双手。</p>
<p>看看这是有多么的简单：</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    ...
}

<span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> {</span>

    ...
}
</code></pre><p>最后看看客户端吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/demo/spring.xml"</span>); <span class="comment">// 获取 Spring Context</span>
        Greeting greeting = (Greeting) context.getBean(<span class="string">"greetingProxy"</span>);                        <span class="comment">// 从 Context 中根据 id 获取 Bean 对象（其实就是一个代理）</span>
        greeting.sayHello(<span class="string">"Jack"</span>);                                                              <span class="comment">// 调用代理的方法</span>
    }
}
</code></pre><p>代码量确实少了，我们将配置性的代码放入配置文件，这样也有助于后期维护。更重要的是，代码只关注于业务逻辑，而将配置放入文件中。这是一条最佳实践！</p>
<p>除了上面提到的那三类增强以外，其实还有两类增强也需要了解一下，关键的时候您要能想得到它们才行。 </p>
<p><strong>7. Spring AOP：抛出增强</strong></p>
<p>程序报错，抛出异常了，一般的做法是打印到控制台或日志文件中，这样很多地方都得去处理，有没有一个一劳永逸的方法呢？那就是 Throws Advice（抛出增强），它确实很强，不信你就继续往下看：</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String name) {
        System.out.println(<span class="string">"Hello! "</span> + name);

        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error"</span>); <span class="comment">// 故意抛出一个异常，看看异常信息能否被拦截到</span>
    }
}
</code></pre><p>下面是抛出增强类的代码：</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingThrowAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> {</span>

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span>(Method method, Object[] args, Object target, Exception e) {
        System.out.println(<span class="string">"---------- Throw Exception ----------"</span>);
        System.out.println(<span class="string">"Target Class: "</span> + target.getClass().getName());
        System.out.println(<span class="string">"Method Name: "</span> + method.getName());
        System.out.println(<span class="string">"Exception Message: "</span> + e.getMessage());
        System.out.println(<span class="string">"-------------------------------------"</span>);
    }
}
</code></pre><p>抛出增强类需要实现 org.springframework.aop.ThrowsAdvice 接口，在接口方法中可获取方法、参数、目标对象、异常对象等信息。我们可以把这些信息统一写入到日志中，当然也可以持久化到数据库中。</p>
<p>这个功能确实太棒了！但还有一个更厉害的增强。如果某个类实现了 A 接口，但没有实现 B 接口，那么该类可以调用 B 接口的方法吗？如果您没有看到下面的内容，一定不敢相信原来这是可行的！</p>
<p><strong>8. Spring AOP：引入增强</strong></p>
<p>以上提到的都是对方法的增强，那能否对类进行增强呢？用 AOP 的行话来讲，对方法的增强叫做 Weaving（织入），而对类的增强叫做 Introduction（引入）。而 Introduction Advice（引入增强）就是对类的功能增强，它也是 Spring AOP 提供的最后一种增强。建议您一开始千万不要去看《Spring Reference》，否则您一定会后悔的。因为当您看了以下的代码示例后，一定会彻底明白什么才是引入增强。</p>
<p>定义了一个新接口 Apology（道歉）：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Apology {

    <span class="keyword">void</span> saySorry(String name);
}
</code></pre><p>但我不想在代码中让 GreetingImpl 直接去实现这个接口，我想在程序运行的时候动态地实现它。因为假如我实现了这个接口，那么我就一定要改写 GreetingImpl 这个类，关键是我不想改它，或许在真实场景中，这个类有1万行代码，我实在是不敢动了。于是，我需要借助 Spring 的引入增强。这个有点意思了！</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingIntroAdvice</span> <span class="keyword">extends</span> <span class="title">DelegatingIntroductionInterceptor</span> <span class="keyword">implements</span> <span class="title">Apology</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Object <span class="title">invoke</span>(MethodInvocation invocation) <span class="keyword">throws</span> Throwable {
        <span class="keyword">return</span> <span class="keyword">super</span>.invoke(invocation);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySorry</span>(String name) {
        System.out.println(<span class="string">"Sorry! "</span> + name);
    }
}
</code></pre><p>以上定义了一个引入增强类，扩展了 org.springframework.aop.support.DelegatingIntroductionInterceptor 类，同时也实现了新定义的 Apology 接口。在类中首先覆盖了父类的 invoke() 方法，然后实现了 Apology 接口的方法。我就是想用这个增强类去丰富 GreetingImpl 类的功能，那么这个 GreetingImpl 类无需直接实现 Apology 接口，就可以在程序运行的时候调用 Apology 接口的方法了。这简直是太神奇的！</p>
<p>看看是如何配置的吧：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"aop.demo"</span>/&gt;</span>

    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interfaces"</span> <span class="attribute">value</span>=<span class="value">"aop.demo.Apology"</span>/&gt;</span>          <span class="comment">&lt;!-- 需要动态实现的接口 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"greetingImpl"</span>/&gt;</span>                    <span class="comment">&lt;!-- 目标类 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"greetingIntroAdvice"</span>/&gt;</span> <span class="comment">&lt;!-- 引入增强 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyTargetClass"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>                <span class="comment">&lt;!-- 代理目标类（默认为 false，代理接口） --&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>需要注意 proxyTargetClass 属性，它表明是否代理目标类，默认为 false，也就是代理接口了，此时 Spring 就用 JDK 动态代理。如果为 true，那么 Spring 就用 CGLib 动态代理。这简直就是太方便了！Spring 封装了这一切，让程序员不在关心那么多的细节。我们要向老罗同志致敬，您是我们心中永远的 idol！</p>
<p>当您看完下面的客户端代码，一定会完全明白以上的这一切：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/demo/spring.xml"</span>);
        GreetingImpl greetingImpl = (GreetingImpl) context.getBean(<span class="string">"greetingProxy"</span>); <span class="comment">// 注意：转型为目标类，而并非它的 Greeting 接口</span>
        greetingImpl.sayHello(<span class="string">"Jack"</span>);

        Apology apology = (Apology) greetingImpl; <span class="comment">// 将目标类强制向上转型为 Apology 接口（这是引入增强给我们带来的特性，也就是“接口动态实现”功能）</span>
        apology.saySorry(<span class="string">"Jack"</span>);
    }
}
</code></pre><p>没想到 saySorry() 方法原来是可以被 greetingImpl 对象来直接调用的，只需将其强制转换为该接口即可。</p>
<p>我们再次感谢 Spring AOP，感谢老罗给我们提供了这么强大的特性！</p>
<p>其实，Spring AOP 还有很多精彩的地方，下一篇将介绍更多更有价值的 AOP 技术，让大家得到更多的收获。</p>
<p>未完，待续…</p>
<hr>
<p>本文是《AOP 那点事儿》的续集。</p>
<p>在上篇中，我们从写死代码，到使用代理；从编程式 Spring AOP 到声明式 Spring AOP。一切都朝着简单实用主义的方向在发展。沿着 Spring AOP 的方向，Rod Johnson（老罗）花了不少心思，都是为了让我们使用 Spring 框架时不会感受到麻烦，但事实却并非如此。那么，后来老罗究竟对 Spring AOP 做了哪些改进呢？</p>
<p>现在继续！</p>
<p><strong>9. Spring AOP：切面</strong></p>
<p>之前谈到的 AOP 框架其实可以将它理解为一个拦截器框架，但这个拦截器似乎非常武断。比如说，如果它拦截了一个类，那么它就拦截了这个类中所有的方法。类似地，当我们在使用动态代理的时候，其实也遇到了这个问题。需要在代码中对所拦截的方法名加以判断，才能过滤出我们需要拦截的方法，想想这种做法确实不太优雅。在大量的真实项目中，似乎我们只需要拦截特定的方法就行了，没必要拦截所有的方法。于是，老罗同志借助了 AOP 的一个很重要的工具，Advisor（切面），来解决这个问题。它也是 AOP 中的核心！是我们关注的重点！</p>
<p>也就是说，我们可以通过切面，将增强类与拦截匹配条件组合在一起，然后将这个切面配置到 ProxyFactory 中，从而生成代理。</p>
<p>这里提到这个“拦截匹配条件”在 AOP 中就叫做 Pointcut（切点），其实说白了就是一个基于表达式的拦截条件罢了。</p>
<p>归纳一下，Advisor（切面）封装了 Advice（增强）与 Pointcut（切点 ）。当您理解了这句话后，就往下看吧。</p>
<p>我在 GreetingImpl 类中故意增加了两个方法，都以“good”开头。下面要做的就是拦截这两个新增的方法，而对 sayHello() 方法不作拦截。</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String name) {
        System.out.println(<span class="string">"Hello! "</span> + name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodMorning</span>(String name) {
        System.out.println(<span class="string">"Good Morning! "</span> + name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodNight</span>(String name) {
        System.out.println(<span class="string">"Good Night! "</span> + name);
    }
}
</code></pre><p>在 Spring AOP 中，老罗已经给我们提供了许多切面类了，这些切面类我个人感觉最好用的就是基于正则表达式的切面类。看看您就明白了：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">...</span>"&gt;</span>

    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"aop.demo"</span>/&gt;</span>

    <span class="comment">&lt;!-- 配置一个切面 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingAdvisor"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"advice"</span> <span class="attribute">ref</span>=<span class="value">"greetingAroundAdvice"</span>/&gt;</span>            <span class="comment">&lt;!-- 增强 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"pattern"</span> <span class="attribute">value</span>=<span class="value">"aop.demo.GreetingImpl.good.*"</span>/&gt;</span> <span class="comment">&lt;!-- 切点（正则表达式） --&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

    <span class="comment">&lt;!-- 配置一个代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"greetingImpl"</span>/&gt;</span>                <span class="comment">&lt;!-- 目标类 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"greetingAdvisor"</span>/&gt;</span> <span class="comment">&lt;!-- 切面 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyTargetClass"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>            <span class="comment">&lt;!-- 代理目标类 --&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>注意以上代理对象的配置中的 interceptorNames，它不再是一个增强，而是一个切面，因为已经将增强封装到该切面中了。此外，切面还定义了一个切点（正则表达式），其目的是为了只将满足切点匹配条件的方法进行拦截。</p>
<p>需要强调的是，这里的切点表达式是基于正则表达式的。示例中的“aop.demo.GreetingImpl.good.<em>”表达式后面的“.</em>”表示匹配所有字符，翻译过来就是“匹配 aop.demo.GreetingImpl 类中以 good 开头的方法”。</p>
<p>除了 RegexpMethodPointcutAdvisor 以外，在 Spring AOP 中还提供了几个切面类，比如：</p>
<ul>
<li><p>DefaultPointcutAdvisor：默认切面（可扩展它来自定义切面）</p>
</li>
<li><p>NameMatchMethodPointcutAdvisor：根据方法名称进行匹配的切面</p>
</li>
<li><p>StaticMethodMatcherPointcutAdvisor：用于匹配静态方法的切面</p>
</li>
</ul>
<p>总的来说，让用户去配置一个或少数几个代理，似乎还可以接受，但随着项目的扩大，代理配置就会越来越多，配置的重复劳动就多了，麻烦不说，还很容易出错。能否让 Spring 框架为我们自动生成代理呢？</p>
<p><strong>10. Spring AOP：自动代理（扫描 Bean 名称）</strong></p>
<p>Spring AOP 提供了一个可根据 Bean 名称来自动生成代理的工具，它就是 BeanNameAutoProxyCreator。是这样配置的：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">...</span>&gt;</span>

    ...

    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"beanNames"</span> <span class="attribute">value</span>=<span class="value">"*Impl"</span>/&gt;</span>                       <span class="comment">&lt;!-- 只为后缀是“Impl”的 Bean 生成代理 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"greetingAroundAdvice"</span>/&gt;</span> <span class="comment">&lt;!-- 增强 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"optimize"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>                         <span class="comment">&lt;!-- 是否对代理生成策略进行优化 --&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>以上使用 BeanNameAutoProxyCreator 只为后缀为“Impl”的 Bean 生成代理。需要注意的是，这个地方我们不能定义代理接口，也就是 interfaces 属性，因为我们根本就不知道这些 Bean 到底实现了多少接口。此时不能代理接口，而只能代理类。所以这里提供了一个新的配置项，它就是 optimize。若为 true 时，则可对代理生成策略进行优化（默认是 false 的）。也就是说，如果该类有接口，就代理接口（使用 JDK 动态代理）；如果没有接口，就代理类（使用 CGLib 动态代理）。而并非像之前使用的 proxyTargetClass 属性那样，强制代理类，而不考虑代理接口的方式。可见 Spring AOP 确实为我们提供了很多很好地服务！</p>
<p>既然 CGLib 可以代理任何的类了，那为什么还要用 JDK 的动态代理呢？肯定您会这样问。</p>
<p>根据多年来实际项目经验得知：CGLib 创建代理的速度比较慢，但创建代理后运行的速度却非常快，而 JDK 动态代理正好相反。如果在运行的时候不断地用 CGLib 去创建代理，系统的性能会大打折扣，所以建议一般在系统初始化的时候用 CGLib 去创建代理，并放入 Spring 的 ApplicationContext 中以备后用。</p>
<p>以上这个例子只能匹配目标类，而不能进一步匹配其中指定的方法，要匹配方法，就要考虑使用切面与切点了。Spring AOP 基于切面也提供了一个自动代理生成器：DefaultAdvisorAutoProxyCreator。</p>
<p><strong>11. Spring AOP：自动代理（扫描切面配置）</strong></p>
<p>为了匹配目标类中的指定方法，我们仍然需要在 Spring 中配置切面与切点：</p>
<pre><code>&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;
&lt;beans <span class="keyword">...</span>&gt;

    <span class="keyword">...</span>

    &lt;bean id=<span class="string">"greetingAdvisor"</span> class=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;
        &lt;property name=<span class="string">"pattern"</span> value=<span class="string">"aop.demo.GreetingImpl.good.*"</span>/&gt;
        &lt;property name=<span class="string">"advice"</span> ref=<span class="string">"greetingAroundAdvice"</span>/&gt;
    &lt;/bean&gt;

    &lt;bean class=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;
        &lt;property name=<span class="string">"optimize"</span> value=<span class="string">"true"</span>/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>这里无需再配置代理了，因为代理将会由 DefaultAdvisorAutoProxyCreator 自动生成。也就是说，这个类可以扫描所有的切面类，并为其自动生成代理。</p>
<p>看来不管怎样简化，老罗始终解决不了切面的配置，这件繁重的手工劳动。在 Spring 配置文件中，仍然会存在大量的切面配置。然而在有很多情况下 Spring AOP 所提供的切面类真的不太够用了，比如：想拦截指定注解的方法，我们就必须扩展 DefaultPointcutAdvisor 类，自定义一个切面类，然后在 Spring 配置文件中进行切面配置。不做不知道，做了您就知道相当麻烦了。</p>
<p>老罗的解决方案似乎已经掉进了切面类的深渊，这还真是所谓的“面向切面编程”了，最重要的是切面，最麻烦的也是切面。</p>
<p>必须要把切面配置给简化掉，Spring 才能有所突破！ </p>
<p>神一样的老罗总算认识到了这一点，接受了网友们的建议，集成了 AspectJ，同时也保留了以上提到的切面与代理配置方式（为了兼容老的项目，更为了维护自己的面子）。将 Spring 与 AspectJ 集成与直接使用 AspectJ 是不同的，我们不需要定义 AspectJ 类（它是扩展了 Java 语法的一种新的语言，还需要特定的编译器），只需要使用 AspectJ 切点表达式即可（它是比正则表达式更加友好的表现形式）。</p>
<p><strong>12. Spring + AspectJ（基于注解：通过 AspectJ execution 表达式拦截方法）</strong></p>
<p>下面以一个最简单的例子，实现之前提到的环绕增强。先定义一个 Aspect 切面类：</p>
<pre><code><span class="annotation">@Aspect</span>
<span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAspect</span> {</span>

    <span class="annotation">@Around</span>(<span class="string">"execution(* aop.demo.GreetingImpl.*(..))"</span>)
    <span class="keyword">public</span> Object <span class="title">around</span>(ProceedingJoinPoint pjp) <span class="keyword">throws</span> Throwable {
        before();
        Object result = pjp.proceed();
        after();
        <span class="keyword">return</span> result;
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>注意：类上面标注的 @Aspect 注解，这表明该类是一个 Aspect（其实就是 Advisor）。该类无需实现任何的接口，只需定义一个方法（方法叫什么名字都无所谓），只需在方法上标注 @Around 注解，在注解中使用了 AspectJ 切点表达式。方法的参数中包括一个 ProceedingJoinPoint 对象，它在 AOP 中称为 Joinpoint（连接点），可以通过该对象获取方法的任何信息，例如：方法名、参数等。</p>
<p>下面重点来分析一下这个切点表达式：</p>
<p>execution(<em> aop.demo.GreetingImpl.</em>(..))</p>
<p>execution()：表示拦截方法，括号中可定义需要匹配的规则。</p>
<p>第一个“*”：表示方法的返回值是任意的。</p>
<p>第二个“*”：表示匹配该类中所有的方法。</p>
<p>(..)：表示方法的参数是任意的。</p>
<p>是不是比正则表达式的可读性更强呢？如果想匹配指定的方法，只需将第二个“*”改为指定的方法名称即可。</p>
<p>如何配置呢？看看是有多简单吧：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
       <span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span>
       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"aop.demo"</span>/&gt;</span>

    <span class="tag">&lt;<span class="title">aop:aspectj-autoproxy</span> <span class="attribute">proxy-target-class</span>=<span class="value">"true"</span>/&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>两行配置就行了，不需要配置大量的代理，更不需要配置大量的切面，真是太棒了！需要注意的是 proxy-target-class=”true” 属性，它的默认值是 false，默认只能代理接口（使用 JDK 动态代理），当为 true 时，才能代理目标类（使用 CGLib 动态代理）。</p>
<p>Spring 与 AspectJ 结合的威力远远不止这些，我们来点时尚的吧，拦截指定注解的方法怎么样？</p>
<p><strong>13. Spring + AspectJ（基于注解：通过 AspectJ @annotation 表达式拦截方法）</strong> </p>
<p>为了拦截指定的注解的方法，我们首先需要来自定义一个注解：</p>
<pre><code><span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">Tag</span> {</span>
}
</code></pre><p>以上定义了一个 @Tag 注解，此注解可标注在方法上，在运行时生效。</p>
<p>只需将前面的 Aspect 类的切点表达式稍作改动：</p>
<pre><code>@Aspect
@Component
public class GreetingAspect {

    @Around(<span class="string">"@annotation(aop.demo.Tag)"</span>)
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        <span class="keyword">...</span>
    }

    <span class="keyword">...</span>
}
</code></pre><p>这次使用了 @annotation() 表达式，只需在括号内定义需要拦截的注解名称即可。</p>
<p>直接将 @Tag 注解定义在您想要拦截的方法上，就这么简单：</p>
<pre><code><span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> {</span>

    <span class="annotation">@Tag</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(String name) {
        System.out.println(<span class="string">"Hello! "</span> + name);
    }
}
</code></pre><p>以上示例中只有一个方法，如果有多个方法，我们只想拦截其中某些时，这种解决方案会更加有价值。</p>
<p>除了 @Around 注解外，其实还有几个相关的注解，稍微归纳一下吧：</p>
<ul>
<li><p>@Before：前置增强</p>
</li>
<li><p>@After：后置增强</p>
</li>
<li><p>@Around：环绕增强</p>
</li>
<li><p>@AfterThrowing：抛出增强</p>
</li>
<li><p>@DeclareParents：引入增强</p>
</li>
</ul>
<p>此外还有一个 @AfterReturning（返回后增强），也可理解为 Finally 增强，相当于 finally 语句，它是在方法结束后执行的，也就说说，它比 @After 还要晚一些。</p>
<p>最后一个 @DeclareParents 竟然就是引入增强！为什么不叫做 @Introduction 呢？我也不知道为什么，但它干的活就是引入增强。</p>
<p><strong>14. Spring + AspectJ（引入增强）</strong></p>
<p>为了实现基于 AspectJ 的引入增强，我们同样需要定义一个 Aspect 类：</p>
<pre><code><span class="annotation">@Aspect</span>
<span class="annotation">@Component</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAspect</span> {</span>

    <span class="annotation">@DeclareParents</span>(value = <span class="string">"aop.demo.GreetingImpl"</span>, defaultImpl = ApologyImpl.class)
    <span class="keyword">private</span> Apology apology;
}
</code></pre><p>只需要在 Aspect 类中定义一个需要引入增强的接口，它也就是运行时需要动态实现的接口。在这个接口上标注了 @DeclareParents 注解，该注解有两个属性：</p>
<ul>
<li><p>value：目标类</p>
</li>
<li><p>defaultImpl：引入接口的默认实现类</p>
</li>
</ul>
<p>我们只需要对引入的接口提供一个默认实现类即可完成引入增强：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApologyImpl</span> <span class="keyword">implements</span> <span class="title">Apology</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySorry</span>(String name) {
        System.out.println(<span class="string">"Sorry! "</span> + name);
    }
}
</code></pre><p>以上这个实现会在运行时自动增强到 GreetingImpl 类中，也就是说，无需修改 GreetingImpl 类的代码，让它去实现 Apology 接口，我们单独为该接口提供一个实现类（ApologyImpl），来做 GreetingImpl 想做的事情。</p>
<p>还是用一个客户端来尝试一下吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Client {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop/demo/spring.xml"</span>);
        Greeting greeting = (Greeting) context.getBean(<span class="string">"greetingImpl"</span>);
        greeting.sayHello(<span class="string">"Jack"</span>);

        Apology apology = (Apology) greeting; <span class="comment">// 强制转型为 Apology 接口</span>
        apology.saySorry(<span class="string">"Jack"</span>);
    }
}
</code></pre><p>从 Spring ApplicationContext 中获取 greetingImpl 对象（其实是个代理对象），可转型为自己静态实现的接口 Greeting，也可转型为自己动态实现的接口 Apology，切换起来非常方便。</p>
<p>使用 AspectJ 的引入增强比原来的 Spring AOP 的引入增强更加方便了，而且还可面向接口编程（以前只能面向实现类），这也算一个非常巨大的突破。</p>
<p>这一切真的已经非常强大也非常灵活了！但仍然还是有用户不能尝试这些特性，因为他们还在使用 JDK 1.4（根本就没有注解这个东西），怎么办呢？没想到 Spring AOP 为那些遗留系统也考虑到了。</p>
<p><strong>15. Spring + AspectJ（基于配置）</strong></p>
<p>除了使用 @Aspect 注解来定义切面类以外，Spring AOP 也提供了基于配置的方式来定义切面类：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">...</span>"&gt;</span>

    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingImpl"</span> <span class="attribute">class</span>=<span class="value">"aop.demo.GreetingImpl"</span>/&gt;</span>

    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"greetingAspect"</span> <span class="attribute">class</span>=<span class="value">"aop.demo.GreetingAspect"</span>/&gt;</span>

    <span class="tag">&lt;<span class="title">aop:config</span>&gt;</span>
        <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">ref</span>=<span class="value">"greetingAspect"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">aop:around</span> <span class="attribute">method</span>=<span class="value">"around"</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* aop.demo.GreetingImpl.*(..))"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span>

<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</code></pre><p>使用 <aop:config> 元素来进行 AOP 配置，在其子元素中配置切面，包括增强类型、目标方法、切点等信息。</p>
<p>无论您是不能使用注解，还是不愿意使用注解，Spring AOP 都能为您提供全方位的服务。</p>
<p>好了，我所知道的比较实用的 AOP 技术都在这里了，当然还有一些更为高级的特性，由于个人精力有限，这里就不再深入了。</p>
<p>还是依照惯例，给一张牛逼的高清无码思维导图，总结一下以上各个知识点：</p>
<p><img src="http://waakaakaa.qiniudn.com/111332_5YL3_223750.png" alt="image"></p>
<p>最后给一张 UML 类图描述一下 Spring AOP 的整体架构：</p>
<p><img src="http://waakaakaa.qiniudn.com/235319_GQUH_223750.png" alt="image"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/proxy-那点事儿/">
  <time datetime="2014-05-14T07:02:44.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/proxy-那点事儿/">Proxy 那点事儿</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Proxy，也就是“代理”了。意思就是，你不用去做，别人代替你去处理。比如说：赚钱方面，我就是我老婆的 Proxy；带小孩方面，我老婆就是我的 Proxy；家务事方面，没有 Proxy。 </p>
<p>它在程序开发中起到了非常重要的作用，比如传说中的 AOP（面向切面编程），就是针对代理的一种应用。此外，在设计模式中，还有一个“代理模式”。在公司里要上外网，要在浏览器里设置一个 HTTP 代理。wocao，代理无处不在啊，不搞明白，岂不是很没面子？</p>
<p>凡是都要由浅入深，学习也不例外。先来一个 Hello World 吧： </p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Hello {

    <span class="keyword">void</span> say(String name);
}
</code></pre><p>这是一个 Hello 接口，不用解释了，大家都懂的。赶紧上实现类吧：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(String name) {
        System.out.println(<span class="string">"Hello! "</span> + name);
    }
}
</code></pre><p>wocao！这简直就是 So easy 嘛！但是有个问题：如果要在 println() 方法前面和后面分别需要处理一些逻辑，怎么做呢？把这些逻辑写死在 say() 方法里面吗？肯定不够优雅啦，菜鸟一般这样干，作为一名资深的程序员，我坚决不能这样做！</p>
<p>我要用代理！写一个 HelloProxy 类，让它去调用 HelloImpl 的 say() 方法，在调用的前后分别进行逻辑处理不就行了吗？赶紧搞一个吧：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> {</span>

    <span class="keyword">private</span> HelloImpl helloImpl;

    <span class="keyword">public</span> <span class="title">HelloProxy</span>() {
        helloImpl = <span class="keyword">new</span> HelloImpl();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(String name) {
        before();
        helloImpl.say(name);
        after();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span>() {
        System.out.println(<span class="string">"Before"</span>);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span>() {
        System.out.println(<span class="string">"After"</span>);
    }
}
</code></pre><p>我将 HelloProxy 类实现了 Hello 接口（和 HelloImpl 实现相同的接口），并且在构造方法中 new 出一个 HelloImpl 类的实例。这样一来，我就可以在 HelloProxy 的 say() 方法里面去调用 HelloImpl 的 say() 方法了。更重要的是，我还可以在调用的前后分别加上 before() 与 after() 方法，在这两个方法里去实现那些前后逻辑。</p>
<p>用一个 main 方法来测试一下吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    Hello helloProxy = <span class="keyword">new</span> HelloProxy();
    helloProxy.say(<span class="string">"Jack"</span>);
}
</code></pre><p>运行后，打印出：</p>
<pre><code><span class="keyword">Before</span>
Hello! Jack
<span class="keyword">After</span>
</code></pre><p>轻而易举，我就写出了这么优雅的代码（暗自小嗨了一把）。</p>
<p>不久后，我在一本设计模式的书上看到，原来我写的这个 HelloProxy 就是所谓的“代理模式”啊！我只能说，自己和 GoF（四人帮）的距离有接近了一点。 </p>
<p>于是我疯狂的使用“代理模式”，项目中到处都有 XxxProxy 的声影。直到有一天，架构师看到了我的代码，他惊呆了！他对我说：“你怎么这么喜欢用静态代理呢？你就不会用动态代理吗？给我全都重构了！”。</p>
<p>我表面上点了点头，说：“好的！”。其实我根本都不知道什么是“静态代理”，什么又是“动态代理”。我继续翻开我那本垫桌脚的设计模式，深入得研究了一番，最后我才明白，原来我一直用的都是“静态代理”啊，怪不得架构师说我到处都是 XxxProxy 类了。我好恨我自己！一定要将这些垃圾 Proxy 都重构为“动态代理”。</p>
<p>于是我就是用 JDK 给我们提供的动态代理方案，写了一个 DynamicProxy：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> {</span>

    <span class="keyword">private</span> Object target;

    <span class="keyword">public</span> <span class="title">DynamicProxy</span>(Object target) {
        <span class="keyword">this</span>.target = target;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Object <span class="title">invoke</span>(Object proxy, Method method, Object[] args) <span class="keyword">throws</span> Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        <span class="keyword">return</span> result;
    }

    ...
}
</code></pre><p>在 DynamicProxy 类中，我定义了一个 Object 类型的 target 变量，它就是被代理的目标对象，通过构造函数来初始化（现在流行叫“注入”了，我觉得叫“射入”也不错哦！构造函数初始化叫“正着射”，所以 reflect 方式就叫“反着射”，简称“反射”）。</p>
<p>言归正传，DynamicProxy 实现了 InvocationHandler 接口，那么必须实现该接口的 invoke 方法，参数不做解释，望文生义吧，是 JRE 给我们“射”进来的。在该方法中，直接通过反射去 invoke method，在调用前后分别处理 before 与 after，最后将 result 返回。</p>
<p>写一个 main() 方法看看实际怎么用吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    Hello hello = <span class="keyword">new</span> HelloImpl();

    DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(hello);

    Hello helloProxy = (Hello) Proxy.newProxyInstance(
        hello.getClass().getClassLoader(),
        hello.getClass().getInterfaces(),
        dynamicProxy
    );

    helloProxy.say(<span class="string">"Jack"</span>);
}
</code></pre><p>没错，意思就是，用我写的这个通用的 DynamicProxy 类去包装 HelloImpl 实例，然后再调用 JDK 给我们提供的 Proxy 类的工厂方法 newProxyInstance() 去动态地创建一个 Hello 接口的代理类，最后调用这个代理类的 say() 方法。</p>
<p>运行一下，结果和以前一样，动态代理成功了。其实，动态代理就是帮我们自动生成 XxxProxy 类的法宝啊！</p>
<p>要注意的是，Proxy.newProxyInstance() 方法的参数实在是让我“蛋碎一地”！</p>
<p>参数1：ClassLoader<br>参数2：该实现类的所有接口<br>参数3：动态代理对象</p>
<p>调用完了还要来一个强制类型转换一下。</p>
<p>wocao！这一坨 shi 一定要想办法封装一下，避免再次发生到处都是 Proxy.newProxyInstance()，这样架构师又要骂我了。于是我将这个 DynamicProxy 重构了：</p>
<pre><code>public class DynamicProxy implements InvocationHandler {

    <span class="keyword">...</span>

    @SuppressWarnings(<span class="string">"unchecked"</span>)
    public &lt;<span class="literal">T</span>&gt; <span class="literal">T</span> getProxy() {
        <span class="keyword">return</span> (<span class="literal">T</span>) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            this
        );
    }

    <span class="keyword">...</span>
}
</code></pre><p>我在 DynamicProxy 里添加了一个 getProxy() 方法，无需传入任何参数，将刚才所说的那一坨 shi，放在这个方法中，并且该方法返回一个泛型类型，就不会强制类型转换了。方法头上加那个 @SuppressWarnings(“unchecked”) 注解表示忽略编译时的警告（因为 Proxy.newProxyInstance() 方法返回的是一个 Object，这里我强制转换为 T 了，这是向下转型，IDE 中就会有警告，编译时也会出现提示，很烦）。</p>
<p>好了，这下子使用 DynamicProxy 就简单了吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> HelloImpl());
    Hello helloProxy = dynamicProxy.getProxy();

    helloProxy.say(<span class="string">"Jack"</span>);
}
</code></pre><p>确实简单用 2 行代理就去掉了前面的 7 行代码（省了 5 行），架构师看到了这样的代码肯定会表扬我！</p>
<p>经过一番代码重构后，我提交了所有的代码，架构师看到了，没有吱声…… 可我总算学会了动态代理。</p>
<p>用了这个 DynamicProxy 以后，我觉得它还是非常爽的，爽的地方是，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，实现类还要动，代理类也要动。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有勇武之地了！这就是 JDK 给我们提供的动态代理，让我不知道该说什么了。</p>
<p>于是我又开始调研，能否代理没有接口的类呢？终于让我找到了这颗“银弹”！那就是 CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。说起来好高深，实际用起来一点都不难。我再搞一个 CGLibProxy 吧：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> {</span>

    <span class="keyword">public</span> &lt;T&gt; T <span class="title">getProxy</span>(Class&lt;T&gt; cls) {
          <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);
    }

    <span class="keyword">public</span> Object <span class="title">intercept</span>(Object obj, Method method, Object[] args, MethodProxy proxy) <span class="keyword">throws</span> Throwable {
        before();
        Object result = proxy.invokeSuper(obj, args);
        after();
        <span class="keyword">return</span> result;
    }

    ...
}
</code></pre><p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。这个功能对于我们这群屌丝程序员而言，如同雪中送炭啊，此乃神器也！我们直接调用 proxy 的 invokeSuper() 方法，将被代理的对象 obj 以及方法参数 args 传入其中即可。</p>
<p>与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy();
    HelloImpl helloProxy = cgLibProxy.getProxy(HelloImpl.class);

    helloProxy.say(<span class="string">"Jack"</span>);
}
</code></pre><p>仍然通过 2 行代码就可以返回代理对象了，与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象（不管它是“屌丝”还是“高富帅”）。说它是神器，过分吗？</p>
<p>我一向都是以追求完美而著称，2 行代码返回代理对象，我觉得还是有些多余，我不想总是去 new 这个 CGLibProxy 对象，最好 new 一次，以后随时拿随时用。于是我想到了“单例模式”：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> CGLibProxy instance = <span class="keyword">new</span> CGLibProxy();

    <span class="keyword">private</span> <span class="title">CGLibProxy</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> CGLibProxy <span class="title">getInstance</span>() {
        <span class="keyword">return</span> instance;
    }

    ...
}
</code></pre><p>我加了以上几行代码，就搞定了！需要说明的是：这里有一个 private 的构造方法，就是为了限制外界不能再去 new 它了，换句话说，我在这里把它给“阉”了。</p>
<p>用一个 main() 方法来证明我的简单主义思想：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    HelloImpl helloImpl = CGLibProxy.getInstance().getProxy(HelloImpl.class);

    helloImpl.say(<span class="string">"Jack"</span>);
}
</code></pre><p>没错吧？只需 1 行代码就可以获取代理对象了！</p>
<p>总结一下，我们今天谈到了无代理、静态代理、JDK 动态代理、CGLib 动态代理，其实代理的世界远不止这么小，还有很多实际的应用场景。本文一开始谈到的 AOP 是一个最为典型的案例，所以有必要再进行继续下去。</p>
<p>我的宝宝突然尿了，在那里狂哭，我得去换块尿布了，老婆这个 Proxy 还是靠不住啊！</p>
<p>今天就到此为止，祝大家有个美好的周末！同样也期待您的留言。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/threadlocal-那点事儿/">
  <time datetime="2014-05-14T06:51:37.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/threadlocal-那点事儿/">ThreadLocal 那点事儿</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p>
<p>早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的，只不过设计得有些难用，所以至今没有得到广泛使用。其实它还是挺有用的，不相信的话，我们一起来看看这个例子吧。</p>
<p>一个序列号生成器的程序，可能同时会有多个线程并发访问它，要保证每个线程得到的序列号都是自增的，而不能相互干扰。</p>
<p>先定义一个接口：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Sequence {

    <span class="keyword">int</span> getNumber();
}
</code></pre><p>每次调用 getNumber() 方法可获取一个序列号，下次再调用时，序列号会自增。</p>
<p>再做一个线程类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> {</span>

    <span class="keyword">private</span> Sequence sequence;

    <span class="keyword">public</span> <span class="title">ClientThread</span>(Sequence sequence) {
        <span class="keyword">this</span>.sequence = sequence;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
            System.out.println(Thread.currentThread().getName() + <span class="string">" =&gt; "</span> + sequence.getNumber());
        }
    }
}
</code></pre><p>在线程中连续输出三次线程名与其对应的序列号。</p>
<p>我们先不用 ThreadLocal，来做一个实现类吧。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceA</span> <span class="keyword">implements</span> <span class="title">Sequence</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span>() {
        number = number + <span class="number">1</span>;
        <span class="keyword">return</span> number;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Sequence sequence = <span class="keyword">new</span> SequenceA();

        ClientThread thread1 = <span class="keyword">new</span> ClientThread(sequence);
        ClientThread thread2 = <span class="keyword">new</span> ClientThread(sequence);
        ClientThread thread3 = <span class="keyword">new</span> ClientThread(sequence);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
</code></pre><p>序列号初始值是0，在 main() 方法中模拟了三个线程，运行后结果如下：</p>
<pre><code><span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">1</span>
<span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">2</span>
<span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">3</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">4</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">5</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">6</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">7</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">8</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">9</span>
</code></pre><p>由于线程启动顺序是随机的，所以并不是0、1、2这样的顺序，这个好理解。为什么当 Thread-0 输出了1、2、3之后，而 Thread-2 却输出了4、5、6呢？线程之间竟然共享了 static 变量！这就是所谓的“非线程安全”问题了。</p>
<p>那么如何来保证“线程安全”呢？对应于这个案例，就是说不同的线程可拥有自己的 static 变量，如何实现呢？下面看看另外一个实现吧。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceB</span> <span class="keyword">implements</span> <span class="title">Sequence</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; numberContainer = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() {
        <span class="annotation">@Override</span>
        <span class="keyword">protected</span> Integer <span class="title">initialValue</span>() {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
    };

<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span>() {
     numberContainer.set(numberContainer.get() + <span class="number">1</span>);
     <span class="keyword">return</span> numberContainer.get();
 }

 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
     Sequence sequence = <span class="keyword">new</span> SequenceB();

     ClientThread thread1 = <span class="keyword">new</span> ClientThread(sequence);
      ClientThread thread2 = <span class="keyword">new</span> ClientThread(sequence);
     ClientThread thread3 = <span class="keyword">new</span> ClientThread(sequence);

     thread1.start();
     thread2.start();
     thread3.start();
    }
}
</code></pre><p>通过 ThreadLocal 封装了一个 Integer 类型的 numberContainer 静态成员变量，并且初始值是0。再看 getNumber() 方法，首先从 numberContainer 中 get 出当前的值，加1，随后 set 到 numberContainer 中，最后将 numberContainer 中 get 出当前的值并返回。</p>
<p>是不是很恶心？但是很强大！确实稍微饶了一下，我们不妨把 ThreadLocal 看成是一个容器，这样理解就简单了。所以，这里故意用 Container 这个单词作为后缀来命名 ThreadLocal 变量。</p>
<p>运行结果如何呢？看看吧。</p>
<pre><code><span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">1</span>
<span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">2</span>
<span class="keyword">Thread</span>-<span class="number">0</span> =&gt; <span class="number">3</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">1</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">2</span>
<span class="keyword">Thread</span>-<span class="number">2</span> =&gt; <span class="number">3</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">1</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">2</span>
<span class="keyword">Thread</span>-<span class="number">1</span> =&gt; <span class="number">3</span>
</code></pre><p>每个线程相互独立了，同样是 static 变量，对于不同的线程而言，它没有被共享，而是每个线程各一份，这样也就保证了线程安全。 也就是说，TheadLocal 为每一个线程提供了一个独立的副本！</p>
<p>搞清楚 ThreadLocal 的原理之后，有必要总结一下 ThreadLocal 的 API，其实很简单。</p>
<ol>
<li>public void set(T value)：将值放入线程局部变量中</li>
<li>public T get()：从线程局部变量中获取值</li>
<li>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</li>
<li>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </li>
</ol>
<p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。</p>
<p>了解了原理与这些 API，其实想想 ThreadLocal 里面不就是封装了一个 Map 吗？自己都可以写一个 ThreadLocal 了，尝试一下吧。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> MyThreadLocal&lt;T&gt; {

    <span class="keyword">private</span> Map&lt;Thread, T&gt; container = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Thread, T&gt;());

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T <span class="keyword">value</span>) {
        container.put(Thread.currentThread(), <span class="keyword">value</span>);
    }

    <span class="keyword">public</span> T <span class="title">get</span>() {
        Thread thread = Thread.currentThread();
        T <span class="keyword">value</span> = container.<span class="keyword">get</span>(thread);
        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span> &amp;&amp; !container.containsKey(thread)) {
            <span class="keyword">value</span> = initialValue();
            container.put(thread, <span class="keyword">value</span>);
        }
        <span class="keyword">return</span> <span class="keyword">value</span>;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>() {
        container.remove(Thread.currentThread());
    }

    <span class="keyword">protected</span> T <span class="title">initialValue</span>() {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre><p>以上完全山寨了一个 ThreadLocal，其中中定义了一个同步 Map（为什么要这样？请读者自行思考），代码应该非常容易读懂。</p>
<p>下面用这 MyThreadLocal 再来实现一把看看。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceC</span> <span class="keyword">implements</span> <span class="title">Sequence</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> MyThreadLocal&lt;Integer&gt; numberContainer = <span class="keyword">new</span> MyThreadLocal&lt;Integer&gt;() {
        <span class="annotation">@Override</span>
        <span class="keyword">protected</span> Integer <span class="title">initialValue</span>() {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
    };

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span>() {
        numberContainer.set(numberContainer.get() + <span class="number">1</span>);
        <span class="keyword">return</span> numberContainer.get();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Sequence sequence = <span class="keyword">new</span> SequenceC();

        ClientThread thread1 = <span class="keyword">new</span> ClientThread(sequence);
        ClientThread thread2 = <span class="keyword">new</span> ClientThread(sequence);
        ClientThread thread3 = <span class="keyword">new</span> ClientThread(sequence);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
</code></pre><p>以上代码其实就是将 ThreadLocal 替换成了 MyThreadLocal，仅此而已，运行效果和之前的一样，也是正确的。</p>
<p>其实 ThreadLocal 可以单独成为一种设计模式，就看你怎么看了。 </p>
<p>ThreadLocal 具体有哪些使用案例呢？</p>
<p>我想首先要说的就是：通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。</p>
<p>如何实现呢？下回分解！</p>
<p>ThreadLocal 那点事儿（续集）</p>
<p>注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！</p>
<hr>
<p>本篇是《ThreadLocal 那点事儿》的续集，如果您没看上一篇，就就有点亏了。如果您错过了这一篇，那亏得就更大了。</p>
<p>还是保持我一贯的 Style，用一个 Demo 来说话吧。用户提出一个需求：当修改产品价格的时候，需要记录操作日志，什么时候做了什么事情。</p>
<p>想必这个案例，只要是做过应用系统的小伙伴们，都应该遇到过吧？无外乎数据库里就两张表：product 与 log，用两条 SQL 语句应该可以解决问题：</p>
<pre><code><span class="operator"><span class="keyword">update</span> product <span class="keyword">set</span> price = ? <span class="keyword">where</span> id = ?
<span class="keyword">insert</span> <span class="keyword">into</span> log (created, description) <span class="keyword">values</span> (?, ?)</span>
</code></pre><p>But！要确保这两条 SQL 语句必须在同一个事务里进行提交，否则有可能 update 提交了，但 insert 却没有提交。如果这样的事情真的发生了，我们肯定会被用户指着鼻子狂骂：“为什么产品价格改了，却看不到什么时候改的呢？”。</p>
<p>聪明的我在接到这个需求以后，是这样做的：</p>
<p>首先，我写一个 DBUtil 的工具类，封装了数据库的常用操作： </p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> {</span>
    <span class="comment">// 数据库配置</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String driver = <span class="string">"com.mysql.jdbc.Driver"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"jdbc:mysql://localhost:3306/demo"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String username = <span class="string">"root"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"root"</span>;

    <span class="comment">// 定义一个数据库连接</span>
    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;

    <span class="comment">// 获取连接</span>
    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span>() {
        <span class="keyword">try</span> {
            Class.forName(driver);
            conn = DriverManager.getConnection(url, username, password);
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        <span class="keyword">return</span> conn;
    }

    <span class="comment">// 关闭连接</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span>() {
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {
                conn.close();
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>里面搞了一个 static 的 Connection，这下子数据库连接就好操作了，牛逼吧！</p>
<p>然后，我定义了一个接口，用于给逻辑层来调用：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> ProductService {

    <span class="keyword">void</span> updateProductPrice(<span class="keyword">long</span> productId, <span class="keyword">int</span> price);
}
</code></pre><p>根据用户提出的需求，我想这个接口完全够用了。根据 productId 去更新对应 Product 的 price，然后再插入一条数据到 log 表中。</p>
<p>其实业务逻辑也不太复杂，于是我快速地完成了 ProductService 接口的实现类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UPDATE_PRODUCT_SQL = <span class="string">"update product set price = ? where id = ?"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT_LOG_SQL = <span class="string">"insert into log (created, description) values (?, ?)"</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateProductPrice</span>(<span class="keyword">long</span> productId, <span class="keyword">int</span> price) {
        <span class="keyword">try</span> {
            <span class="comment">// 获取连接</span>
            Connection conn = DBUtil.getConnection();
            conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">// 关闭自动提交事务（开启事务）</span>

            <span class="comment">// 执行操作</span>
            updateProduct(conn, UPDATE_PRODUCT_SQL, productId, price); <span class="comment">// 更新产品</span>
            insertLog(conn, INSERT_LOG_SQL, <span class="string">"Create product."</span>); <span class="comment">// 插入日志</span>

            <span class="comment">// 提交事务</span>
            conn.commit();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="comment">// 关闭连接</span>
            DBUtil.closeConnection();
        }
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateProduct</span>(Connection conn, String updateProductSQL, <span class="keyword">long</span> productId, <span class="keyword">int</span> productPrice) <span class="keyword">throws</span> Exception {
        PreparedStatement pstmt = conn.prepareStatement(updateProductSQL);
        pstmt.setInt(<span class="number">1</span>, productPrice);
        pstmt.setLong(<span class="number">2</span>, productId);
        <span class="keyword">int</span> rows = pstmt.executeUpdate();
        <span class="keyword">if</span> (rows != <span class="number">0</span>) {
            System.out.println(<span class="string">"Update product success!"</span>);
        }
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertLog</span>(Connection conn, String insertLogSQL, String logDescription) <span class="keyword">throws</span> Exception {
        PreparedStatement pstmt = conn.prepareStatement(insertLogSQL);
        pstmt.setString(<span class="number">1</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss SSS"</span>).format(<span class="keyword">new</span> Date()));
        pstmt.setString(<span class="number">2</span>, logDescription);
        <span class="keyword">int</span> rows = pstmt.executeUpdate();
        <span class="keyword">if</span> (rows != <span class="number">0</span>) {
            System.out.println(<span class="string">"Insert log success!"</span>);
        }
    }
}
</code></pre><p>代码的可读性还算不错吧？这里我用到了 JDBC 的高级特性 Transaction 了。暗自庆幸了一番之后，我想是不是有必要写一个客户端，来测试一下执行结果是不是我想要的呢？ 于是我偷懒，直接在 ProductServiceImpl 中增加了一个 main() 方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    ProductService productService = <span class="keyword">new</span> ProductServiceImpl();
    productService.updateProductPrice(<span class="number">1</span>, <span class="number">3000</span>);
}
</code></pre><p>我想让 productId 为 1 的产品的价格修改为 3000。于是我把程序跑了一遍，控制台输出：</p>
<pre><code><span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
</code></pre><p>应该是对了。作为一名专业的程序员，为了万无一失，我一定要到数据库里在看看。没错！product 表对应的记录更新了，log 表也插入了一条记录。这样就可以将 ProductService 接口交付给别人来调用了。</p>
<p>几个小时过去了，QA 妹妹开始骂我：“我靠！我才模拟了 10 个请求，你这个接口怎么就挂了？说是数据库连接关闭了！”。</p>
<p>听到这样的叫声，让我浑身打颤，立马中断了我的小视频，赶紧打开 IDE，找到了这个 ProductServiceImpl 这个实现类。好像没有 Bug 吧？但我现在不敢给她任何回应，我确实有点怕她的。</p>
<p>我突然想起，她是用工具模拟的，也就是模拟多个线程了！那我自己也可以模拟啊，于是我写了一个线程类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> {</span>

    <span class="keyword">private</span> ProductService productService;

    <span class="keyword">public</span> <span class="title">ClientThread</span>(ProductService productService) {
        <span class="keyword">this</span>.productService = productService;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(Thread.currentThread().getName());
        productService.updateProductPrice(<span class="number">1</span>, <span class="number">3000</span>);
    }
}
</code></pre><p>我用这线程去调用 ProduceService 的方法，看看是不是有问题。此时，我还要再修改一下 main() 方法：</p>
<pre><code><span class="comment">// public static void main(String[] args) {</span>
<span class="comment">//     ProductService productService = new ProductServiceImpl();</span>
<span class="comment">//     productService.updateProductPrice(1, 3000);</span>
<span class="comment">// }</span>

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        ProductService productService = <span class="keyword">new</span> ProductServiceImpl();
        ClientThread thread = <span class="keyword">new</span> ClientThread(productService);
        thread.start();
    }
}
</code></pre><p>我也模拟 10 个线程吧，我就不信那个邪了！</p>
<p>运行结果真的让我很晕、很晕：</p>
<pre><code>Thread-<span class="number">1</span>
Thread-<span class="number">3</span>
Thread-<span class="number">5</span>
Thread-<span class="number">7</span>
Thread-<span class="number">9</span>
Thread-<span class="number">0</span>
Thread-<span class="number">2</span>
Thread-<span class="number">4</span>
Thread-<span class="number">6</span>
Thread-<span class="number">8</span>
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
Update product success!
Insert log success!
<span class="label">com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException:</span> No operations allowed after connection closed.
at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.NativeConstructorAccessorImpl</span><span class="preprocessor">.newInstance</span>0(Native Method)
at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.NativeConstructorAccessorImpl</span><span class="preprocessor">.newInstance</span>(NativeConstructorAccessorImpl<span class="preprocessor">.java</span>:<span class="number">39</span>)
at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.DelegatingConstructorAccessorImpl</span><span class="preprocessor">.newInstance</span>(DelegatingConstructorAccessorImpl<span class="preprocessor">.java</span>:<span class="number">27</span>)
at java<span class="preprocessor">.lang</span><span class="preprocessor">.reflect</span><span class="preprocessor">.Constructor</span><span class="preprocessor">.newInstance</span>(Constructor<span class="preprocessor">.java</span>:<span class="number">513</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.Util</span><span class="preprocessor">.handleNewInstance</span>(Util<span class="preprocessor">.java</span>:<span class="number">411</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.Util</span><span class="preprocessor">.getInstance</span>(Util<span class="preprocessor">.java</span>:<span class="number">386</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.SQLError</span><span class="preprocessor">.createSQLException</span>(SQLError<span class="preprocessor">.java</span>:<span class="number">1015</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.SQLError</span><span class="preprocessor">.createSQLException</span>(SQLError<span class="preprocessor">.java</span>:<span class="number">989</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.SQLError</span><span class="preprocessor">.createSQLException</span>(SQLError<span class="preprocessor">.java</span>:<span class="number">975</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.SQLError</span><span class="preprocessor">.createSQLException</span>(SQLError<span class="preprocessor">.java</span>:<span class="number">920</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.ConnectionImpl</span><span class="preprocessor">.throwConnectionClosedException</span>(ConnectionImpl<span class="preprocessor">.java</span>:<span class="number">1304</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.ConnectionImpl</span><span class="preprocessor">.checkClosed</span>(ConnectionImpl<span class="preprocessor">.java</span>:<span class="number">1296</span>)
at <span class="keyword">com</span><span class="preprocessor">.mysql</span><span class="preprocessor">.jdbc</span><span class="preprocessor">.ConnectionImpl</span><span class="preprocessor">.commit</span>(ConnectionImpl<span class="preprocessor">.java</span>:<span class="number">1699</span>)
at <span class="keyword">com</span><span class="preprocessor">.smart</span><span class="preprocessor">.sample</span><span class="preprocessor">.test</span><span class="preprocessor">.transaction</span><span class="preprocessor">.solution</span>1<span class="preprocessor">.ProductServiceImpl</span><span class="preprocessor">.updateProductPrice</span>(ProductServiceImpl<span class="preprocessor">.java</span>:<span class="number">25</span>)
at <span class="keyword">com</span><span class="preprocessor">.smart</span><span class="preprocessor">.sample</span><span class="preprocessor">.test</span><span class="preprocessor">.transaction</span><span class="preprocessor">.ClientThread</span><span class="preprocessor">.run</span>(ClientThread<span class="preprocessor">.java</span>:<span class="number">18</span>)
</code></pre><p>我靠！竟然在多线程的环境下报错了，果然是数据库连接关闭了。怎么回事呢？我陷入了沉思中。于是我 Copy 了一把那句报错信息，在百度、Google，还有 OSC 里都找了，解答实在是千奇百怪。</p>
<p>我突然想起，既然是跟 Connection 有关系，那我就将主要精力放在检查 Connection 相关的代码上吧。是不是 Connection 不应该是 static 的呢？我当初设计成 static 的主要是为了让 DBUtil 的 static 方法访问起来更加方便，用 static 变量来存放 Connection 也提高了性能啊。怎么搞呢？</p>
<p>于是我看到了 OSC 上非常火爆的一篇文章《ThreadLocal 那点事儿》，终于才让我明白了！原来要使每个线程都拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接，所以线程2就报错了。一定是这样！</p>
<p>我赶紧将 DBUtil 给重构了：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> DBUtil {
    <span class="comment">// 数据库配置</span>
    <span class="keyword">private</span> <span class="keyword">static</span> final String driver = <span class="string">"com.mysql.jdbc.Driver"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final String url = <span class="string">"jdbc:mysql://localhost:3306/demo"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final String username = <span class="string">"root"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final String password = <span class="string">"root"</span>;

    <span class="comment">// 定义一个用于放置数据库连接的局部线程变量（使每个线程都拥有自己的连接）</span>
    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connContainer = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();

    <span class="comment">// 获取连接</span>
    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span>() {
        Connection conn = connContainer.<span class="keyword">get</span>();
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) {
                Class.forName(driver);
                conn = DriverManager.getConnection(url, username, password);
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            connContainer.<span class="keyword">set</span>(conn);
        }
        <span class="keyword">return</span> conn;
    }

    <span class="comment">// 关闭连接</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span>() {
        Connection conn = connContainer.<span class="keyword">get</span>();
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {
                conn.close();
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            connContainer.remove();
        }
    }
}
</code></pre><p>我把 Connection 放到了 ThreadLocal 中，这样每个线程之间就隔离了，不会相互干扰了。</p>
<p>此外，在 getConnection() 方法中，首先从 ThreadLocal 中（也就是 connContainer 中） 获取 Connection，如果没有，就通过 JDBC 来创建连接，最后再把创建好的连接放入这个 ThreadLocal 中。可以把 ThreadLocal 看做是一个容器，一点不假。</p>
<p>同样，我也对 closeConnection() 方法做了重构，先从容器中获取 Connection，拿到了就 close 掉，最后从容器中将其 remove 掉，以保持容器的清洁。</p>
<p>这下应该行了吧？我再次运行 main() 方法：</p>
<pre><code><span class="keyword">Thread</span>-<span class="number">0</span>
<span class="keyword">Thread</span>-<span class="number">2</span>
<span class="keyword">Thread</span>-<span class="number">4</span>
<span class="keyword">Thread</span>-<span class="number">6</span>
<span class="keyword">Thread</span>-<span class="number">8</span>
<span class="keyword">Thread</span>-<span class="number">1</span>
<span class="keyword">Thread</span>-<span class="number">3</span>
<span class="keyword">Thread</span>-<span class="number">5</span>
<span class="keyword">Thread</span>-<span class="number">7</span>
<span class="keyword">Thread</span>-<span class="number">9</span>
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
<span class="keyword">Update</span> product success!
<span class="keyword">Insert</span> log success!
</code></pre><p>我去！总算是解决了，QA 妹妹，你应该会对我微笑一下吧？</p>
<p>感谢您的关注，分享是一种快乐，也希望得到您的支持与批评！</p>
<p>注意：该示例仅用于说明 TheadLocal 的基本用法。在实际工作中，推荐使用连接池来管理数据库连接。示例中的代码仅作参考，使用前请酌情考虑。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/爹地，我找到了!----15个极好的linux-find命令示例/">
  <time datetime="2014-05-14T06:34:41.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/爹地，我找到了!----15个极好的linux-find命令示例/">爹地，我找到了! -- 15个极好的Linux find命令示例</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>前阵子，我们审查了15件实事 find命令的例子（第一部分）。查找命令可以做很多比只是在寻找基于名称的文件 （第2部分）在这篇文章中，让我们来讨论15高级find命令的例子， 包括-根据它访问，修改或改变的时间查找文件，查找文件相比之下，执行操作找到的文件等， 拉梅什纳塔拉詹：这是我的照片中的可爱的小女儿。她很高兴地发现在加州长滩水族馆海狮。 </p>
<p><strong>基于访问/修改/更改时间查找文件</strong></p>
<p>你可以找到基于以下三个文件的时间属性的文件。</p>
<ul>
<li>访问时间的文件。文件访问时，访问时间得到更新。</li>
<li>的文件的修改时间。文件内容修改时，修改时间得到更新。</li>
<li>更改文件的时间。更改时间时，被更新的inode数据的变化。</li>
</ul>
<p>在下面的例子中，min选项之间的差异和时间选项是参数。</p>
<ul>
<li>分论点将它的参数为分钟。例如，60分钟（1小时）= 60分钟。</li>
<li>时间参数，将它的参数为24小时。例如，时间2 = 2 * 24小时（2天）。</li>
<li>虽然这样做的24个小时计算，小数部分都将被忽略，所以25小时为24小时，和47小时取为24小时，仅48小时为48小时。要获得更清晰的参考atime的部分find命令的手册页。</li>
</ul>
<p><strong>例1：找到在1个小时内被更改的文件</strong></p>
<p>想要通过文件修改时间找出文件，可以使用参数 -mmin -mtime。下面是man手册中有关mmin和mtime的定义。</p>
<ul>
<li>-mmin n 文件最后一次修改是在n分钟之内</li>
<li>-mtime n 文件最后一次修改是在 n*24小时之内（译者注：也就是n天了呗）</li>
</ul>
<p>执行下面例子中的命令，将会找到当前目录以及其子目录下，最近一次修改时间在1个小时（60分钟）之内的文件或目录</p>
<pre><code><span class="preprocessor"># find . -mmin -60</span>
</code></pre><p>同样的方式，执行下面例子中的命令，将会找到24小时（1天）内修改了的文件（文件系统根目录 / 下）</p>
<pre><code><span class="preprocessor"># find / -mtime -1</span>
</code></pre><p><strong>例2：找到1个小时内被访问过的文件</strong></p>
<p>想要通过文件访问时间找出文件，可以使用参数 -amin -atime。下面是man手册中有关amin和atime的定义。</p>
<ul>
<li>-amin n 文件最后一次访问是在n分钟之内</li>
<li>-atime n 文件最后一次访问是在 n*24小时之内</li>
</ul>
<p>执行下面例子中的命令，将会找到当前目录以及其子目录下，最近一次访问时间在1个小时（60分钟）之内的文件或目录</p>
<pre><code><span class="preprocessor"># find . -amin -60</span>
</code></pre><p>同样的方式，执行下面例子中的命令，将会找到24小时（1天）内被访问了的文件（文件系统根目录 / 下）</p>
<pre><code><span class="preprocessor"># find / -atime -1</span>
</code></pre><p><strong>例3：查找一个小时内状态被改变的文件</strong></p>
<p>（译者注：这里的改变更第1个例子的更改文件内容时间是不同概念，这里是更改的是文件inode的数据，比如文件的权限，所属人等等信息）</p>
<p>要查找文件的inode的更改时间，使用-cmin和-ctime选项</p>
<ul>
<li>-cmin n  文件的状态在n分钟内被改变</li>
<li>-ctime n  文件状态在n*24小时内（也就是n天内）被改变</li>
</ul>
<p>（译者注：如果上面的n为-n形式，则表示n分钟/天之内，n为+n则表示n分钟/天之前）</p>
<p>下面的例子在当前目录和其子目录下面查找一个小时内文件状态改变的文件（也就是60分钟内）：</p>
<pre><code><span class="preprocessor"># find . -cmin -60</span>
</code></pre><p>同样的道理，下面的例子在根目录/及其子目录下一天内（24小时内）文件状态被改变的文件列表：</p>
<pre><code><span class="preprocessor"># find / -ctime -1</span>
</code></pre><p><strong>例4：搜索仅仅限定于文件，不显示文件夹</strong></p>
<p>上面的例子搜索出来不仅仅有文件，还会显示文件夹。因为当一个文件被访问的时候，它所处的文件夹也会被访问，如果你对文件夹不感兴趣，那么可以使用 -type f 选项</p>
<p>下面的例子会显示30分钟内被修改过的文件，文件夹不显示：</p>
<pre><code><span class="preprocessor"># find /etc/sysconfig -amin -30</span>
.
./console
./network-scripts
./i18n
./rhn
./rhn/clientCaps.d
./networking
./networking/profiles
./networking/profiles/<span class="default"><span class="keyword">default</span></span>
./networking/profiles/<span class="default"><span class="keyword">default</span>/resolv.conf</span>
./networking/profiles/<span class="default"><span class="keyword">default</span>/hosts</span>
./networking/devices
./apm-scripts
[注: 上面的输出包含了文件和文件夹]

<span class="preprocessor"># find /etc/sysconfig -amin -30 -type f</span>
./i18n
./networking/profiles/<span class="default"><span class="keyword">default</span>/resolv.conf</span>
./networking/profiles/<span class="default"><span class="keyword">default</span>/hosts</span>
[注: 上面的输出仅仅包含文件]
</code></pre><p><strong>例5： 仅仅查找非隐藏的文件（不显示隐藏文件）：</strong></p>
<p>如果我们查找的时候不想隐藏文件也显示出来，可以使用下面的正则式查找：</p>
<p>下面的命令会显示当前目录及其子目录下15分钟内文件内容被修改过的文件，并且只列出非隐藏文件。也就是说，以.开头的文件时不会显示出来的</p>
<pre><code><span class="special">#</span> find . -mmin -15 <span class="command">\(</span> ! -regex ".*/<span class="command">\.</span>.*" <span class="command">\)</span>
</code></pre><p>基于文件比较的查找命令</p>
<p>我们平时通过更别的东西进行比较，会更容易记住一些事情。比如说我想找出在我编辑test文件之后编辑过的文件。你可以通过test这个文件的编辑时间作为比较基准去查找之后编辑过的文件：</p>
<p><strong>例6： 查找文件修改时间在某一文件修改后的文件：</strong></p>
<pre><code>语法： find -newer <span class="keyword">FILE</span>
</code></pre><p>下面的例子显示在/etc/passwd修改之后被修改过的文件。对于系统管理员，想知道你新增了一个用户后去跟踪系统的活动状态是很有帮助的（万一那新用户不老实，一上来就乱搞，你很快就知道了  ^_^）：</p>
<pre><code><span class="preprocessor"># find -newer /etc/passwd</span>
</code></pre><p><strong>例7：查找文件访问时间在某一文件的修改时间之后的文件：</strong></p>
<pre><code><span class="preprocessor"># find -newer /etc/passwd</span>
</code></pre><p>下面的例子显示所有在/etc/hosts文件被修改后被访问到的文件。如果你新增了一个主机/端口记录在/etc/hosts文件中，你很可能很想知道在那之后有什么文件被访问到了，下面是这个命令：</p>
<pre><code><span class="preprocessor"># find -anewer /etc/hosts</span>
</code></pre><p><strong>例8：查找状态改变时间在某个文件修改时间之后的文件：</strong></p>
<pre><code>语法： find -cnewer <span class="keyword">FILE</span>
</code></pre><p>下面的例子显示在修改文件/etc/fstab之后所有文件状态改变过的文件。如果你在/etc/fstab新增了一个挂载点，你很可能想知道之后哪些文件的状态发生了改变，这时候你可以使用如下命令：</p>
<pre><code><span class="preprocessor"># find -cnewer /etc/fstab</span>
</code></pre><p>在查找到的文件列表结果上直接执行命令：</p>
<p>这之前你已经看到了如果通过find命令去查找各种条件的文件列表。如果你对这些find命令还不熟悉，我建议你看完上面的第一部分</p>
<p>接下来这部分我们向你介绍如果在find命令上执行各种不同的命令，也就是说如何去操作find命令查找出来的文件列表。</p>
<p>我们能在find命令查找出来的文件名列表上指定任意的操作：</p>
<pre><code># find <span class="tag">&lt;<span class="title">CONDITION</span> <span class="attribute">to</span> <span class="attribute">Find</span> <span class="attribute">files</span>&gt;</span> -exec <span class="tag">&lt;<span class="title">OPERATION</span>&gt;</span> \;
</code></pre><p>其中的OPERATION可以是任意的命令，下面列举一下比较常用的：</p>
<ul>
<li>rm 命令，用于删除find查找出来的文件</li>
<li>mv 命令，用于重命名查找出的文件</li>
<li>ls -l 命令，显示查找出的文件的详细信息</li>
<li>md5sum， 对查找出的文件进行md5sum运算，可以获得一个字符串，用于检测文件内容的合法性</li>
<li>wc 命令，用于统计计算文件的单词数量，文件大小等待</li>
<li>执行任何Unix的shell命令</li>
<li>执行你自己写的shell脚本，参数就是每个查找出来的文件名</li>
</ul>
<p><strong>例9：在find命令输出上使用 ls -l， 列举出1小时内被编辑过的文件的详细信息</strong></p>
<pre><code><span class="preprocessor"># find -mmin -60</span>
./cron
./secure

<span class="preprocessor"># find -mmin -60 -exec ls -l {} \;</span>
-rw<span class="comment">-------  1 root root 1028 Jun 21 15:01 ./cron</span>
-rw<span class="comment">-------  1 root root 831752 Jun 21 15:42 ./secure</span>
</code></pre><p><strong>例10：仅仅在当前文件系统中搜索</strong></p>
<p>系统管理员有时候仅仅想在/挂载的文件系统分区上搜索，而不想去搜索其他的挂载分区，比如/home/挂载分区。如果你有多个分区被挂载了，你想在/下搜索，一般可以按下面的这样做</p>
<p>下面这个命令会搜索根目录/及其子目录下所有.log结尾的文件名。如果你有多个分区在/下面，那么这个搜索会去搜索所有的被挂载的分区：</p>
<pre><code><span class="array"># find </span>/ -name <span class="string">"*.log"</span>
</code></pre><p>如果我们使用-xdev选项，那么仅仅会在在当前文件系统中搜索，下面是在xdev的man page上面找到的一段-xdev的定义：</p>
<ul>
<li>-xdev Don’t descend directories on other filesystems.</li>
</ul>
<p>下面的命令会在/目录及其子目录下搜索当前文件系统(也就是/挂载的文件系统)中所有以.log结尾的文件，也就是说如果你有多个分区挂载在/下面，下面的搜索不会去搜索其他的分区的（比如/home/）</p>
<pre><code><span class="array"># find </span>/ -xdev -name <span class="string">"*.log"</span>
</code></pre><p><strong>例11： 在同一个命令中使用多个{}</strong></p>
<p>linux手册说命令中只能使用一个{}，不过你可以像下面这样在同一个命令中使用多个{}</p>
<pre><code># find -name <span class="string">"*.txt"</span> cp <span class="list">{}</span> <span class="list">{}</span>.bkup \;
</code></pre><p>注意，在同一个命令中使用这个{}是可以的，但是在不同的命令里就不行了，也就是说，如果你想象下面这样重命名文件是行不通的</p>
<pre><code>find <span class="attribute">-name</span> <span class="string">"*.txt"</span> <span class="attribute">-exec</span> mv {} <span class="string">`basename {} .htm`</span><span class="built_in">.</span>html <span class="subst">\</span>;
</code></pre><p><strong>例12： 使用多个{}实例</strong></p>
<p>你可以像下面这样写一个shell脚本去模拟上面那个重命名的例子</p>
<pre><code># mv <span class="string">"$1"</span> <span class="string">"<span class="escape">`b</span>asename "</span>$<span class="number">1</span><span class="string">" .htm<span class="escape">`.</span>html"</span>
</code></pre><p>上面的双引号是为了防止文件名中出现的空格，不加的话会有问题。然后你把这个shell脚本保存为mv.sh，你可以像下面这样使用find命令了</p>
<pre><code>find <span class="attribute">-name</span> <span class="string">"*.html"</span> <span class="attribute">-exec</span> <span class="built_in">.</span>/mv<span class="built_in">.</span>sh <span class="string">'{}'</span> <span class="subst">\</span>;
</code></pre><p>所以，任何情况下你在find命令执行中想使用同一个文件名多次的话，先写一个脚本，然后在find中通过-exec执行这个脚本，把文件名参数传递进去就行，这是最简单的办法</p>
<p><strong>例13： 将错误重定向到/dev/nul</strong></p>
<p>重定向错误输出一般不是什么好的想法。一个有经验的程序员懂得在终端显示错误并及时修正它是很重要的。</p>
<p>尤其是在find命令中重定向错误不是个好的实践。 但是如果你确实不想看到那些烦人的错误，想把错误都重定向到null设备中（也就是linux上的黑洞装置，任何丢进去的东西消失的无影无踪了）。你可以像下面这样做</p>
<pre><code>find -name <span class="string">"*.txt"</span> <span class="number">2</span>&gt;&gt;<span class="regexp">/dev/</span><span class="literal">null</span>
</code></pre><p>有时候这是很有用的。比如，如果你想通过你自己的账号在/目录下查找所有的*.conf文件，你会得到很多很多的”Permission denied”的错误消息， 就像下面这样：</p>
<pre><code>$ find <span class="subst">/</span> <span class="attribute">-name</span> <span class="string">"*.conf"</span>
/sbin/generate<span class="attribute">-modprobe</span><span class="built_in">.</span>conf
find: /tmp/orbit<span class="attribute">-root</span>: Permission denied
find: /tmp/ssh<span class="attribute">-gccBMp5019</span>: Permission denied
find: /tmp/keyring<span class="subst">-</span><span class="number">5</span>iqiGo: Permission denied
find: /<span class="built_in">var</span>/<span class="keyword">log</span>/httpd: Permission denied
find: /<span class="built_in">var</span>/<span class="keyword">log</span>/ppp: Permission denied
/boot/grub/grub<span class="built_in">.</span>conf
find: /<span class="built_in">var</span>/<span class="keyword">log</span>/audit: Permission denied
find: /<span class="built_in">var</span>/<span class="keyword">log</span>/squid: Permission denied
find: /<span class="built_in">var</span>/<span class="keyword">log</span>/samba: Permission denied
find: /<span class="built_in">var</span>/<span class="keyword">cache</span>/alchemist/printconf<span class="built_in">.</span>rpm/wm: Permission denied
<span class="preprocessor">[</span>Note: There are two valid <span class="subst">*</span><span class="built_in">.</span>conf files burned <span class="keyword">in</span> the <span class="string">"Permission denied"</span> messages<span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p>你说烦人不？所以，如果你只想看到find命令真实的查找结果而不是这些”Permission denied”错误消息，你可以将这些错误消息重定向到/dev/null中去</p>
<pre><code>$ find <span class="subst">/</span> <span class="attribute">-name</span> <span class="string">"*.conf"</span> <span class="number">2</span><span class="subst">&gt;&gt;</span>/dev/<span class="built_in">null</span>
/sbin/generate<span class="attribute">-modprobe</span><span class="built_in">.</span>conf
/boot/grub/grub<span class="built_in">.</span>conf
<span class="preprocessor">[</span>Note: <span class="literal">All</span> the <span class="string">"Permission denied"</span> messages are <span class="literal">not</span> displayed<span class="preprocessor">]</span><span class="markup"></span>
</code></pre><p><strong>例14： 将文件名中的空格换成下划线</strong></p>
<p>你从网上下载下来的音频文件的文件名很多都带有空格。但是带有空格的文件名在linux(类Unix)系统里面是很不好的。你可以使用find然后后面加上rename命令的替换功能去重命名这些文件，将空格转换成下划线</p>
<p>下面显示怎样将所有mp3文件的文件名中的空格换成_</p>
<pre><code>$ find . -<span class="typedef"><span class="keyword">type</span> f -iname “*.mp3″ -exec rename “s/ /_/g” <span class="container">{}</span> \;</span>
</code></pre><p><strong>例15： 在find结果中同时执行两条命令</strong></p>
<p>在find的man page页面中，下面是一次文件查找遍历中使用两条命令的语法举例</p>
<p>下面的find命令的例子，遍历文件系统一次，列出拥有setuid属性的文件和目录，写入/root/suid.txt文件， 如果文件大小超过100M，将其记录到/root/big.txt中</p>
<pre><code><span class="array"># find </span>/ \( -perm -<span class="number">4000</span> -fprintf /root/suid.txt <span class="string">'%#m %u %p\n'</span> \) , \
\( -size +<span class="number">100</span>M -fprintf /root/big.txt <span class="string">'%-10s %p\n'</span> \)
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/妈咪，我找到了!----15个实用的linux-find命令示例/">
  <time datetime="2014-05-14T06:20:06.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/妈咪，我找到了!----15个实用的linux-find命令示例/">妈咪，我找到了! -- 15个实用的Linux find命令示例</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>除了在一个目录结构下查找文件这种基本的操作，你还可以用find命令实现一些实用的操作，使你的命令行之旅更加简易。</p>
<p>本文将介绍15种无论是于新手还是老鸟都非常有用的Linux find命令。</p>
<p>首先，在你的home目录下面创建下面的空文件，来测试下面的find命令示例。</p>
<pre><code><span class="preprocessor"># vim create_sample_files.sh</span>
touch MybashProgram<span class="preprocessor">.sh</span>
touch mycprogram<span class="preprocessor">.c</span>
touch MyCProgram<span class="preprocessor">.c</span>
touch Program<span class="preprocessor">.c</span>

mkdir backup
cd backup

touch MybashProgram<span class="preprocessor">.sh</span>
touch mycprogram<span class="preprocessor">.c</span>
touch MyCProgram<span class="preprocessor">.c</span>
touch Program<span class="preprocessor">.c</span>

<span class="preprocessor"># chmod +x create_sample_files.sh</span>

<span class="preprocessor"># ./create_sample_files.sh</span>

<span class="preprocessor"># ls -R</span>
<span class="label">.:</span>
backup                  MybashProgram<span class="preprocessor">.sh</span>  MyCProgram<span class="preprocessor">.c</span>
create_sample_files<span class="preprocessor">.sh</span>  mycprogram<span class="preprocessor">.c</span>      Program<span class="preprocessor">.c</span>

./backup:
MybashProgram<span class="preprocessor">.sh</span>  mycprogram<span class="preprocessor">.c</span>  MyCProgram<span class="preprocessor">.c</span>  Program<span class="preprocessor">.c</span>
</code></pre><p><strong>1. 用文件名查找文件</strong></p>
<p>这是find命令的一个基本用法。下面的例子展示了用MyCProgram.c作为查找名在当前目录及其子目录中查找文件的方法。</p>
<pre><code><span class="preprocessor"># find -name "MyCProgram.c"</span>
./backup/MyCProgram<span class="preprocessor">.c</span>
./MyCProgram<span class="preprocessor">.c</span>
</code></pre><p><strong>2.用文件名查找文件，忽略大小写</strong></p>
<p>这是find命令的一个基本用法。下面的例子展示了用MyCProgram.c作为查找名在当前目录及其子目录中查找文件的方法，忽略了大小写。</p>
<pre><code><span class="preprocessor"># find -iname "MyCProgram.c"</span>
./mycprogram<span class="preprocessor">.c</span>
./backup/mycprogram<span class="preprocessor">.c</span>
./backup/MyCProgram<span class="preprocessor">.c</span>
./MyCProgram<span class="preprocessor">.c</span>
</code></pre><p><strong>3. 使用mindepth和maxdepth限定搜索指定目录的深度</strong></p>
<p>在root目录及其子目录下查找passwd文件。</p>
<pre><code><span class="preprocessor"># find / -name passwd</span>
./usr/share/doc/nss_ldap-<span class="number">253</span>/pam<span class="preprocessor">.d</span>/passwd
./usr/bin/passwd
./etc/pam<span class="preprocessor">.d</span>/passwd
./etc/passwd
</code></pre><p>在root目录及其1层深的子目录中查找passwd. (例如root — level 1, and one sub-directory — level 2)</p>
<pre><code><span class="preprocessor"># find -maxdepth 2 -name passwd</span>
./etc/passwd
</code></pre><p>在root目录下及其最大两层深度的子目录中查找passwd文件. (例如 root — level 1, and two sub-directories — level 2 and 3 )</p>
<pre><code><span class="preprocessor"># find / -maxdepth 3 -name passwd</span>
./usr/bin/passwd
./etc/pam.d/passwd
./etc/passwd
</code></pre><p>在第二层子目录和第四层子目录之间查找passwd文件。</p>
<pre><code><span class="preprocessor"># find -mindepth 3 -maxdepth 5 -name passwd</span>
./usr/bin/passwd
./etc/pam.d/passwd
</code></pre><p><strong>4. 在find命令查找到的文件上执行命令</strong></p>
<p>下面的例子展示了find命令来计算所有不区分大小写的文件名为“MyCProgram.c”的文件的MD5验证和。{}将会被当前文件名取代。</p>
<pre><code>find -iname <span class="string">"MyCProgram.c"</span> -exec md5sum {} \;
d41d8<span class="built_in">cd</span>98f00b204e9800998ecf8427e  ./mycprogram.c
d41d8<span class="built_in">cd</span>98f00b204e9800998ecf8427e  ./backup/mycprogram.c
d41d8<span class="built_in">cd</span>98f00b204e9800998ecf8427e  ./backup/MyCProgram.c
d41d8<span class="built_in">cd</span>98f00b204e9800998ecf8427e  ./MyCProgram.c
</code></pre><p><strong>5. 相反匹配</strong></p>
<p>显示所有的名字不是MyCProgram.c的文件或者目录。由于maxdepth是1，所以只会显示当前目录下的文件和目录。</p>
<pre><code>find -maxdepth <span class="number">1</span> -not -iname <span class="string">"MyCProgram.c"</span>
.
./MybashProgram<span class="preprocessor">.sh</span>
./create_sample_files<span class="preprocessor">.sh</span>
./backup
./Program<span class="preprocessor">.c</span>
</code></pre><p><strong>6. 使用inode编号查找文件</strong></p>
<p>任何一个文件都有一个独一无二的inode编号，借此我们可以区分文件。创建两个名字相似的文件，例如一个有空格结尾，一个没有。</p>
<pre><code>touch <span class="string">"test-file-name"</span>

<span class="comment"># touch "test-file-name "</span>
[Note: There <span class="keyword">is</span> a <span class="constant">space</span> <span class="keyword">at</span> <span class="keyword">the</span> <span class="keyword">end</span>]

<span class="comment"># ls -1 test*</span>
test-<span class="type">file</span>-<span class="property">name</span>
test-<span class="type">file</span>-<span class="property">name</span>
</code></pre><p>从ls的输出不能区分哪个文件有空格结尾。使用选项-i，可以看到文件的inode编号，借此可以区分这两个文件。</p>
<pre><code>ls <span class="attribute">-i1</span> test<span class="subst">*</span>
<span class="number">16187429</span> test<span class="attribute">-file</span><span class="attribute">-name</span>
<span class="number">16187430</span> test<span class="attribute">-file</span><span class="attribute">-name</span>
</code></pre><p>你可以如下面所示在find命令中指定inode编号。在此，find命令用inode编号重命名了一个文件。</p>
<pre><code>find -inum <span class="number">16187430</span> -exec mv {} new-test-<span class="type">file</span>-<span class="property">name</span> \;

<span class="comment"># ls -i1 *test*</span>
<span class="number">16187430</span> new-test-<span class="type">file</span>-<span class="property">name</span>
<span class="number">16187429</span> test-<span class="type">file</span>-<span class="property">name</span>
</code></pre><p>你可以在你想对那些像上面一样的糟糕命名的文件做某些操作时使用这一技术。例如，名为file?.txt的文件名字中有一个特殊字符。若你想执行“rm file?.txt”，下面所示的所有三个文件都会被删除。所以，采用下面的步骤来删除”file?.txt”文件。</p>
<pre><code>ls
file1<span class="preprocessor">.txt</span>  file2<span class="preprocessor">.txt</span>  file?<span class="preprocessor">.txt</span>
</code></pre><p>找到每一个文件的inode编号。</p>
<pre><code>ls -i1
<span class="number">804178</span> file1<span class="preprocessor">.txt</span>
<span class="number">804179</span> file2<span class="preprocessor">.txt</span>
<span class="number">804180</span> file?<span class="preprocessor">.txt</span>
</code></pre><p>如下所示： 使用inode编号来删除那些具有特殊符号的文件名。</p>
<pre><code>find -inum <span class="number">804180</span> -exec rm {} \;

<span class="comment"># ls</span>
file1.txt  file2.txt
[Note: The <span class="type">file</span> <span class="keyword">with</span> <span class="property">name</span> <span class="string">"file?.txt"</span> <span class="keyword">is</span> now removed]
</code></pre><p><strong>7. 根据文件权限查找文件</strong></p>
<p>下面的操作时合理的：</p>
<ul>
<li>找到具有指定权限的文件</li>
<li>忽略其他权限位，检查是否和指定权限匹配</li>
<li>根据给定的八进制/符号表达的权限搜索</li>
</ul>
<p>此例中，假设目录包含以下文件。注意这些文件的权限不同。</p>
<pre><code>ls -l
total 0
-<span class="ruby">rwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">31</span> all_for_all
</span>-<span class="ruby">rw-r--r-- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">30</span> everybody_read
</span>-<span class="ruby">--------- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">31</span> no_for_all
</span>-<span class="ruby">rw------- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">29</span> ordinary_file
</span>-<span class="ruby">rw-r----- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> others_can_also_read
</span>-<span class="ruby">---r----- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> others_can_only_read</span>
</code></pre><p>找到具有组读权限的文件。使用下面的命令来找到当前目录下对同组用户具有读权限的文件，忽略该文件的其他权限。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-perm</span> <span class="attribute">-g</span><span class="subst">=</span>r <span class="attribute">-type</span> f <span class="attribute">-exec</span> ls <span class="attribute">-l</span> {} <span class="subst">\</span>;
<span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">--</span>r<span class="subst">--</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span><span class="subst">-</span><span class="number">02</span><span class="subst">-</span><span class="number">19</span> <span class="number">20</span>:<span class="number">30</span> <span class="built_in">.</span>/everybody_read
<span class="attribute">-rwxrwxrwx</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span><span class="subst">-</span><span class="number">02</span><span class="subst">-</span><span class="number">19</span> <span class="number">20</span>:<span class="number">31</span> <span class="built_in">.</span>/all_for_all
<span class="subst">----</span>r<span class="subst">-----</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span><span class="subst">-</span><span class="number">02</span><span class="subst">-</span><span class="number">19</span> <span class="number">20</span>:<span class="number">27</span> <span class="built_in">.</span>/others_can_only_read
<span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">-----</span> <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span><span class="subst">-</span><span class="number">02</span><span class="subst">-</span><span class="number">19</span> <span class="number">20</span>:<span class="number">27</span> <span class="built_in">.</span>/others_can_also_read
</code></pre><p>找到对组用户具有只读权限的文件。</p>
<pre><code><span class="title">find</span> . -perm g=r -<span class="typedef"><span class="keyword">type</span> f -exec ls -l <span class="container">{}</span> \;</span>
<span class="comment">----r----- 1 root root 0 2009-02-19 20:27 ./others_can_only_read</span>
</code></pre><p>找到对组用户具有只读权限的文件(使用八进制权限形式)。</p>
<pre><code><span class="title">find</span> . -perm <span class="number">040</span> -<span class="typedef"><span class="keyword">type</span> f -exec ls -l <span class="container">{}</span> \;</span>
<span class="comment">----r----- 1 root root 0 2009-02-19 20:27 ./others_can_only_read</span>
</code></pre><p><strong>8. 找到home目录及子目录下所有的空文件(0字节文件)</strong></p>
<p>下面命令的输出文件绝大多数都是锁定文件盒其他程序创建的place hoders</p>
<pre><code>find ~ -<span class="keyword">empty</span>
</code></pre><p>只列出你home目录里的空文件。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-maxdepth</span> <span class="number">1</span> <span class="attribute">-empty</span>
</code></pre><p>只列出当年目录下的非隐藏空文件。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-maxdepth</span> <span class="number">1</span> <span class="attribute">-empty</span> <span class="attribute">-not</span> <span class="attribute">-name</span> <span class="string">".*"</span>
</code></pre><p><strong>9. 查找5个最大的文件</strong></p>
<p>下面的命令列出当前目录及子目录下的5个最大的文件。这会需要一点时间，取决于命令需要处理的文件数量。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-type</span> f <span class="attribute">-exec</span> ls <span class="attribute">-s</span> {} <span class="subst">\</span>; <span class="subst">|</span> sort <span class="attribute">-n</span> <span class="attribute">-r</span> <span class="subst">|</span> head <span class="subst">-</span><span class="number">5</span>
</code></pre><p><strong>10. 查找5个最小的文件</strong></p>
<p>方法同查找5个最大的文件类似，区别只是sort的顺序是降序。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-type</span> f <span class="attribute">-exec</span> ls <span class="attribute">-s</span> {} <span class="subst">\</span>; <span class="subst">|</span> sort <span class="attribute">-n</span>  <span class="subst">|</span> head <span class="subst">-</span><span class="number">5</span>
</code></pre><p>上面的命令中，很可能你看到的只是空文件(0字节文件)。如此，你可以使用下面的命令列出最小的文件，而不是0字节文件。</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-not</span> <span class="attribute">-empty</span> <span class="attribute">-type</span> f <span class="attribute">-exec</span> ls <span class="attribute">-s</span> {} <span class="subst">\</span>; <span class="subst">|</span> sort <span class="attribute">-n</span>  <span class="subst">|</span> head <span class="subst">-</span><span class="number">5</span>
</code></pre><p><strong>11. 使用-type查找指定文件类型的文件</strong></p>
<p>只查找socket文件</p>
<pre><code>find . -<span class="class"><span class="keyword">type</span> <span class="title">s</span></span>
</code></pre><p>查找所有的目录</p>
<pre><code>find . -<span class="class"><span class="keyword">type</span> <span class="title">d</span></span>
</code></pre><p>查找所有的一般文件</p>
<pre><code>find . -<span class="class"><span class="keyword">type</span> <span class="title">f</span></span>
</code></pre><p>查找所有的隐藏文件</p>
<pre><code>find <span class="built_in">.</span> <span class="attribute">-type</span> f <span class="attribute">-name</span> <span class="string">".*"</span>
</code></pre><p>查找所有的隐藏目录</p>
<pre><code>find <span class="attribute">-type</span> d <span class="attribute">-name</span> <span class="string">".*"</span>
</code></pre><p><strong>12. 通过和其他文件比较修改时间查找文件</strong></p>
<p>显示在指定文件之后做出修改的文件。下面的find命令将显示所有的在ordinary_file之后创建修改的文件。</p>
<pre><code>ls -lrt
total 0
-<span class="ruby">rw-r----- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> others_can_also_read
</span>-<span class="ruby">---r----- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">27</span> others_can_only_read
</span>-<span class="ruby">rw------- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">29</span> ordinary_file
</span>-<span class="ruby">rw-r--r-- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">30</span> everybody_read
</span>-<span class="ruby">rwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">31</span> all_for_all
</span>-<span class="ruby">--------- <span class="number">1</span> root root <span class="number">0</span> <span class="number">2009</span>-<span class="number">02</span>-<span class="number">19</span> <span class="number">20</span><span class="symbol">:</span><span class="number">31</span> no_for_all
</span>
# find -newer ordinary_file
.
./everybody_read
./all_for_all
./no_for_all
</code></pre><p><strong>13. 通过文件大小查找文件</strong></p>
<p>使用-size选项可以通过文件大小查找文件。</p>
<p>查找比指定文件大的文件</p>
<pre><code><span class="built_in">find</span> ~ -<span class="built_in">size</span> +<span class="number">100</span>M
</code></pre><p>查找比指定文件小的文件</p>
<pre><code><span class="built_in">find</span> ~ -<span class="built_in">size</span> -<span class="number">100</span>M
</code></pre><p>查找符合给定大小的文件</p>
<pre><code><span class="built_in">find</span> ~ -<span class="built_in">size</span> <span class="number">100</span>M
</code></pre><p>注意: – 指比给定尺寸小，+ 指比给定尺寸大。没有符号代表和给定尺寸完全一样大。</p>
<p><strong>14. 给常用find操作取别名</strong></p>
<p>若你发现有些东西很有用，你可以给他取别名。并且在任何你希望的地方执行。</p>
<p>常用的删除a.out文件。</p>
<pre><code><span class="keyword">alias</span> rmao=<span class="string">"find . -iname a.out -exec rm {} \;"</span>
<span class="comment"># rmao</span>
</code></pre><p>删除c程序产生的core文件。</p>
<pre><code><span class="keyword">alias</span> rmc=<span class="string">"find . -iname core -exec rm {} \;"</span>
<span class="comment"># rmc</span>
</code></pre><p><strong>15. 用find命令删除大型打包文件</strong></p>
<p>下面的命令删除大于100M的*.zip文件。</p>
<pre><code>find <span class="subst">/</span> <span class="attribute">-type</span> f <span class="attribute">-name</span> <span class="subst">*</span><span class="built_in">.</span>zip <span class="attribute">-size</span> <span class="subst">+</span><span class="number">100</span>M <span class="attribute">-exec</span> rm <span class="attribute">-i</span> {} <span class="subst">\</span>;<span class="string">"</span>
</code></pre><p>用别名rm100m删除所有大雨100M的*.tar文件。使用同样的思想可以创建rm1g,rm2g,rm5g的一类别名来删除所有大于1G,2G,5G的文件。</p>
<pre><code>alias rm100m=<span class="string">"find / -type f -name *.tar -size +100M -exec rm -i {} \;"</span>
<span class="preprocessor"># alias rm1g="find / -type f -name *.tar -size +1G -exec rm -i {} \;"</span>
<span class="preprocessor"># alias rm2g="find / -type f -name *.tar -size +2G -exec rm -i {} \;"</span>
<span class="preprocessor"># alias rm5g="find / -type f -name *.tar -size +5G -exec rm -i {} \;"</span>

<span class="preprocessor"># rm100m</span>
<span class="preprocessor"># rm1g</span>
<span class="preprocessor"># rm2g</span>
<span class="preprocessor"># rm5g</span>
</code></pre><p>Find命令示例(第二部分)</p>
<p>若你喜欢这篇关于find命令的Mommy文章，别忘了看看第二部分的关于find命令的Daddy文章。<a href="http://www.oschina.net/translate/15-practical-unix-linux-find-command-examples-part-2" target="_blank">爹地，我找到了!, 15个极好的Linux find命令示例</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/thoughtworks(中国)-程序员读书雷达/">
  <time datetime="2014-05-14T06:13:08.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/thoughtworks(中国)-程序员读书雷达/">ThoughtWorks(中国) 程序员读书雷达</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><img src="http://waakaakaa.qiniudn.com/reading-radar.jpg" alt="image"></p>
<p>软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。</p>
<p>ThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。</p>
<p>现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。</p>
<p>该读书雷达将书籍分为了如下四个维度：</p>
<blockquote>
<p>Coding Practice（编程实践）</p>
<p>Architecture &amp; Design（架构与设计）</p>
<p>Methodology（方法学）</p>
<p>Thought &amp; Leadership（思想与领导力）</p>
</blockquote>
<p>我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。</p>
<p>每个维度皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。</p>
<p>或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，”吾生也有涯，而知也无涯”，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodolog（方法学）维度，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于我和刘龙军还不够擅长的领域，我们不敢也不愿做出可能误导人的推荐。</p>
<p>本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。</p>
<p>我将在后面的文章中，根据每个维度为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示(感谢凯峰为这个雷达图建立的豆列，可以访问<a href="http://book.douban.com/doulist/2012097/" target="_blank">ThoughtWorks(中国)程序员读书雷达</a>)：</p>
<p><strong>Coding Practice | 编程实践</strong></p>
<p>基础篇</p>
<blockquote>
<p>Clean Code《代码整洁之道》</p>
<p>Pragmatic Unit Testing《单元测试之道》</p>
<p>The Productive Programmer《卓有成效的程序员》</p>
<p>Test-Driven Development By Example《测试驱动开发》</p>
<p>Clean Coder《程序员的职业修养》</p>
<p>The Art of Readable Code《编写可读代码的艺术》</p>
</blockquote>
<p>进阶篇</p>
<blockquote>
<p>Refactoring To Patterns《重构与模式》</p>
<p>Implementation Patterns《实现模式》</p>
<p>Code Completed《代码大全》</p>
<p>The Pragmatic Programmer《程序员修炼之道》</p>
</blockquote>
<p>高级篇</p>
<blockquote>
<p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》</p>
<p>Working Effectively with Legacy Code《修改代码的艺术》</p>
</blockquote>
<p><strong>Architecture &amp; Design | 架构与设计</strong></p>
<p>基础篇</p>
<blockquote>
<p>Agile Software Development 《敏捷软件开发：原则、实践与模式》</p>
<p>Head First Design Patterns《深入浅出设计模式》</p>
<p>Design Patterns 《设计模式》</p>
</blockquote>
<p>进阶篇</p>
<blockquote>
<p>The Art of UNIX Programming 《Unix编程艺术》</p>
<p>Practical API Design 《框架设计的艺术》</p>
<p>Domain Specific Languages 《领域特定语言》</p>
<p>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p>
</blockquote>
<p>高级篇</p>
<blockquote>
<p>Release It </p>
<p>Domain-Driven Design 《领域驱动设计》</p>
<p>Enterprise Integration Patterns《企业集成模式》</p>
<p>Beautiful Architecture《架构之美》</p>
<p>Pattern-Oriented Software Architecture《面向模式的软件架构》</p>
</blockquote>
<p><strong>Methodology | 方法学</strong></p>
<p>基础篇</p>
<blockquote>
<p>User Stories Applied《用户故事与敏捷方法》</p>
<p>The Gold Mine《金矿》</p>
<p>Scrum and XP From the Trenches《硝烟中的Scrum和XP》</p>
<p>Continuous Integration《持续集成》</p>
<p>Extreme Programming Explained《解析极限编程》</p>
</blockquote>
<p>进阶篇</p>
<blockquote>
<p>Lean Thinking《精益思想》</p>
<p>Continuous Delivery《持续交付》</p>
<p>How Google Tests Software</p>
<p>Agile Testing</p>
<p>Extreme Programming Refactored《重构极限编程》</p>
</blockquote>
<p>高级篇</p>
<blockquote>
<p>Specification By Example</p>
</blockquote>
<p><strong>Thought &amp; Leadership | 思想与领导力</strong></p>
<p>基础篇</p>
<blockquote>
<p>The Effective Executive《卓有成效的管理者》</p>
<p>Are Your Lights On?《你的灯亮着吗》</p>
<p>Becoming A Technical Leader《成为技术领导者》</p>
</blockquote>
<p>进阶篇</p>
<blockquote>
<p>The Fifth Discipline《第五项修炼》</p>
<p>The Design Of Business</p>
<p>Management 3.0《管理3.0：培养和提升敏捷领导力》</p>
<p>Presentation To Win</p>
<p>The McKinsey Way《麦肯锡方法》</p>
</blockquote>
<p>高级篇</p>
<blockquote>
<p>Thinking, Fast and Slow《思考快与慢》</p>
</blockquote>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/vim学习指南/">
  <time datetime="2014-05-14T05:38:38.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/vim学习指南/">Vim学习指南</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>英文原文：<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank">Learn Vim Progressively</a></p>
<p>你想尽可能快地自学vim(为大家所熟知的最好的编辑器) 。这是我学习的方法：从细处入手然后慢慢掌握所有技巧。</p>
<p>Vim 六十亿美元的编辑器</p>
<blockquote>
<p>设计优良，强壮，快速。</p>
</blockquote>
<p>学习vim并把它作为你的下一个文本编辑器，据我所知没有比它更好的编辑器，学起来难但出奇的好用。</p>
<p>我建议你按下附4个步骤学习Vim：</p>
<ol>
<li>适应</li>
<li>感觉舒适</li>
<li>感觉很好，强壮，快速</li>
<li>使用vim的高级技能</li>
</ol>
<p>本课程结束时你将成为一个vim高手。</p>
<p>但在我们开始之前，先提醒一下。刚开始学习vim会有点痛苦，它很费时间，有点像玩乐器一样。不要指望能像其他编辑器一样花3天以内的时间便能很好的使用它，事实上，这肯定要花2周而不是3天。</p>
<h1 id="第一层次_–_适应">第一层次 – 适应</h1>
<ol>
<li>安装vim</li>
<li>运行vim</li>
<li>什么也别做，读！</li>
</ol>
<p>在标准的编辑器里，写一些东西到屏幕上只需要在键盘上输入就足够了，在Vim中不是这样。Vim在普通模式里，让我们转到插入模式，键入字符i。</p>
<p>你应该感觉好一点了，能像在标准编辑器里输入了，回到普通模式只需按ESC键即可。</p>
<p>你现在知道了如何在插入和普通模式之间转换，下面是你在普通模式下需要记住的指令：</p>
<p>&gt;</p>
<ul>
<li>i→ 插入模式. 按ESC键返回普通模式</li>
<li>x→ 删除光标所在的字符</li>
<li>:wq→ 保存退出(:w 保存，:q 退出)</li>
<li>dd→ 删除(拷贝)当前行</li>
<li>p→ 粘贴<br>&gt;<br>推荐<br>&gt;</li>
<li>hjkl(高度推荐) → 基本的光标移动 (←↓↑→)， hj按行移动。</li>
<li>:help <command>→ 显示关于<command>的帮助，可以使用help不带<command>获得常规帮助。</li>
</ul>
<p>只有5个命令，一开始只需掌握这些，当适应了这些命令后（大概需要一天或更多的诗句），你可以转到第二层级了。</p>
<p>但首先，稍回顾一下普通模式。在标准编辑器里，要复制的话你需要使用ctrl键（Ctrl-c）。实际上，当你按<br>下ctrl键时所有的按键的意义都改变了。在vim普通模式下就像在ctrl键自动按下的情况下使用编辑器。</p>
<p>最后的补充：</p>
<ul>
<li>我使用<C-λ>代替Ctrl-λ</li>
<li>命令后附带回车，比如我若是写:q，我是指:q<enter></li>
</ul>
<h1 id="第二层_-_爽一把">第二层 - 爽一把</h1>
<p>你懂的，命令是由需求所定。是时候学习更多命令了。下面这些是我的建议：</p>
<ol>
<li>插入模式变种命令：<br>&gt;<ul>
<li>a→ 在光标后插入</li>
<li>o→ 在当前行之后插入新行</li>
<li>O→ 在当前行之前插入新行</li>
<li>cw→ 替换从光标到单词结束</li>
</ul>
</li>
<li>基本移动命令<br>&gt;<ul>
<li>0→ 跳到第一列</li>
<li>^→ 跳到本行第一个非空字符</li>
<li>$→ 跳到本行末尾</li>
<li>g_→ 跳到本行最后一个非空字符</li>
<li>/pattern→ 搜索pattern</li>
</ul>
</li>
<li>复制/粘贴<br>&gt;<ul>
<li>P→ 在当前位置之前粘贴，记住 p 是在当前位置之前粘贴.</li>
<li>yy→ 复制当前行，与dd和P命令相比更简单。</li>
</ul>
</li>
<li>取消/恢复<br>&gt;<ul>
<li>u→ 取消</li>
<li><C-r>→ 恢复</li>
</ul>
</li>
<li>加载/保存/退出/修改 文件(缓存)<br>&gt;<ul>
<li>:e &lt;文件路径&gt;→ 打开</li>
<li>:w→ 保存</li>
<li>:saveas &lt;文件路径&gt;→ 保存到这个文件</li>
<li>:x,ZZ或者:wq→ 保存和退出 (:x 如果可能的话，只保存)</li>
<li>:q!→ 退出但不保存，使用:qa!，即使在缓存中还有已经修改的也会退出。</li>
<li>:bn(对比:bp) → 显示下一个(上一个)文件缓存</li>
</ul>
</li>
</ol>
<p>花些时间学习所有这些命令。一旦完成后，你应该就能完成在像在其它编辑器中所有事情。也许，你可能还会觉得有点笨手笨脚。但是跟着我进入下一个层次，你就会发现为什么vim值得你额外付出的努力。</p>
<h1 id="第三层次_-_更好，更强，更快">第三层次 - 更好，更强，更快</h1>
<p>恭喜进入第三层次！现在我们开始一些有趣的事。在第三层次中，我们只会谈论那些和vi编辑器兼容的命令</p>
<p><strong>更好</strong></p>
<p>让我们看看vim是如何帮助我们做重复工作的:</p>
<ol>
<li>.→ (点)会重做最后一个命令,</li>
<li>N&lt;命令&gt; → 会重做这个命令N次.</li>
</ol>
<p>一些例子，打开文件然后输入:</p>
<p>&gt;</p>
<ul>
<li>2dd→ 会删除2行</li>
<li>3p→ 会粘贴文本3次</li>
<li>100idesu [ESC]→ 会写入“desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu”</li>
<li>.→ 在最后一个命令之后会在此写入100个”desu”.</li>
<li>3.→ 会写入3个“desu”(并不是300个, 聪明极了).</li>
</ul>
<p><strong>更强</strong></p>
<p>掌握高效率使用vim是十分重要的。请不要跳过这节。</p>
<ol>
<li>NG→ 跳到第N行</li>
<li>gg→ 是1G的快捷方式 - 跳到文件的开始</li>
<li>G→ 跳到最后一行</li>
<li>单词间移动:</li>
</ol>
<p>&gt;</p>
<ol>
<li>w→ 跳到下一个单词的开头,</li>
<li>e→ 跳到这个单词的末尾.<br>&gt;<br>默认，单词是有字母和下划线组成。这里我们所谓的单词就是由空格分隔的。如果你只想考虑单词，就使用大写的字符吧:<br>&gt;</li>
<li>W→跳到下一个单词的开头,</li>
<li>E→ 跳到这个单词的末尾.<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135039_AdpL.jpg" alt="image"></li>
</ol>
<p>现在，我们谈论高效率移动：</p>
<p>&gt;</p>
<ul>
<li>%: 跳到对应的(, (, [ 处.</li>
<li>*(对比#) : 跳到当前光标的下一个(上一个) 相同单词的地方</li>
</ul>
<p>信我，最后3个命令价比黄金。</p>
<p><strong>更快</strong></p>
<p>记住了vi移动的重要性？这里就是原因。大多数命令使用下面这种通用格式：</p>
<p>&lt;开始位置&gt;&lt;命令&gt;&lt;结束位置&gt;</p>
<p>例如： 0y$意味着</p>
<ul>
<li>0→ 跳到本行开头</li>
<li>y→ 从这里开始复制</li>
<li>$→ 直到本行结束</li>
</ul>
<p>我们也可以使用ye，从当前位置复制到单词的末尾。但是y2/foo 会一直复制到第二个foo出现的地方。</p>
<p>但对于y（复制）， d(删除), v(visual 选择)， gU(大写)， gu(小写)等等命令都是真实的。</p>
<h1 id="第四层次_–_Vim_超能量">第四层次 – Vim 超能量</h1>
<p>使用上述的命令，是否觉得很爽了。但是现在，这里才是杀手锏。正因为其中有些特性，我才使用vim的。</p>
<p><strong>在当前行移动:0^$g_fFtT,;</strong></p>
<p>&gt;</p>
<ul>
<li>0→ 跳到第一列</li>
<li>^→ 跳到当前行的第一个字符</li>
<li>$→ 跳到最后一列</li>
<li>g_→ 跳到这行的最后一个字符</li>
<li>fa→ 跳到这行a字母的下一个出现的地方。（对比 ; ）会查找下一个（上一个）地方</li>
<li>t,→ 跳到，字符的前一个字符.</li>
<li>3fa→ 在这行中查找a出现的第三个位置.</li>
<li>F 和 T→ 与f和t相似， 但是方向相反.<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135039_vFzT.jpg" alt="image"></li>
</ul>
<p>一个有用的提示：dt”→删除所有的直到”。</p>
<p><strong>区域选择 ： &lt;命令&gt;a&lt;对象&gt; 或 &lt;命令&gt;i&lt;对象&gt;</strong></p>
<p>这些命令仅仅能用在可视化模式的一个操作后。但是他们相当的有用。他们的主要模式有：</p>
<p>&lt;命令&gt;a&lt;对象&gt; 和 &lt;命令&gt;i&lt;对象&gt;</p>
<p>命令可以是任何命令，例如 , d(删除),y(拉取),v(进入可视化模式)。对象可以是: w一个单词，W一个单词 (扩展的)，s一个句子，p一个段落。而且也可以是普通的字符， 例如”，’，)，}，]。</p>
<p>假设现在光标在 (map (+) (“foo”)) 这个字符串的第一个o上。</p>
<p>&gt;</p>
<ul>
<li>vi”→ 将会选择 foo</li>
<li>va”→ 将会选择 “foo”</li>
<li>vi)→ 将会选择 “foo”</li>
<li>va)→ 将会选择 (“foo”)</li>
<li>v2i)→ 将会选择 map (+) (“foo”)</li>
<li>v2a)→ 将会选择 (map (+) (“foo”))<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135040_FZZt.png" alt="image"></li>
</ul>
<p><strong>矩形选择块:<C-v></strong></p>
<p>矩形选择块能够方便的对多行代码进行注释。 如:0<C-v><C-d>I— [ESC]</p>
<p>&gt;</p>
<ul>
<li>^→ 将光标定位到这行第一个非空格字符</li>
<li><C-v>→ 选择开始位置</li>
<li><C-d>→ 向下移动 (也可使用 jjj 或者 % ， 其他…)</li>
<li>I— [ESC]→ 用 — 来注释每一行<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135040_1Cyy.gif" alt="image"></li>
</ul>
<p>提示：如果你的剪贴板在Windows中是非空的话，那么你就不得不使用<C-q>来代替<C-v>。</p>
<p><strong>实现:<C-n>和<C-p>.</strong></p>
<p>在插入模式中：只要打出单词的首字母，然后按<C-p>，神奇的事情就发生了…</p>
<p><img src="http://waakaakaa.qiniudn.com/19135042_T1fu.gif" alt="image"></p>
<p><strong>宏命令 : qa 做的一些事,@a,@@</strong></p>
<p>qa 把你的动作记录在了寄存器 a 中。然后@a 就会将存在寄存器中的动作重现，就好像你从新打了一边。@@是将你最后一次执行的宏命令再次执行的快捷键。</p>
<p>&gt;<br>事例<br>&gt;<br>在只有数字1的一行上， 像这样键入命令:<br>&gt;</p>
<ul>
<li>qaYp<C-a>q→<ul>
<li>qa开始记录。</li>
<li>Yp记录这一行。</li>
<li><C-a>增加数字大小。</li>
<li>q停止记录。</li>
</ul>
</li>
<li>@a→ 在1下面写2</li>
<li>@@→ 在2下面写3</li>
<li>现在键入 100@@ 就将会产生一个到 103 的自增列。<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135042_jJUW.gif" alt="image"></li>
</ul>
<p><strong>可视化模式选择： v, V, <C-v></strong></p>
<p>我们已经看到过<C-v>例子，这里还有v和V。一旦已经选择好了，你可以：</p>
<p>&gt;</p>
<ul>
<li>J→ 让所有行连接在一起</li>
<li>&lt;(对比&gt;) → 向左（右）对齐.</li>
<li>=→ 自动对齐<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135043_Npsr.gif" alt="image"></li>
</ul>
<p>在可视化模式所选择的行的末尾添加一些东西：</p>
<p>&gt;</p>
<ul>
<li><C-v></li>
<li>跳到目的行 (jjj 或者 <C-d> 或者 /patternor%等等…)</li>
<li>$跳到行末尾</li>
<li>A, 写入一些文本，[按] ESC 键.<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135046_NfIl.gif" alt="image"></li>
</ul>
<p><strong>分割：： split 和 vsplit</strong></p>
<p>这些是很重要的命令，所以你应该在:help split看看。</p>
<p>&gt;</p>
<ul>
<li>:split→ 创建一个水平分割窗口t (:vsplit 创建一个竖直分割窗口)</li>
<li><C-w><dir>:  dir是hjklor←↓↑→中任何一个。用来切换分割窗口。</li>
<li><C-w>_(对比<C-w>|) : 用来最大化水平（竖直）分割窗口的大小</li>
<li><C-w>+(对比<C-w>-) : 增加 (减小) 分割窗口<br>&gt;<br><img src="http://waakaakaa.qiniudn.com/19135046_ivZR.gif" alt="image"></li>
</ul>
<h1 id="小结">小结</h1>
<p>这些是我经常使用的90%的命令。我建议你每天学习一到两个命令。在两到三周之后，你将会感觉到vim在你手上使用的是如此的强大。</p>
<p>学习vim更多的是记忆训练。值得高兴的是vim诞生了一些非常好的工具和优秀的文档。当你非常熟悉大部分基本命令之后就可以使用vimtutor了。另外，你应该仔细的阅读这页 ::help usr_02.txt.</p>
<p>然后，你要去学习了解寄存器，插件已经其它的功能。学习vim就像学钢琴一样，所有的都要掌握好。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/一种在图片里隐藏你的程序代码的技术/">
  <time datetime="2014-05-14T05:00:19.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/一种在图片里隐藏你的程序代码的技术/">一种在图片里隐藏你的程序代码的技术</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>我最近开发了我的第一个网页游戏：<a href="http://www.patrick-wied.at/projects/html5-video-puzzle" target="_blank">一个HTML5的视频智力游戏</a>。 开发的过程很有趣，我喜欢编程，但当实现了游戏逻辑后，我有了一个有趣的想法：为什么不想个办法把代码隐藏起来？起初我想到的是一些很简单的做法，比如禁 止上下文菜单，以防右键点击时可以查看页面源代码。但这毫无意义，右键菜单不能用，人们仍然可以通过键盘快捷键或菜单栏里的“查看源文件”来观看源代码。</p>
<p><strong>一张图片能隐含千言万语</strong>。</p>
<p>这依赖于图片的体积。但我决定要把源代码加密存放到一张图片里。HTML5的画布(canvas)组件很适合干这种事情，因为它支持针对图像像素的 操作。一个像素由四个值(通道)来表示：红，绿，蓝和alpha通道。它们的值的分布范围是从0到255。我的Javascript代码就是一个个的字 符，每个字符都有一个ASCII对应值。ASCII值的范围也是0-255，所以，我想做的是，遍历画布上的每个像素，给每个像素设置3个代码字符的 ASCII值作为它的RGB值，你可以通过charCodeAt函数轻松的取出这些字符。</p>
<blockquote>
<p>.charCodeAt(0)</p>
</blockquote>
<p>生成的是一张色彩斑斓、很小的图片，它就是我的程序代码  。看看吧:</p>
<p>解码的时候，我只需要把这个图片画到画布上，遍历像素点，取出r,g,b值所代表的字符：</p>
<blockquote>
<p>String.fromCharCode(code)</p>
</blockquote>
<p>把它们连接成一个大的字符串，这就是你的代码了——可执行的代码。 </p>
<p>这样就能保护你的源代码了吗？</p>
<p>其实不能——一个有经验的(甚至没有经验的)程序员仍然能够知道如何去解码图片，取出里面的代码，但我想这是能防止那些怀着不良商业目的人偷盗你的的代码的第一步措施——而那些能够想出如何解码的程序员(大部分)都不是来剽窃的 </p>
<p><strong>这种方法的主要缺陷</strong></p>
<p>这种技术只能应用在支持HTML5画布(canvas)技术的现代浏览器里，IE6、IE8 里肯定是不行的。甚至有些现代的浏览器对于图片的alpha通道的编码也有支持问题，所以，每个像素点你只能放3个字符——一个100×100大小的图片 可以存放3万个文本字符。 </p>
<p>你还有其它简单的能防止别人拷贝你的代码的方法吗？我们当然可以把字符进行加密，但如何保证你的解密步骤能不被人轻易的破解呢？告诉我你的想法吧！</p>
<p>[本文英文原文链接：<a href="http://www.patrick-wied.at/blog/a-technique-for-hiding-your-javascript-code" target="_blank">A technique for hiding your JavaScript Code</a> ]</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/java-处理-xml-的三种主流技术及介绍/">
  <time datetime="2014-05-14T04:38:14.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/java-处理-xml-的三种主流技术及介绍/">Java 处理 XML 的三种主流技术及介绍</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>XML (Extensible Markup Language) 意为可扩展标记语言，它已经是软件开发行业中大多数程序员和厂商用以选择作为数据传输的载体。本文作者对于 Java 处理 XML 的几种主流技术进行一些总结和介绍，希望帮助那些有不同需求的开发人员对于 XML 处理技术的作出最优的选择。</p>
<p>最初，XML 语言仅仅是意图用来作为 HTML 语言的替代品而出现的，但是随着该语言的不断发展和完善，人们越来越发现它所具有的优点：例如标记语言可扩展，严格的语法规定，可使用有意义的标记，内容 存储和表现分离等等优势注定了该语言从诞生之日起就会走向辉煌。 XML 语言在成为 W3C 标准之后进入到了一个快速发展的时期，当然它本身所具有的一系列优点和优势也注定了各大技术厂商对它的偏爱，Java 作为软件行业的一种开发技术也迅速作出了反应，出现了多种对 XML 支持的工具，本文将会从这个角度对 Java 处理 XML 的几种主流技术进行介绍，希望能对您有所帮助。在这篇文章中，您将会得到以下信息：</p>
<ol>
<li>Java 提供了哪些优秀的类库及工具便于程序员对 XML 进行处理 ?</li>
<li>有了 DOM 了，其它工具类库还有必要么 ?</li>
<li>几个小例程带你快速了解这三种解析方式</li>
</ol>
<p>Java 有哪些优秀的类库及工具便于程序员对 XML 进行处理 ?</p>
<ul>
<li>大名鼎鼎的 DOM</li>
<li>绿色环保的 SAX</li>
<li>默默无闻的 Digester</li>
</ul>
<h1 id="XML_三种解析方式简介">XML 三种解析方式简介</h1>
<p>大名鼎鼎的 DOM</p>
<p>说它大名鼎鼎可是一点不为过，DOM 是 W3C 处理 XML 的标准 API，它是许多其它与 XML 处理相关的标准的基础，不仅是 Java，其它诸如 Javascript，PHP，MS .NET 等等语言都实现了该标准， 成为了应用最为广泛的 XML 处理方式。当然，为了能提供更多更加强大的功能，Java 对于 DOM 直接扩展工具类有很多，比如很多 Java 程序员耳熟能详的 JDOM，DOM4J 等等， 它们基本上属于对 DOM 接口功能的扩充，保留了很多 DOM API 的特性，许多原本的 DOM 程序员甚至都没有任何障碍就熟练掌握了另外两者的使用，直观、易于操作的方式使它深受广大 Java 程序员的喜爱。</p>
<p>绿色环保的 SAX</p>
<p>SAX 的应运而生有它特殊的需要，为什么说它绿色环保呢，这是因为 SAX 使用了最少的系统资源和最快速的解析方式对 XML 处理提供了支持。 但随之而来繁琐的查找方式也给广大程序员带来许多困扰，常常令人头痛不已，同时它对 XPath 查询功能的支持，令人们对它又爱又恨。</p>
<p>默默无闻的 Digester：XML 的 JavaBean 化</p>
<p>Digester 是 apache 基金组织下的一个开源项目，笔者对它的了解源于对 Struts 框架的研究，是否有很多程序员想要一解各大开源框架的设计甚至想要自己写一个功能强大的框架时会碰到这样一个难题： 这些形形色色的用 XML 语言标记的框架配置文件，框架底层是用什么技术来解析呢？ DOM 解析耗费时间，SAX 解析又过于繁琐，况且每次解析系统开销也会过大， 于是，大家想到需要用与 XML 结构相对应的 JavaBean 来装载这些信息，由此 Digester 应运而生。它的出现为 XML 转换为 JavaBean 对象的需求带来了方便的操作接口，使得更多的类似需求得到了比较完美的解决方法， 不再需要程序员自己实现此类繁琐的解析程序了。与此同时 SUN 也推出了 XML 和 JavaBean 转换工具类 JAXB，有兴趣的读者可以自行了解。</p>
<h1 id="三种解析方式比较">三种解析方式比较</h1>
<p>DOM</p>
<p>优缺点：实现 W3C 标准，有多种编程语言支持这种解析方式，并且这种方法本身操作上简单快捷，十分易于初学者掌握。其处理方式是将 XML 整个作为类似树结构的方式读入内存中以便操作及解析，因此支持应用程序对 XML 数据的内容和结构进行修改，但是同时由于其需要在处理开始时将整个 XML 文件读入到内存中去进行分析，因此其在解析大数据量的 XML 文件时会遇到类似于内存泄露以及程序崩溃的风险，请对这点多加注意。</p>
<p>适用范围：小型 XML 文件解析、需要全解析或者大部分解析 XML、需要修改 XML 树内容以生成自己的对象模型</p>
<p>SAX</p>
<p>SAX 从根本上解决了 DOM 在解析 XML 文档时产生的占用大量资源的问题。其实现是通过类似于流解析的技术，通读整个 XML 文档树，通过事件处理器来响应程序员对于 XML 数据解析的需求。由于其不需要将整个 XML 文档读入内存当中，它对系统资源的节省是十分显而易见的，它在一些需要处理大型 XML 文档以及性能要求较高的场合有起了十分重要的作用。支持 XPath 查询的 SAX 使得开发人员更加灵活，处理起 XML 来更加的得心应手。但是同时，其仍然有一些不足之处也困扰广大的开发人员：首先是它十分复杂的 API 接口令人望而生畏，其次由于其是属于类似流解析的文件扫描方式，因此不支持应用程序对于 XML 树内容结构等的修改，可能会有不便之处。</p>
<p>适用范围：大型 XML 文件解析、只需要部分解析或者只想取得部分 XML 树内容、有 XPath 查询需求、有自己生成特定 XML 树对象模型的需求</p>
<p>Digester/JAXB</p>
<p>优缺点 : 由于其是在上述两者的基础上衍生出来的工具类，为的是满足将 XML 转换为 JavaBean 的特殊需求，故而没有什么特别明显的优缺点。作为大名鼎鼎的开源框架 Struts 的 XML 解析工具 Digester，为我们带来了将 XML 转换为 JavaBean 的可靠方法。</p>
<p>适用范围 : 有将 XML 文档直接转换为 JavaBean 需求。</p>
<p>应用示例</p>
<p>下面给出一段用于解析的 XML 片段：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> 
 <span class="tag">&lt;<span class="title">books</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">book</span> <span class="attribute">id</span>=<span class="value">"001"</span>&gt;</span> 
      <span class="tag">&lt;<span class="title">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="title">title</span>&gt;</span> 
      <span class="tag">&lt;<span class="title">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="title">author</span>&gt;</span> 
   <span class="tag">&lt;/<span class="title">book</span>&gt;</span> 
   <span class="tag">&lt;<span class="title">book</span> <span class="attribute">id</span>=<span class="value">"002"</span>&gt;</span> 
      <span class="tag">&lt;<span class="title">title</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="title">title</span>&gt;</span> 
      <span class="tag">&lt;<span class="title">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="title">author</span>&gt;</span> 
   <span class="tag">&lt;/<span class="title">book</span>&gt;</span> 
 <span class="tag">&lt;/<span class="title">books</span>&gt;</span> 
</code></pre><h1 id="DOM_解析_XML">DOM 解析 XML</h1>
<p>Java 中的 DOM 接口简介： JDK 中的 DOM API 遵循 W3C DOM 规范，其中 org.w3c.dom 包提供了 Document、DocumentType、Node、NodeList、Element 等接口， 这些接口均是访问 DOM 文档所必须的。我们可以利用这些接口创建、遍历、修改 DOM 文档。</p>
<p>javax.xml.parsers 包中的 DoumentBuilder 和 DocumentBuilderFactory 用于解析 XML 文档生成对应的 DOM Document 对象。</p>
<p>javax.xml.transform.dom 和 javax.xml.transform.stream 包中 DOMSource 类和 StreamSource 类，用于将更新后的 DOM 文档写入 XML 文件。</p>
<p>下面给出一个运用 DOM 解析 XML 的例子：</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> java.io.File;</span> 
 <span class="preprocessor"><span class="keyword">import</span> java.io.IOException;</span> 
 <span class="preprocessor"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span> 
 <span class="preprocessor"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span> 
 <span class="preprocessor"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span> 
 <span class="preprocessor"><span class="keyword">import</span> org.w3c.dom.Document;</span> 
 <span class="preprocessor"><span class="keyword">import</span> org.w3c.dom.Element;</span> 
 <span class="preprocessor"><span class="keyword">import</span> org.w3c.dom.Node;</span> 
 <span class="preprocessor"><span class="keyword">import</span> org.w3c.dom.NodeList;</span> 
 <span class="preprocessor"><span class="keyword">import</span> org.xml.sax.SAXException;</span> 

 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMParser</span> {</span> 
   DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); 
   <span class="comment">//Load and parse XML file into DOM </span>
   <span class="keyword">public</span> Document parse(String filePath) { 
      Document document = <span class="literal">null</span>; 
      <span class="keyword">try</span> { 
         <span class="comment">//DOM parser instance </span>
         DocumentBuilder builder = builderFactory.newDocumentBuilder(); 
         <span class="comment">//parse an XML file into a DOM tree </span>
         document = builder.parse(<span class="keyword">new</span> File(filePath)); 
      } <span class="keyword">catch</span> (ParserConfigurationException e) { 
         e.printStackTrace();  
      } <span class="keyword">catch</span> (SAXException e) { 
         e.printStackTrace(); 
      } <span class="keyword">catch</span> (IOException e) { 
         e.printStackTrace(); 
      } 
      <span class="keyword">return</span> document; 
   } 

   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) { 
         DOMParser parser = <span class="keyword">new</span> DOMParser(); 
         Document document = parser.parse(<span class="string">"books.xml"</span>); 
         <span class="comment">//get root element </span>
         Element rootElement = document.getDocumentElement(); 

         <span class="comment">//traverse child elements </span>
         NodeList nodes = rootElement.getChildNodes(); 
         <span class="keyword">for</span> (int i=<span class="number">0</span>; i &lt; nodes.getLength(); i++) 
         { 
            Node node = nodes.item(i); 
            <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) {   
               Element child = (Element) node; 
               <span class="comment">//process child element </span>
            } 
         } 

         NodeList nodeList = rootElement.getElementsByTagName(<span class="string">"book"</span>); 
         <span class="keyword">if</span>(nodeList != <span class="literal">null</span>) 
         { 
            <span class="keyword">for</span> (int i = <span class="number">0</span> ; i &lt; nodeList.getLength(); i++) 
            {
                Element element = (Element)nodeList.item(i); 
                String id = element.getAttribute(<span class="string">"id"</span>); 
            } 
         } 
   } 
 } 
</code></pre><p>在上面的例子中，DOMParser 的 Parse() 方法负责解析 XML 文件并生成对应的 DOM Document 对象。其中 DocumentBuilderFactory 用于生成 DOM 文档解析器以便解析 XML 文档。 在获取了 XML 文件对应的 Document 对象之后，我们可以调用一系列的 API 方便的对文档对象模型中的元素进行访问和处理。 需要注意的是调用 Element 对象的 getChildNodes() 方法时将返回其下所有的子节点，其中包括空白节点，因此需要在处理子 Element 之前对节点类型加以判断。</p>
<p>可以看出 DOM 解析 XML 易于开发，只需要通过解析器建立起 XML 对应的 DOM 树型结构后便可以方便的使用 API 对节点进行访问和处理，支持节点的删除和修改等。 但是 DOM 解析 XML 文件时会将整个 XML 文件的内容解析成树型结构存放在内存中，因此不适合用 DOM 解析很大的 XML 文件。</p>
<h1 id="SAX_解析_XML">SAX 解析 XML</h1>
<p>与 DOM 建立树形结构的方式不同，SAX 采用事件模型来解析 XML 文档，是解析 XML 文档的一种更快速、更轻量的方法。 利用 SAX 可以对 XML 文档进行有选择的解析和访问，而不必像 DOM 那样加载整个文档，因此它对内存的要求较低。 但 SAX 对 XML 文档的解析为一次性读取，不创建任何文档对象，很难同时访问文档中的多处数据。</p>
<p>下面是一个 SAX 解析 XML 的例子：</p>
<pre><code><span class="keyword">import</span> org.xml.sax.Attributes; 
 <span class="keyword">import</span> org.xml.sax.SAXException; 
 <span class="keyword">import</span> org.xml.sax.XMLReader; 
 <span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler; 
 <span class="keyword">import</span> org.xml.sax.helpers.XMLReaderFactory; 

 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SAXParser</span> {</span> 

   class BookHandler extends DefaultHandler { 
      <span class="keyword">private</span> List&lt;String&gt; nameList; 
      <span class="keyword">private</span> <span class="keyword">boolean</span> title = <span class="keyword">false</span>; 

      <span class="keyword">public</span> List&lt;String&gt; <span class="title">getNameList</span>() { 
        <span class="keyword">return</span> nameList; 
      } 
      <span class="comment">// Called at start of an XML document </span>
      <span class="annotation">@Override</span> 
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span>() <span class="keyword">throws</span> SAXException { 
         System.out.println(<span class="string">"Start parsing document..."</span>); 
         nameList = <span class="keyword">new</span> ArrayList&lt;String&gt;(); 
      } 
      <span class="comment">// Called at end of an XML document </span>
      <span class="annotation">@Override</span> 
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span>() <span class="keyword">throws</span> SAXException {  
         System.out.println(<span class="string">"End"</span>);  
      } 

      <span class="javadoc">/** 
       * Start processing of an element. 
       *<span class="javadoctag"> @param</span> namespaceURI  Namespace URI 
       *<span class="javadoctag"> @param</span> localName  The local name, without prefix 
       *<span class="javadoctag"> @param</span> qName  The qualified name, with prefix 
       *<span class="javadoctag"> @param</span> atts  The attributes of the element 
       */</span> 
      <span class="annotation">@Override</span> 
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span>(String uri, String localName, String qName, 
         Attributes atts) <span class="keyword">throws</span> SAXException { 
         <span class="comment">// Using qualified name because we are not using xmlns prefixes here. </span>
         <span class="keyword">if</span> (qName.equals(<span class="string">"title"</span>)) { 
            title = <span class="keyword">true</span>; 
         } 
      } 

      <span class="annotation">@Override</span> 
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span>(String namespaceURI, String localName, String qName) 
           <span class="keyword">throws</span> SAXException { 
         <span class="comment">// End of processing current element </span>
         <span class="keyword">if</span> (title) { 
            title = <span class="keyword">false</span>; 
         } 
      } 

      <span class="annotation">@Override</span> 
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span>(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length) { 
         <span class="comment">// Processing character data inside an element </span>
         <span class="keyword">if</span> (title) { 
            String bookTitle = <span class="keyword">new</span> String(ch, start, length); 
            System.out.println(<span class="string">"Book title: "</span> + bookTitle); 
            nameList.add(bookTitle); 
         } 
      }             
   } 

   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> SAXException, IOException { 
      XMLReader parser = XMLReaderFactory.createXMLReader(); 
      BookHandler bookHandler = (<span class="keyword">new</span> SAXParser()).<span class="keyword">new</span> BookHandler(); 
      parser.setContentHandler(bookHandler); 
      parser.parse(<span class="string">"books.xml"</span>); 
      System.out.println(bookHandler.getNameList()); 
   } 
 } 
</code></pre><p>SAX 解析器接口和事件处理器接口定义在 org.xml.sax 包中。主要的接口包括 ContentHandler、DTDHandler、EntityResolver 及 ErrorHandler。 其中 ContentHandler 是主要的处理器接口，用于处理基本的文档解析事件；DTDHandler 和 EntityResolver 接口用于处理与 DTD 验证和实体解析相关的事件； ErrorHandler 是基本的错误处理接口。DefaultHandler 类实现了上述四个事件处理接口。上面的例子中 BookHandler 继承了 DefaultHandler 类， 并覆盖了其中的五个回调方法 startDocument()、endDocument()、startElement()、endElement() 及 characters() 以加入自己的事件处理逻辑。</p>
<h1 id="Digester_解析_XML">Digester 解析 XML</h1>
<p>为了满足将 XML 转换为 JavaBean 的特殊需求，Apache 旗下的一个名为 Digester 的工具为我们提供了这么一个选择。由于最终是将 XML 转化为 JavaBean 存储在内存当中， 故而解析性能等方面其实与使用者并没有多大关系。解析的关键在于用以匹配 XML 的模式以及规则等，由于该工具较为复杂，限于篇幅，作者只能给予简单的介绍。</p>
<p>下面是一个 Digester 解析 XML 的例子片段：</p>
<pre><code>// 定义要解析的 XML 的路径，并初始化工具类
File input = new File(<span class="string">"books.xml"</span>)<span class="comment">; </span>
Digester digester = new Digester()<span class="comment">; </span>

// 如果碰到了 &lt;books&gt; 这个标签，应该初始化 test<span class="preprocessor">.myBean</span><span class="preprocessor">.Books</span> 这个 JavaBean 并填装相关内容
digester<span class="preprocessor">.addObjectCreate</span>(<span class="string">"books"</span>, <span class="string">"test.myBean.Books"</span>)<span class="comment">; </span>
digester<span class="preprocessor">.addSetProperties</span>(<span class="string">"books"</span>)<span class="comment">; </span>
// 如果碰到了 &lt;books/book&gt; 这个标签，同上初始化 test<span class="preprocessor">.myBean</span><span class="preprocessor">.Book</span> 这个 JavaBean 
digester<span class="preprocessor">.addObjectCreate</span>(<span class="string">"books/book"</span>, <span class="string">"test.myBean.Book"</span>)<span class="comment">; </span>
digester<span class="preprocessor">.addSetProperties</span>(<span class="string">"books/book"</span>)<span class="comment">; </span>
// 通过调用上面已经初始化过的 JavaBean 的 addBook() 方法来把多个 &lt;books/book&gt; 加到一个集合中
digester<span class="preprocessor">.addSetNext</span>(<span class="string">"books/book"</span>, <span class="string">"addBook"</span>, <span class="string">"test.myBean.Book"</span>)<span class="comment">; </span>

// 定义好了上面的解析规则后，就可以开始进行解析工作了
Books books = (Books) digester<span class="preprocessor">.parse</span>(input)<span class="comment">; </span>
</code></pre><p>上述代码简单的向读者展示了 Digester 处理 XML 的一些要点，主要是说明了一些模式以及规则的匹配。 简言之，Digester 就是一种用来把一个 XML 转化为一个与该 XML 结构类似的 JavaBean。你可以把 XML 根元素想象成一个 JavaBean， 该根元素的 attribute 就是这个 JavaBean 的各种 Field，当该根元素有其他子 tag 时，又要把这个子 tag 想象成一个个新的 XML，将其视为一个新的 JavaBean， 并作为一个 Field 加入到父 Bean 当中，然后以此类推，通过循环的方式将整个 XML 进行解析。</p>
<h1 id="结束语">结束语</h1>
<p>本文介绍了 Java 解析 XML 的三种常用技术，其中 DOM 易于上手，程序易于理解，但缺点在于占用内存大，不适合于解析较大的 XML 文件； SAX 基于事件模型占用系统资源少，能够胜任较大的 XML 文件解析，但解析过程较为繁琐查找元素不方便； Digester/JAXB 基于上述两种技术衍生而来。文中的实例向读者展示了三种 API 的基本使用方法， 在实际开发过程中使用那种技术解析 XML 更好要依据各自的优缺点视具体情况而定。<br>原文出处：<a href="http://www.ibm.com/developerworks/cn/xml/dm-1208gub/index.html" target="_blank">IBM developerWorks</a> </p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
    <a href="/archives/2014/" class="prev">上一页</a>
  
  
    <a href="/archives/2014/page/3/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2014 <a href="/">Xin Zhang</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>