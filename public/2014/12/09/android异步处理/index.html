<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Android异步处理 | 挖之家</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Xin Zhang">
  
  
    <meta name="description" content="Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面
概述：每个Android应用程序都运行在一个dalvik虚拟机进程中，进程开始的时候会启动一个主线程(MainThread)，主线程负责处理和ui相关的事件，因此主线程通常又叫UI线程。而由于Android采用UI单线程模型，所以只能在主线程中对UI元素进行操作。如果在非UI线程直接对UI进行了操作，则会报错：">
  
  <meta content="article" property="og:type">
<meta content="Android异步处理" property="og:title">
<meta content="http://waakaakaa.github.io/2014/12/09/android异步处理/" property="og:url">
<meta content="/img/Android异步处理/1.jpg" property="og:image">
<meta content="挖之家" property="og:site_name">
<meta content="Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面
概述：每个Android应用程序都运行在一个dalvik虚拟机进程中，进程开始的时候会启动一个主线程(MainThread)，主线程负责处理和ui相关的事件，因此主线程通常又叫UI线程。而由于Android采用UI单线程模型，所以只能在主线程中对UI元素进行操作。如果在非UI线程直接对UI进行了操作，则会报错：" property="og:description">
<meta content="summary" name="twitter:card">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">挖之家</a></h1>
    <p><a href="/">太阳每天都是欣的</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/12/09/android异步处理/">
  <time datetime="2014-12-08T17:09:30.000Z">
    12月 9 2014
  </time>
</a>
    
    
  
    <h1 class="title">Android异步处理</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面">Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面</h1>
<p>概述：每个Android应用程序都运行在一个dalvik虚拟机进程中，进程开始的时候会启动一个主线程(MainThread)，主线程负责处理和ui相关的事件，因此主线程通常又叫UI线程。而由于Android采用UI单线程模型，所以只能在主线程中对UI元素进行操作。如果在非UI线程直接对UI进行了操作，则会报错：</p>
<a id="more"></a>

<p>CalledFromWrongThreadException:only the original thread that created a view hierarchy can touch its views<br>。<br>Android为我们提供了消息循环的机制，我们可以利用这个机制来实现线程间的通信。那么，我们就可以在非UI线程发送消息到UI线程，最终让Ui线程来进行ui的操作。</p>
<p>对于运算量较大的操作和IO操作，我们需要新开线程来处理这些繁重的工作，以免阻塞ui线程。</p>
<p>例子：下面我们以获取CSDN logo的例子，演示如何使用Thread+Handler的方式实现在非UI线程发送消息通知UI线程更新界面。</p>
<p>ThradHandlerActivity.java:</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadHandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> {</span>
    <span class="javadoc">/** Called when the activity is first created. */</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SUCCESS = <span class="number">0</span>;<span class="comment">//获取图片成功的标识</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_FAILURE = <span class="number">1</span>;<span class="comment">//获取图片失败的标识</span>

    <span class="keyword">private</span> ImageView mImageView;
    <span class="keyword">private</span> Button mButton;

    <span class="keyword">private</span> Thread mThread;

    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() {
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> (Message msg) {<span class="comment">//此方法在ui线程运行</span>
            <span class="keyword">switch</span>(msg.what) {
            <span class="keyword">case</span> MSG_SUCCESS:
                mImageView.setImageBitmap((Bitmap) msg.obj);<span class="comment">//imageview显示从网络获取到的logo</span>
                Toast.makeText(getApplication(), getApplication().getString(R.string.get_pic_success), Toast.LENGTH_LONG).show();
                <span class="keyword">break</span>;

            <span class="keyword">case</span> MSG_FAILURE:
                Toast.makeText(getApplication(), getApplication().getString(R.string.get_pic_failure), Toast.LENGTH_LONG).show();
                <span class="keyword">break</span>;
            }
        }
    };

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        mImageView= (ImageView) findViewById(R.id.imageView);<span class="comment">//显示图片的ImageView</span>
        mButton = (Button) findViewById(R.id.button);
        mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(View v) {
                <span class="keyword">if</span>(mThread == <span class="keyword">null</span>) {
                    mThread = <span class="keyword">new</span> Thread(runnable);
                    mThread.start();<span class="comment">//线程启动</span>
                }
                <span class="keyword">else</span> {
                    Toast.makeText(getApplication(), getApplication().getString(R.string.thread_started), Toast.LENGTH_LONG).show();
                }
            }
        });
    }

    Runnable runnable = <span class="keyword">new</span> Runnable() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {<span class="comment">//run()在新的线程中运行</span>
            HttpClient hc = <span class="keyword">new</span> DefaultHttpClient();
            HttpGet hg = <span class="keyword">new</span> HttpGet(<span class="string">"http://csdnimg.cn/www/images/csdnindex_logo.gif"</span>);<span class="comment">//获取csdn的logo</span>
            <span class="keyword">final</span> Bitmap bm;
            <span class="keyword">try</span> {
                HttpResponse hr = hc.execute(hg);
                bm = BitmapFactory.decodeStream(hr.getEntity().getContent());
            } <span class="keyword">catch</span> (Exception e) {
                mHandler.obtainMessage(MSG_FAILURE).sendToTarget();<span class="comment">//获取图片失败</span>
                <span class="keyword">return</span>;
            }
            mHandler.obtainMessage(MSG_SUCCESS,bm).sendToTarget();<span class="comment">//获取图片成功，向ui线程发送MSG_SUCCESS标识和bitmap对象</span>

<span class="comment">//            mImageView.setImageBitmap(bm); //出错！不能在非ui线程操作ui元素</span>

<span class="comment">//            mImageView.post(new Runnable() {//另外一种更简洁的发送消息给ui线程的方法。</span>
<span class="comment">//                </span>
<span class="comment">//                @Override</span>
<span class="comment">//                public void run() {//run()方法会在ui线程执行</span>
<span class="comment">//                    mImageView.setImageBitmap(bm);</span>
<span class="comment">//                }</span>
<span class="comment">//            });</span>
        }
    };

}
</code></pre><p>main.xml布局文件：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span> <span class="attribute">android:text</span>=<span class="value">"@string/button_name"</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span><span class="tag">&lt;/<span class="title">Button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ImageView</span> <span class="attribute">android:id</span>=<span class="value">"@+id/imageView"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>strings.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span> <span class="attribute">android:text</span>=<span class="value">"@string/button_name"</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span><span class="tag">&lt;/<span class="title">Button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ImageView</span> <span class="attribute">android:id</span>=<span class="value">"@+id/imageView"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>Manifest.xml:</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.zhuozhuo"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"9"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>&gt;</span><span class="tag">&lt;/<span class="title">uses-permission</span>&gt;</span><span class="comment">&lt;!--不要忘记设置网络访问权限--&gt;</span>

    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".ThreadHandlerActivity"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>运行结果：</p>
<p><img src="/img/Android异步处理/1.jpg" alt="image"></p>
<p>为了不阻塞ui线程，我们使用mThread从网络获取了CSDN的LOGO ，并用bitmap对象存储了这个Logo的像素信息。<br>此时，如果在这个线程的run()方法中调用</p>
<pre><code>mImageView<span class="preprocessor">.setImageBitmap</span>(bm)  
</code></pre><p>会出现：CalledFromWrongThreadException:only the original thread that created a view hierarchy can touch its views。原因是run()方法是在新开的线程中执行的，我们上面提到不能直接在非ui线程中操作ui元素。</p>
<p>非UI线程发送消息到UI线程分为两个步骤</p>
<p>一、发送消息到UI线程的消息队列</p>
<p>通过使用Handler的</p>
<pre><code><span class="keyword">Message</span> obtainMessage(int what,<span class="keyword">Object</span> <span class="keyword">object</span>)  
</code></pre><p>构造一个Message对象，这个对象存储了是否成功获取图片的标识what和bitmap对象，然后通过message.sendToTarget()方法把这条message放到消息队列中去。</p>
<p>二、处理发送到UI线程的消息</p>
<p>在ui线程中，我们覆盖了handler的 </p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> (Message msg)   
</code></pre><p>这个方法是处理分发给ui线程的消息，判断msg.what的值可以知道mThread是否成功获取图片，如果图片成功获取，那么可以通过msg.obj获取到这个对象。</p>
<p>最后，我们通过</p>
<pre><code>mImageView<span class="preprocessor">.setImageBitmap</span>((Bitmap) msg<span class="preprocessor">.obj</span>)<span class="comment">;  </span>
</code></pre><p>设置ImageView的bitmap对象，完成UI的更新。</p>
<p>补充：</p>
<p>事实上，我们还可以调用View的post方法来更新ui</p>
<pre><code>mImageView.post(<span class="keyword">new</span> Runnable() {<span class="comment">//另外一种更简洁的发送消息给ui线程的方法。</span>

                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {<span class="comment">//run()方法会在ui线程执行</span>
                    mImageView.setImageBitmap(bm);
                }
            });
</code></pre><p>这种方法会把Runnable对象发送到消息队列，ui线程接收到消息后会执行这个runnable对象。</p>
<p>从例子中我们可以看到handler既有发送消息和处理消息的作用，会误以为handler实现了消息循环和消息分发，其实Android为了让我们的代码看起来更加简洁，与UI线程的交互只需要使用在UI线程创建的handler对象就可以了。如需深入学习，了解消息循环机制的具体实现，请关注《Android异步处理三：Handler+Looper+MessageQueue深入详解》</p>
<p>===</p>
<h1 id="Android异步处理二：使用AsyncTask异步更新UI界面">Android异步处理二：使用AsyncTask异步更新UI界面</h1>
<p>概述： AsyncTask是在Android SDK 1.5之后推出的一个方便编写后台线程与UI线程交互的辅助类。AsyncTask的内部实现是一个线程池，每个后台任务会提交到线程池中的线程执行，然后使用Thread+Handler的方式调用回调函数（如需深入了解原理请看《Android异步处理四：AsyncTask的实现原理》）。</p>
<p>AsyncTask抽象出后台线程运行的五个状态，分别是：1、准备运行，2、正在后台运行，3、进度更新，4、完成后台任务，5、取消任务，对于这五个阶段，AsyncTask提供了五个回调函数：</p>
<ol>
<li><p>准备运行：onPreExecute(),该回调函数在任务被执行之后立即由UI线程调用。这个步骤通常用来建立任务，在用户接口（UI）上显示进度条。</p>
</li>
<li><p>正在后台运行：doInBackground(Params…),该回调函数由后台线程在onPreExecute()方法执行结束后立即调用。通常在这里执行耗时的后台计算。计算的结果必须由该函数返回，并被传递到onPostExecute()中。在该函数内也可以使用publishProgress(Progress…)来发布一个或多个进度单位(unitsof progress)。这些值将会在onProgressUpdate(Progress…)中被发布到UI线程。</p>
</li>
<li><p>进度更新：onProgressUpdate(Progress…),该函数由UI线程在publishProgress(Progress…)方法调用完后被调用。一般用于动态地显示一个进度条。</p>
</li>
<li><p>完成后台任务：onPostExecute(Result),当后台计算结束后调用。后台计算的结果会被作为参数传递给这一函数。</p>
</li>
<li><p>取消任务：onCancelled ()，在调用AsyncTask的cancel()方法时调用</p>
</li>
</ol>
<p>AsyncTask的构造函数有三个模板参数：</p>
<ol>
<li><p>Params，传递给后台任务的参数类型。</p>
</li>
<li><p>Progress，后台计算执行过程中，进步单位（progress　units）的类型。（就是后台程序已经执行了百分之几了。）</p>
</li>
<li><p>Result， 后台执行返回的结果的类型。</p>
</li>
</ol>
<p>AsyncTask并不总是需要使用上面的全部3种类型。标识不使用的类型很简单，只需要使用Void类型即可。</p>
<p>例子：与《Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面》实现的例子相同，我们在后台下载CSDN的LOGO，下载完成后在UI界面上显示出来，并会模拟下载进度更新。</p>
<p>AsyncTaskActivity.java</p>
<pre><code><span class="keyword">package</span> com.zhuozhuo;


<span class="keyword">import</span> org.apache.http.HttpResponse;
<span class="keyword">import</span> org.apache.http.client.HttpClient;
<span class="keyword">import</span> org.apache.http.client.methods.HttpGet;
<span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpClient;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.graphics.Bitmap;
<span class="keyword">import</span> android.graphics.BitmapFactory;
<span class="keyword">import</span> android.os.AsyncTask;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.view.View.OnClickListener;
<span class="keyword">import</span> android.widget.Button;
<span class="keyword">import</span> android.widget.ImageView;
<span class="keyword">import</span> android.widget.ProgressBar;
<span class="keyword">import</span> android.widget.Toast;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> {</span>

    <span class="keyword">private</span> ImageView mImageView;
    <span class="keyword">private</span> Button mButton;
    <span class="keyword">private</span> ProgressBar mProgressBar;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        mImageView= (ImageView) findViewById(R.id.imageView);
        mButton = (Button) findViewById(R.id.button);
        mProgressBar = (ProgressBar) findViewById(R.id.progressBar);
        mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(View v) {
                GetCSDNLogoTask task = <span class="keyword">new</span> GetCSDNLogoTask();
                task.execute(<span class="string">"http://csdnimg.cn/www/images/csdnindex_logo.gif"</span>);
            }
        });
    }

    class GetCSDNLogoTask extends AsyncTask&lt;String,Integer,Bitmap&gt; {<span class="comment">//继承AsyncTask</span>

        <span class="annotation">@Override</span>
        <span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span>(String... params) {<span class="comment">//处理后台执行的任务，在后台线程执行</span>
            publishProgress(<span class="number">0</span>);<span class="comment">//将会调用onProgressUpdate(Integer... progress)方法</span>
            HttpClient hc = <span class="keyword">new</span> DefaultHttpClient();
            publishProgress(<span class="number">30</span>);
            HttpGet hg = <span class="keyword">new</span> HttpGet(params[<span class="number">0</span>]);<span class="comment">//获取csdn的logo</span>
            <span class="keyword">final</span> Bitmap bm;
            <span class="keyword">try</span> {
                HttpResponse hr = hc.execute(hg);
                bm = BitmapFactory.decodeStream(hr.getEntity().getContent());
            } <span class="keyword">catch</span> (Exception e) {

                <span class="keyword">return</span> <span class="keyword">null</span>;
            }
            publishProgress(<span class="number">100</span>);
            <span class="comment">//mImageView.setImageBitmap(result); 不能在后台线程操作ui</span>
            <span class="keyword">return</span> bm;
        }

        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span>(Integer... progress) {<span class="comment">//在调用publishProgress之后被调用，在ui线程执行</span>
            mProgressBar.setProgress(progress[<span class="number">0</span>]);<span class="comment">//更新进度条的进度</span>
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span>(Bitmap result) {<span class="comment">//后台任务执行完之后被调用，在ui线程执行</span>
             <span class="keyword">if</span>(result != <span class="keyword">null</span>) {
                 Toast.makeText(AsyncTaskActivity.<span class="keyword">this</span>, <span class="string">"成功获取图片"</span>, Toast.LENGTH_LONG).show();
                 mImageView.setImageBitmap(result);
             }<span class="keyword">else</span> {
                 Toast.makeText(AsyncTaskActivity.<span class="keyword">this</span>, <span class="string">"获取图片失败"</span>, Toast.LENGTH_LONG).show();
             }
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span> () {<span class="comment">//在 doInBackground(Params...)之前被调用，在ui线程执行</span>
             mImageView.setImageBitmap(<span class="keyword">null</span>);
             mProgressBar.setProgress(<span class="number">0</span>);<span class="comment">//进度条复位</span>
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span> () {<span class="comment">//在ui线程执行</span>
             mProgressBar.setProgress(<span class="number">0</span>);<span class="comment">//进度条复位</span>
         }

    }


}
</code></pre><p>main.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ProgressBar</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:id</span>=<span class="value">"@+id/progressBar"</span> <span class="attribute">style</span>=<span class="value">"?android:attr/progressBarStyleHorizontal"</span>&gt;</span><span class="tag">&lt;/<span class="title">ProgressBar</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span> <span class="attribute">android:text</span>=<span class="value">"下载图片"</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span><span class="tag">&lt;/<span class="title">Button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ImageView</span> <span class="attribute">android:id</span>=<span class="value">"@+id/imageView"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>manifest.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.zhuozhuo"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"10"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>&gt;</span><span class="tag">&lt;/<span class="title">uses-permission</span>&gt;</span>
    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".AsyncTaskActivity"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>运行结果：</p>
<p><img src="/img/Android异步处理/2.jpg" alt="image"></p>
<p>流程说明：</p>
<ol>
<li><p>当点击按钮时，创建一个task，并且传入CSDN的LOGO地址（String类型参数，因此AsyncTask的第一个模板参数为String类型）</p>
</li>
<li><p>UI线程执行onPreExecute()，把ImageView的图片清空，progrssbar的进度清零。</p>
</li>
<li><p>后台线程执行doInBackground()，不可以在doInBackground()操作ui，调用publishProgress(0)更新进度，此时会调用onProgressUpdate(Integer…progress)更新进度条（进度用整形表示，因此AsyncTask的第二个模板参数是Integer）。函数最后返回result（例子中是返回Bitmap类型，因此AsyncTask的第三个模板参数是Bitmap）。</p>
</li>
<li><p>当后台任务执行完成后，调用onPostExecute(Result)，传入的参数是doInBackground()中返回的对象。</p>
</li>
</ol>
<p>总结：</p>
<p>AsyncTask为我们抽象出一个后台任务的五种状态，对应了五个回调接口，我们只需要根据不同的需求实现这五个接口（doInBackground是必须要实现的），就能完成一些简单的后台任务。使用AsyncTask的方式使编写后台进程和UI进程交互的代码变得更为简洁，使用起来更加方便，但是，AsyncTask也有一些缺憾，我们留到以后再讲。</p>
<p>===</p>
<h1 id="Android异步处理三：Handler+Looper+MessageQueue深入详解">Android异步处理三：Handler+Looper+MessageQueue深入详解</h1>
<p>概述：Android使用消息机制实现线程间的通信，线程通过Looper建立自己的消息循环，MessageQueue是FIFO的消息队列，Looper负责从MessageQueue中取出消息，并且分发到消息指定目标Handler对象。Handler对象绑定到线程的局部变量Looper，封装了发送消息和处理消息的接口。</p>
<p>例子：在介绍原理之前，我们先介绍Android线程通讯的一个例子，这个例子实现点击按钮之后从主线程发送消息”hello”到另外一个名为” CustomThread”的线程。</p>
<p>LooperThreadActivity.java</p>
<pre><code><span class="keyword">package</span> com.zhuozhuo;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.os.Handler;
<span class="keyword">import</span> android.os.Looper;
<span class="keyword">import</span> android.os.Message;
<span class="keyword">import</span> android.util.Log;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.view.View.OnClickListener;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LooperThreadActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span>{</span>
    <span class="javadoc">/** Called when the activity is first created. */</span>

    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_HELLO = <span class="number">0</span>;
    <span class="keyword">private</span> Handler mHandler;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        <span class="keyword">new</span> CustomThread().start();<span class="comment">//新建并启动CustomThread实例</span>

        findViewById(R.id.send_btn).setOnClickListener(<span class="keyword">new</span> OnClickListener() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(View v) {<span class="comment">//点击界面时发送消息</span>
                String str = <span class="string">"hello"</span>;
                Log.d(<span class="string">"Test"</span>, <span class="string">"MainThread is ready to send msg:"</span> + str);
                mHandler.obtainMessage(MSG_HELLO, str).sendToTarget();<span class="comment">//发送消息到CustomThread实例</span>

            }
        });

    }





    class CustomThread extends Thread {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            <span class="comment">//建立消息循环的步骤</span>
            Looper.prepare();<span class="comment">//1、初始化Looper</span>
            mHandler = <span class="keyword">new</span> Handler(){<span class="comment">//2、绑定handler到CustomThread实例的Looper对象</span>
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> (Message msg) {<span class="comment">//3、定义处理消息的方法</span>
                    <span class="keyword">switch</span>(msg.what) {
                    <span class="keyword">case</span> MSG_HELLO:
                        Log.d(<span class="string">"Test"</span>, <span class="string">"CustomThread receive msg:"</span> + (String) msg.obj);
                    }
                }
            };
            Looper.loop();<span class="comment">//4、启动消息循环</span>
        }
    }
}
</code></pre><p>main.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">TextView</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> 
    <span class="attribute">android:text</span>=<span class="value">"@string/hello"</span>
    /&gt;</span>
<span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:text</span>=<span class="value">"发送消息"</span> <span class="attribute">android:id</span>=<span class="value">"@+id/send_btn"</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span><span class="tag">&lt;/<span class="title">Button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>Log打印结果：</p>
<p><img src="/img/Android异步处理/3.png" alt="image"></p>
<p>原理：</p>
<p>我们看到，为一个线程建立消息循环有四个步骤：</p>
<ol>
<li><p>初始化Looper</p>
</li>
<li><p>绑定handler到CustomThread实例的Looper对象</p>
</li>
<li><p>定义处理消息的方法</p>
</li>
<li><p>启动消息循环</p>
</li>
</ol>
<p>下面我们以这个例子为线索，深入Android源代码，说明Android Framework是如何建立消息循环，并对消息进行分发的。</p>
<p>1、  初始化Looper : Looper.prepare()</p>
<p>Looper.java</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal sThreadLocal = <span class="keyword">new</span> ThreadLocal();
<span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">void</span> <span class="title">prepare</span>() {
        <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);
        }
        sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper());
}
</code></pre><p>一个线程在调用Looper的静态方法prepare()时，这个线程会新建一个Looper对象，并放入到线程的局部变量中，而这个变量是不和其他线程共享的（关于ThreadLocal的介绍）。下面我们看看Looper()这个构造函数：</p>
<p>Looper.java</p>
<pre><code><span class="keyword">final</span> MessageQueue mQueue;
<span class="keyword">private</span> <span class="title">Looper</span>() {
        mQueue = <span class="keyword">new</span> MessageQueue();
        mRun = <span class="keyword">true</span>;
        mThread = Thread.currentThread();
    }
</code></pre><p>可以看到在Looper的构造函数中，创建了一个消息队列对象mQueue，此时，调用Looper. prepare()的线程就建立起一个消息循环的对象（此时还没开始进行消息循环）。</p>
<p>2、  绑定handler到CustomThread实例的Looper对象 : mHandler= new Handler()</p>
<p>Handler.java</p>
<pre><code><span class="keyword">final</span> MessageQueue mQueue;
 <span class="keyword">final</span> Looper mLooper;
<span class="keyword">public</span> <span class="title">Handler</span>() {
        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {
            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();
            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) {
                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(
                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);
        }
        mQueue = mLooper.mQueue;
        mCallback = <span class="keyword">null</span>;
}
</code></pre><p>Handler通过mLooper = Looper.myLooper();绑定到线程的局部变量Looper上去，同时Handler通过mQueue =mLooper.mQueue;获得线程的消息队列。此时，Handler就绑定到创建此Handler对象的线程的消息队列上了。</p>
<p>3、定义处理消息的方法：Override public void handleMessage (Message msg){}<br>   子类需要覆盖这个方法，实现接受到消息后的处理方法。</p>
<p>4、启动消息循环 ： Looper.loop()</p>
<p>所有准备工作都准备好了，是时候启动消息循环了！Looper的静态方法loop()实现了消息循环。</p>
<p>Looper.java</p>
<pre><code> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span>() {
        Looper me = myLooper();
        MessageQueue queue = me.mQueue;

        <span class="comment">// Make sure the identity of this thread is that of the local process,</span>
        <span class="comment">// and keep track of what that identity token actually is.</span>
        Binder.clearCallingIdentity();
        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();

        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            Message msg = queue.next(); <span class="comment">// might block</span>
            <span class="comment">//if (!me.mRun) {</span>
            <span class="comment">//    break;</span>
            <span class="comment">//}</span>
            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {
                    <span class="comment">// No target is a magic identifier for the quit message.</span>
                    <span class="keyword">return</span>;
                }
                <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(
                        <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span>
                        + msg.callback + <span class="string">": "</span> + msg.what
                        );
                msg.target.dispatchMessage(msg);
                <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(
                        <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to    "</span> + msg.target + <span class="string">" "</span>
                        + msg.callback);

                <span class="comment">// Make sure that during the course of dispatching the</span>
                <span class="comment">// identity of the thread wasn't corrupted.</span>
                <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();
                <span class="keyword">if</span> (ident != newIdent) {
                    Log.wtf(<span class="string">"Looper"</span>, <span class="string">"Thread identity changed from 0x"</span>
                            + Long.toHexString(ident) + <span class="string">" to 0x"</span>
                            + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span>
                            + msg.target.getClass().getName() + <span class="string">" "</span>
                            + msg.callback + <span class="string">" what="</span> + msg.what);
                }

                msg.recycle();
            }
        }
    }
</code></pre><p>while(true)体现了消息循环中的“循环“，Looper会在循环体中调用queue.next()获取消息队列中需要处理的下一条消息。当msg != null且msg.target != null时，调用msg.target.dispatchMessage(msg);分发消息，当分发完成后，调用msg.recycle();回收消息。</p>
<p>msg.target是一个handler对象，表示需要处理这个消息的handler对象。Handler的void dispatchMessage(Message msg)方法如下：</p>
<p>Handler.java</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span>(Message msg) {
        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {
            handleCallback(msg);
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (mCallback.handleMessage(msg)) {
                    <span class="keyword">return</span>;
                }
            }
            handleMessage(msg);
        }
}
</code></pre><p>可见，当msg.callback== null 并且mCallback == null时，这个例子是由handleMessage(msg);处理消息，上面我们说到子类覆盖这个方法可以实现消息的具体处理过程。</p>
<p>总结：从上面的分析过程可知，消息循环的核心是Looper，Looper持有消息队列MessageQueue对象，一个线程可以把Looper设为该线程的局部变量，这就相当于这个线程建立了一个对应的消息队列。Handler的作用就是封装发送消息和处理消息的过程，让其他线程只需要操作Handler就可以发消息给创建Handler的线程。由此可以知道，在上一篇《Android异步处理一：使用Thread+Handler实现非UI线程更新UI界面》中，UI线程在创建的时候就建立了消息循环(在ActivityThread的public static final void main(String[] args)方法中实现)，因此我们可以在其他线程给UI线程的handler发送消息，达到更新UI的目的。</p>
<p>===</p>
<h1 id="Android异步处理四：AsyncTask的实现原理">Android异步处理四：AsyncTask的实现原理</h1>
<p>概述：AsyncTask的本质是一个线程池，所有提交的异步任务都会在这个线程池中的工作线程内执行，当工作线程需要跟UI线程交互时，工作线程会通过向在UI线程创建的Handler（原理见：《Android异步处理三：Handler+Looper+MessageQueue深入详解》）传递消息的方式，调用相关的回调函数，从而实现UI界面的更新。</p>
<p>例子：</p>
<p>本章还是以《Android异步处理二：使用AsyncTask异步更新UI界面》中的例子说明AsyncTask的实现原理。</p>
<p>这个例子是在后台下载CSDN的LOGO，下载完成后在UI界面上显示出来。</p>
<p>AsyncTask.java</p>
<pre><code><span class="keyword">package</span> com.zhuozhuo;

<span class="keyword">import</span> org.apache.http.HttpResponse;
<span class="keyword">import</span> org.apache.http.client.HttpClient;
<span class="keyword">import</span> org.apache.http.client.methods.HttpGet;
<span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpClient;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.graphics.Bitmap;
<span class="keyword">import</span> android.graphics.BitmapFactory;
<span class="keyword">import</span> android.os.AsyncTask;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.view.View.OnClickListener;
<span class="keyword">import</span> android.widget.Button;
<span class="keyword">import</span> android.widget.ImageView;
<span class="keyword">import</span> android.widget.ProgressBar;
<span class="keyword">import</span> android.widget.Toast;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> {</span>

    <span class="keyword">private</span> ImageView mImageView;
    <span class="keyword">private</span> Button mButton;
    <span class="keyword">private</span> ProgressBar mProgressBar;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        mImageView= (ImageView) findViewById(R.id.imageView);
        mButton = (Button) findViewById(R.id.button);
        mProgressBar = (ProgressBar) findViewById(R.id.progressBar);
        mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(View v) {
                GetCSDNLogoTask task = <span class="keyword">new</span> GetCSDNLogoTask();
                task.execute(<span class="string">"http://csdnimg.cn/www/images/csdnindex_logo.gif"</span>);
            }
        });
    }

    class GetCSDNLogoTask extends AsyncTask&lt;String,Integer,Bitmap&gt; {<span class="comment">//继承AsyncTask</span>

        <span class="annotation">@Override</span>
        <span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span>(String... params) {<span class="comment">//处理后台执行的任务，在后台线程执行</span>
            publishProgress(<span class="number">0</span>);<span class="comment">//将会调用onProgressUpdate(Integer... progress)方法</span>
            HttpClient hc = <span class="keyword">new</span> DefaultHttpClient();
            publishProgress(<span class="number">30</span>);
            HttpGet hg = <span class="keyword">new</span> HttpGet(params[<span class="number">0</span>]);<span class="comment">//获取csdn的logo</span>
            <span class="keyword">final</span> Bitmap bm;
            <span class="keyword">try</span> {
                HttpResponse hr = hc.execute(hg);
                bm = BitmapFactory.decodeStream(hr.getEntity().getContent());
            } <span class="keyword">catch</span> (Exception e) {

                <span class="keyword">return</span> <span class="keyword">null</span>;
            }
            publishProgress(<span class="number">100</span>);
            <span class="comment">//mImageView.setImageBitmap(result); 不能在后台线程操作ui</span>
            <span class="keyword">return</span> bm;
        }

        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span>(Integer... progress) {<span class="comment">//在调用publishProgress之后被调用，在ui线程执行</span>
            mProgressBar.setProgress(progress[<span class="number">0</span>]);<span class="comment">//更新进度条的进度</span>
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span>(Bitmap result) {<span class="comment">//后台任务执行完之后被调用，在ui线程执行</span>
             <span class="keyword">if</span>(result != <span class="keyword">null</span>) {
                 Toast.makeText(AsyncTaskActivity.<span class="keyword">this</span>, <span class="string">"成功获取图片"</span>, Toast.LENGTH_LONG).show();
                 mImageView.setImageBitmap(result);
             }<span class="keyword">else</span> {
                 Toast.makeText(AsyncTaskActivity.<span class="keyword">this</span>, <span class="string">"获取图片失败"</span>, Toast.LENGTH_LONG).show();
             }
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span> () {<span class="comment">//在 doInBackground(Params...)之前被调用，在ui线程执行</span>
             mImageView.setImageBitmap(<span class="keyword">null</span>);
             mProgressBar.setProgress(<span class="number">0</span>);<span class="comment">//进度条复位</span>
         }

         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span> () {<span class="comment">//在ui线程执行</span>
             mProgressBar.setProgress(<span class="number">0</span>);<span class="comment">//进度条复位</span>
         }

    }


}
</code></pre><p>main.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ProgressBar</span> <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:id</span>=<span class="value">"@+id/progressBar"</span> <span class="attribute">style</span>=<span class="value">"?android:attr/progressBarStyleHorizontal"</span>&gt;</span><span class="tag">&lt;/<span class="title">ProgressBar</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span> <span class="attribute">android:text</span>=<span class="value">"下载图片"</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span><span class="tag">&lt;/<span class="title">Button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ImageView</span> <span class="attribute">android:id</span>=<span class="value">"@+id/imageView"</span> <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>mainifest.xml</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.zhuozhuo"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"10"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>&gt;</span><span class="tag">&lt;/<span class="title">uses-permission</span>&gt;</span>
    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".AsyncTaskActivity"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>运行结果：</p>
<p><img src="/img/Android异步处理/4.jpg" alt="image"></p>
<p>分析：</p>
<p>在分析实现流程之前，我们先了解一下AsyncTask有哪些成员变量。</p>
<pre><code>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE =<span class="number">5</span>;<span class="comment">//5个核心工作线程</span>
   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">128</span>;<span class="comment">//最多128个工作线程</span>
   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;<span class="comment">//空闲线程的超时时间为1秒</span>

   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sWorkQueue =
           <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>);<span class="comment">//等待队列</span>

   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutorsExecutor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,
           MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue,sThreadFactory);<span class="comment">//线程池是静态变量，所有的异步任务都会放到这个线程池的工作线程内执行。</span>
</code></pre><p>回到例子中，点击按钮之后会新建一个GetCSDNLogoTask对象：</p>
<pre><code><span class="attribute">GetCSDNLogoTask task </span>=<span class="string"> new GetCSDNLogoTask();</span>
</code></pre><p>此时会调用父类AsyncTask的构造函数：</p>
<p>AsyncTask.java</p>
<pre><code><span class="keyword">public</span> <span class="title">AsyncTask</span>() {
        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() {
            <span class="keyword">public</span> Result <span class="title">call</span>() <span class="keyword">throws</span> Exception {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                <span class="keyword">return</span> doInBackground(mParams);
            }
        };

        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) {
            <span class="annotation">@Override</span>
            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span>() {
                Message message;
                Result result = <span class="keyword">null</span>;

                <span class="keyword">try</span> {
                    result = get();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } <span class="keyword">catch</span> (ExecutionException e) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,
                            e.getCause());
                } <span class="keyword">catch</span> (CancellationException e) {
                    message = sHandler.obtainMessage(MESSAGE_POST_CANCEL,
                            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(AsyncTask.<span class="keyword">this</span>, (Result[]) <span class="keyword">null</span>));
                    message.sendToTarget();<span class="comment">//取消任务，发送MESSAGE_POST_CANCEL消息</span>
                    <span class="keyword">return</span>;
                } <span class="keyword">catch</span> (Throwable t) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing "</span>
                            + <span class="string">"doInBackground()"</span>, t);
                }

                message = sHandler.obtainMessage(MESSAGE_POST_RESULT,
                        <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(AsyncTask.<span class="keyword">this</span>, result));<span class="comment">//完成任务，发送MESSAGE_POST_RESULT消息并传递result对象</span>
                message.sendToTarget();
            }
        };
    }
</code></pre><p>WorkerRunnable类实现了callable接口的call()方法，该函数会调用我们在AsyncTask子类中实现的doInBackground(mParams)方法，由此可见，WorkerRunnable封装了我们要执行的异步任务。FutureTask中的protected void done() {}方法实现了异步任务状态改变后的操作。当异步任务被取消，会向UI线程传递MESSAGE_POST_CANCEL消息，当任务成功执行，会向UI线程传递MESSAGE_POST_RESULT消息，并把执行结果传递到UI线程。</p>
<p>由此可知，AsyncTask在构造的时候已经定义好要异步执行的方法doInBackground(mParams)和任务状态变化后的操作（包括失败和成功）。</p>
<p>当创建完GetCSDNLogoTask对象后，执行</p>
<pre><code><span class="keyword">task</span>.execute(<span class="string">"http://csdnimg.cn/www/images/csdnindex_logo.gif"</span>);  
</code></pre><p>此时会调用AsyncTask的execute(Params…params)方法</p>
<p>AsyncTask.java</p>
<pre><code><span class="keyword">public</span> final AsyncTask&lt;Params,Progress, Result&gt; <span class="title">execute</span>(Params... <span class="keyword">params</span>) {
        <span class="keyword">if</span> (mStatus != Status.PENDING) {
            <span class="keyword">switch</span> (mStatus) {
                <span class="keyword">case</span> RUNNING:
                    <span class="keyword">throw</span> newIllegalStateException(<span class="string">"Cannot execute task:"</span>
                            + <span class="string">" the taskis already running."</span>);
                <span class="keyword">case</span> FINISHED:
                    <span class="keyword">throw</span> newIllegalStateException(<span class="string">"Cannot execute task:"</span>
                            + <span class="string">" the taskhas already been executed "</span>
                            + <span class="string">"(a task canbe executed only once)"</span>);
            }
        }

        mStatus = Status.RUNNING;

        onPreExecute();<span class="comment">//运行在ui线程，在提交任务到线程池之前执行</span>

        mWorker.mParams = <span class="keyword">params</span>;
        sExecutor.execute(mFuture);<span class="comment">//提交任务到线程池</span>

        <span class="keyword">return</span> <span class="keyword">this</span>;
}
</code></pre><p>当任务正在执行或者已经完成，会抛出IllegalStateException，由此可知我们不能够重复调用execute(Params…params)方法。在提交任务到线程池之前，调用了onPreExecute()方法。然后才执行sExecutor.execute(mFuture)是任务提交到线程池。</p>
<p>前面我们说到，当任务的状态发生改变时（1、执行成功2、取消执行3、进度更新），工作线程会向UI线程的Handler传递消息。在《Android异步处理三：Handler+Looper+MessageQueue深入详解》一文中我们提到，Handler要处理其他线程传递过来的消息。在AsyncTask中，InternalHandler是在UI线程上创建的，它接收来自工作线程的消息，实现代码如下：</p>
<p>AsyncTask.java</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> {</span>
       <span class="annotation">@SuppressWarnings</span>({<span class="string">"unchecked"</span>,<span class="string">"RawUseOfParameterizedType"</span>})
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="title">voidhandleMessage</span>(Message msg) {
            AsyncTaskResult result =(AsyncTaskResult) msg.obj;
            <span class="keyword">switch</span> (msg.what) {
                caseMESSAGE_POST_RESULT:
                    <span class="comment">// There is onlyone result</span>
                    result.mTask.finish(result.mData[<span class="number">0</span>]);<span class="comment">//执行任务成功</span>
                    <span class="keyword">break</span>;
                caseMESSAGE_POST_PROGRESS:
                   result.mTask.onProgressUpdate(result.mData);<span class="comment">//进度更新</span>
                    <span class="keyword">break</span>;
                caseMESSAGE_POST_CANCEL:
                    result.mTask.onCancelled();<span class="comment">//取消任务</span>
                    <span class="keyword">break</span>;
            }
        }
    }
</code></pre><p>当接收到消息之后，AsyncTask会调用自身相应的回调方法。</p>
<p>总结：</p>
<ol>
<li><p>AsyncTask的本质是一个静态的线程池，AsyncTask派生出的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行。</p>
</li>
<li><p>线程池中的工作线程执行doInBackground(mParams)方法执行异步任务</p>
</li>
<li><p>当任务状态改变之后，工作线程会向UI线程发送消息，AsyncTask内部的InternalHandler响应这些消息，并调用相关的回调函数</p>
</li>
</ol>

    
  </div>
  <footer>
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2015 <a href="/">Xin Zhang</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>


</body>
</html>