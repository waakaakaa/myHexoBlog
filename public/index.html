<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>挖之家</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Xin Zhang">
  
  
  <meta content="website" property="og:type">
<meta content="挖之家" property="og:title">
<meta content="http://waakaakaa.github.io/" property="og:url">
<meta property="og:image">
<meta content="挖之家" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">挖之家</a></h1>
    <p><a href="/">太阳每天都是欣的</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/06/05/tcp-的那些事儿/">
  <time datetime="2014-06-04T18:40:01.000Z">
    6月 5 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/06/05/tcp-的那些事儿/">TCP 的那些事儿</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>原文链接：<a href="http://coolshell.cn/articles/11564.html" target="_blank">http://coolshell.cn/articles/11564.html</a></p>
<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看<a href="http://www.kohala.com/start/" target="_blank">W.Richard Stevens</a>的《<a href="http://book.douban.com/subject/1088054/" target="_blank">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。</p>
<p>我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍TCP的流迭、拥塞处理。</li>
</ul>
<p>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h1 id="TCP头格式">TCP头格式</h1>
<p>接下来，我们来看一下TCP头的格式</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/TCP-Header-01.jpg" alt="image"></p>
<p>你需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。</li>
<li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li>
<li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>
<li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/TCP-Header-02.jpg" alt="image"></p>
<h1 id="TCP的状态机">TCP的状态机</h1>
<p>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“TCP协议的状态机”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank">图片来源</a>） 和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcpfsm.png" alt="image"></p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li><strong>对于建链接的3次握手</strong>，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
<li><strong>对于4次挥手</strong>，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</li>
</ul>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcpclosesimul.png" alt="两端同时断连接（[图片来源](http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm)）"></p>
<p>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
<li><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL - <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（<a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC793</a>定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“It should not be changed without advice/request of technical experts”）。<ul>
<li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique" target="_blank">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 <a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process" target="_blank">tcp_timewait_state_process</a>）。</li>
<li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<p>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank">RFC 1122</a>） </p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h1 id="数据传输中的Sequence_Number">数据传输中的Sequence Number</h1>
<p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcp_data_seq_num.jpg" alt="image"></p>
<p>你可以看到，SeqNum的增加是和传输的字节数相关的。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p>注意：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h1 id="TCP重传机制">TCP重传机制</h1>
<p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p><strong>超时重传机制</strong></p>
<p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<p><strong>快速重传机制</strong></p>
<p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/FASTIncast021.png" alt="image"></p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是重转之前的一个还是重装所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<p><strong>SACK 方法</strong></p>
<p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看<a href="http://tools.ietf.org/html/rfc2018" target="_blank">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcp_sack_example-1024x577.jpg" alt="image"></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank">TCP SACK的性能权衡</a>》</p>
<p><strong>Duplicate SACK – 重复收到数据的问题</strong></p>
<p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a> 里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank">RFC-2833</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<p>示例一：ACK丢包</p>
<p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<pre><code><span class="attribute">Transmitted  Received    ACK Sent
Segment      Segment     (Including SACK Blocks)

3000-3499    3000-3499   3500 (ACK dropped)
3500-3999    3500-3999   4000 (ACK dropped)
3000-3499    3000-3499   4000, SACK</span>=<span class="string">3000-3500
                                    ---------</span>
</code></pre><p>示例二，网络延误</p>
<p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<pre><code><span class="attribute">Transmitted    Received    ACK Sent
Segment        Segment     (Including SACK Blocks)

500-999        500-999     1000
1000-1499      (delayed)
1500-1999      1500-1999   1000, SACK</span>=<span class="string">1500-2000
2000-2499      2000-2499   1000, SACK=1500-2500
2500-2999      2500-2999   1000, SACK=1500-3000
1000-1499      1000-1499   3000
               1000-1499   3000, SACK=1000-1500
                                      ---------</span>
</code></pre><p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li><p>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
</li>
<li><p>是不是自己的timeout太小了，导致重传。</p>
</li>
<li><p>网络上出现了先发的包后到的情况（又称reordering）</p>
</li>
<li><p>网络上是不是把我的数据包给复制了。</p>
<p>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。</p>
</li>
</ol>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<hr>
<p>这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《TCP的那些事儿（上）》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<h1 id="TCP的RTT算法">TCP的RTT算法</h1>
<p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<p><strong>经典算法</strong></p>
<p><a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC793</a> 中定义的经典算法是这样的：</p>
<ol>
<li><p>首先，先采样RTT，记下最近好几次的RTT值。</p>
</li>
<li><p>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）<br>SRTT = ( α <em> SRTT ) + ((1- α) </em> RTT)</p>
</li>
<li><p>开始计算RTO。公式如下：<br>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</p>
</li>
</ol>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<p><strong>Karn / Partridge 算法</strong></p>
<p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li>
</ul>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/Karn-Partridge-Algorithm.jpg" alt="image"></p>
<p>所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn&#39;s_Algorithm" target="_blank">Karn / Partridge Algorithm</a>，这个算法的最大特点是——忽略重传，不把重传的RTT做采样（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<p><strong>Jacobson / Karels 算法</strong></p>
<p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<pre><code><span class="setting">SRTT = <span class="value">SRTT + α (RTT – SRTT)  —— 计算平滑RTT</span></span>

<span class="setting">DevRTT = <span class="value">(<span class="number">1</span>-β)*DevRTT + β*(|RTT-SRTT|) ——计算平滑RTT和真实的差距（加权移动平均）</span></span>

<span class="setting">RTO= <span class="value">µ * SRTT + ∂ *DevRTT —— 神一样的公式</span></span>
</code></pre><p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank">tcp_rtt_estimator</a>）。</p>
<h1 id="TCP滑动窗口">TCP滑动窗口</h1>
<p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/sliding_window.jpg" alt="image"></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcpswwindows.png" alt="image"></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcpswslide.png" alt="image"></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcpswflow.png" alt="image"></p>
<p><strong>Zero Window</strong></p>
<p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p>注意：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<p><strong>Silly Window Syndrome</strong></p>
<p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件（更多的条件可以看一下<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_output.c#L1421" target="_blank">tcp_nagle_check</a>函数）：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）等待时间或是超时200ms，这两个条件有一个满足，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<pre><code>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span> *)&amp;<span class="keyword">value</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
</code></pre><p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这个还不够准确。TCP_CORK是禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送。最好不要两个选项都设置。 老实说，我觉得Nagle算法其实只加了个延时，没有别的什么，我觉得最好还是把他关闭，然后由自己的应用层来控制数据，我个觉得不应该什么事都去依赖内核算法。</p>
<h1 id="TCP的拥塞处理_-_Congestion_Handling">TCP的拥塞处理 - Congestion Handling</h1>
<p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</p>
<p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank">Congestion Avoidance and Control</a>》(PDF)</p>
<p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<p><strong>慢热启动算法 – Slow Start</strong></p>
<p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<ol>
<li><p>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p>
</li>
<li><p>每当收到一个ACK，cwnd++; 呈线性上升</p>
</li>
<li><p>每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p>
</li>
<li><p>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcp.slow_.start_.jpg" alt="image"></p>
<p>这里，我需要提一下的是一篇Google的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<p><strong>拥塞避免算法 - Congestion Avoidance</strong></p>
<p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ol>
<li><p>收到一个ACK时，cwnd = cwnd + 1/cwnd</p>
</li>
<li><p>当每过一个RTT时，cwnd = cwnd + 1</p>
</li>
</ol>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<p><strong>拥塞状态时的算法</strong></p>
<p>前面我们说过，当丢包的时候，会有两种情况：</p>
<ol>
<li><p>等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</li>
<li><p>Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<p><strong>快速恢复算法 – Fast Recovery</strong></p>
<p>TCP Reno</p>
<p>这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于3个重复的Acks。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<p>TCP New Reno</p>
<p>于是，1995年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<p><strong>算法示意图</strong></p>
<p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcp.fr_-1024x359.jpg" alt="image"></p>
<p><strong>FACK算法</strong></p>
<p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）F<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank">orward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在snd.fack这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个awnd = snd.nxt – snd.fack（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h1 id="其它拥塞控制算法简介">其它拥塞控制算法简介</h1>
<p><strong>TCP Vegas 拥塞控制算法</strong></p>
<p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了Vegas和 New Reno的对比：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2014/05/tcp_vegas_newreno-1024x555.jpg" alt="image"></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank">/net/ipv4/tcp_vegas.c</a></p>
<p><strong>HSTCP(High Speed TCP) 算法</strong></p>
<p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank">/net/ipv4/tcp_highspeed.c</a></p>
<p><strong>TCP BIC 算法</strong></p>
<p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&amp;oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D" target="_blank">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank">/net/ipv4/tcp_bic.c</a></p>
<p><strong>TCP WestWood算法</strong></p>
<p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X <em> RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD </em> min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank">/net/ipv4/tcp_westwood.c</a></p>
<p><strong>其它</strong></p>
<p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>
<h1 id="后记">后记</h1>
<p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p>（全文完）</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/25/如何使用macvim/">
  <time datetime="2014-05-24T17:21:00.000Z">
    5月 25 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/25/如何使用macvim/">如何使用MacVim</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="命令模式_按下ESC_高效率移动">命令模式 按下ESC 高效率移动</h1>
<h2 id="1、在插入模式之外">1、在插入模式之外</h2>
<p>基本上来说，你应该尽可能少的呆在插入模式里面，因为在插入模式里面 VIM 就像一个“哑巴”编辑器一样。很多新手都会一直呆在插入模式里面，因为这样易于使用。但 VIM 的强大之处在于他的命令行模式！你会发现，在你越来越了解 VIM 之后，你就会花越来越少的时间使用插入模式了。</p>
<h2 id="2、使用_h、j、k、l">2、使用 h、j、k、l</h2>
<p>使用 VIM 高效率编辑的第一步，就是放弃使用箭头键。使用 VIM，你就不用频繁的在箭头键和字母键之间移来移去了，这会节省你很多时间。当你在命令模式时，你可以用 h、j、k、l 来分别实现左、下、上、右箭头的功能。一开始可能需要适应一下，但一旦习惯这种方式，你就会发现这样操作的高效之处了。</p>
<p>在你编辑你的电子邮件或者其他有段落的文本时，你可能会发现使用方向键和你预期的效果不一样，有时候可能会一次跳过了很多行。这是因为你的段落在 VIM 看来是一个大的长长的行。这时你可以在按 h、j、k 或者 l 之前键入一个 g，这样 VIM 就会按屏幕上面的行如你所愿的移动了。</p>
<h2 id="3、在当前行里面有效的移动光标">3、在当前行里面有效的移动光标</h2>
<p>很多编辑器只提供了简单的命令来控制光标的移动（比如左、上、右、下、到行首/尾等）。VIM 则提供了很多强大的命令来满足你控制光标的欲望。当光标从一点移动到另外一点，在这两点之间的文本（包括这两个点）称作被“跨过”，这里的命令也被称作是 motion。（简单说明一下，后面会用到这个重要的概念）</p>
<h2 id="4、常用到的一些命令（motion）：">4、常用到的一些命令（motion）：</h2>
<p>fx：移动光标到当前行的下一个 x 处。很明显，x 可以是任意一个字母，而且你可以使用 ; 来重复你的上一个 f 命令。</p>
<p>tx：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）</p>
<p>Fx：和 fx 类似，不过是往回找。</p>
<p>w：光标往前移动一个词。</p>
<p>b：光标往后移动一个词。</p>
<p>0：移动光标到当前行首。</p>
<p>^：移动光标到当前行的第一个字母位置。</p>
<p>$：移动光标到行尾。</p>
<p>)：移动光标到下一个句子。</p>
<p>( ：移动光标到上一个句子。</p>
<h2 id="5、在整个文件里面有效移动光标">5、在整个文件里面有效移动光标</h2>
<p>VIM 有很多命令，可以用来到达文件里面你想到达的地方。下面是一些在文件里面移动的命令：</p>
<p><C-F>：向下移动一屏。</p>
<p><C-B>：向上移动一屏。</p>
<p>G：到文件尾</p>
<p>numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）</p>
<p>gg：到文件首</p>
<p>H：移动光标到屏幕上面</p>
<p>M：移动光标到屏幕中间</p>
<p>L：移动光标到屏幕下面</p>
<p>*：读取光标处的字符串，并且移动光标到它再次出现的地方。</p>
<p>#：和上面的类似，但是是往反方向寻找。</p>
<p>/text：从当前光标处开始搜索字符串 text，并且到达 text 出现的地方。必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按 n。</p>
<p>？text：和上面类似，但是是反方向。</p>
<p>ma：在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。</p>
<p>`a：到书签 a 处。注意这个不是单引号，它一般位于大部分键盘的 1 的左边。</p>
<p>`.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。</p>
<h1 id="高效的输入_">高效的输入 </h1>
<h2 id="1、使用关键词自动完成">1、使用关键词自动完成</h2>
<p>VIM 有一个非常漂亮的关键词自动完成系统。这表示，你可以输入一个长词的一部分，然后按一下某个键，然后 VIM 就替你完成了这个长词的输入了。举个例子：你有一个变量名为 iAmALongAndAwkwardVarName 在你写的代码的某个地方。也许你不想每回都自己一个一个字母的去输入它。</p>
<p>使用关键词自动完成功能，你只需要输入开始几个字母（比如 iAmAL），然后按 <C-N>（按住 Ctrl，再按 N）或者 <C-P>。如果 VIM 没有给出你想要的词，继续按，直到你满意为止，VIM 会一直循环它找到的匹配的字符串。</p>
<h2 id="2、聪明的进入插入模式">2、聪明的进入插入模式</h2>
<p>很多新手进入插入模式都只是用 i。这样当然可以进入插入模式，但通常不是那么合适，因为 VIM 提供了很多进入插入模式的命令。下面是最常用的一些：</p>
<p>i：在当前字符的左边插入</p>
<p>I：在当前行首插入</p>
<p>a：在当前字符的右边插入</p>
<p>A：在当前行尾插入</p>
<p>o：在当前行下面插入一个新行</p>
<p>O：在当前行上面插入一个新行</p>
<p>c{motion}：删除 motion 命令跨过的字符，并且进入插入模式。比如：c$，这将会删除从光标位置到行尾的字符并且进入插入模式。ct！，这会删除从光标位置到下一个叹号（但不包括），然后进入插入模式。被删除的字符被存在了剪贴板里面，并且可以再粘贴出来。</p>
<p>d{motion}：和上面差不多，但是不进入插入模式。</p>
<h2 id="3、有效的移动大段的文本">3、有效的移动大段的文本</h2>
<p>使用可视选择（visual selections）和合适的选择模式</p>
<p>不像最初的 VI，VIM 允许你高亮（选择）一些文本，并且进行操作。这里有三种可视选择模式：</p>
<p>v：按字符选择。经常使用的模式，所以亲自尝试一下它。</p>
<p>V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。</p>
<p><C-V>：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。</p>
<p>在选择模式的时候使用上面所述的方向键和命令（motion）。比如，vwww，会高亮光标前面的三个词。Vjj 将会高亮当前行以及下面两行。</p>
<h2 id="4、在可视选择模式下剪切和拷贝">4、在可视选择模式下剪切和拷贝</h2>
<p>一旦你高亮了选区，你或许想进行一些操作：</p>
<p>d：剪贴选择的内容到剪贴板。</p>
<p>y：拷贝选择的内容到剪贴板。</p>
<p>c：剪贴选择的内容到剪贴板并且进入插入模式。</p>
<p>在非可视选择模式下剪切和拷贝</p>
<p>如果你很清楚的知道你想拷贝或者剪切什么，那你根本就不需要进入可视选择模式。这样也会节省时间：</p>
<p>d{motion}：剪切 motion 命令跨过的字符到剪贴板。比如，dw 会剪切一个词而 dfS 会将从当前光标到下一个 S 之间的字符剪切至剪贴板。</p>
<p>y{motion}：和上面类似，不过是拷贝。</p>
<p>c{motion}：和 d{motion} 类似，不过最后进入插入模式。</p>
<p>dd：剪切当前行。</p>
<p>yy：拷贝当前行。</p>
<p>cc：剪切当前行并且进入插入模式。</p>
<p>D：剪切从光标位置到行尾到剪贴板。</p>
<p>Y：拷贝当前行。</p>
<p>C：和 D 类似，最后进入插入模式。</p>
<p>x：剪切当前字符到剪贴板。</p>
<p>s：和x类似，不过最后进入插入模式。</p>
<h2 id="5、粘贴">5、粘贴</h2>
<p>粘贴很简单，按 p。</p>
<h2 id="6、使用多重剪贴板">6、使用多重剪贴板</h2>
<p>很多编辑器都只提供了一个剪贴板。VIM 有很多。剪贴板在 VIM 里面被称为寄存器（Registers）。你可以列出当前定义的所有寄存器名和它们的内容，命令为“:reg”。最好使用小写字母来作为寄存器的名称，因为大写的有些被 VIM 占用了。</p>
<p>使用寄存器的命令为双引号 “。</p>
<p>比如：我们要拷贝当前行到寄存器 k。你应该按 “kyy。（你也可以使用 V”ky。为什么这样也可以呢？）现在当前行应该已经存在了寄存器 k 里面直到你又拷贝了一些东西进入寄存器 k。现在你可以使用命令 “kp 来粘贴寄存器 k 里面的内容到你想要的位置。</p>
<h2 id="7、避免重复">7、避免重复</h2>
<p>令人惊奇的 . 命令</p>
<p>在 VI 里面，输入 . (小数点符号），将会重复你输入的上一个命令。比如，你上个命令为“dw”（删除一个词），VI 将会接着再删除一个词。</p>
<h2 id="8、使用数字">8、使用数字</h2>
<p>使用数字也是 VIM 强大的而且很节省时间的重要特性之一。在很多 VIM 的命令之前都可以使用一个数字，这个数字将会告诉 VIM 这个命令需要执行几次。比如：</p>
<p>3j 将会把光标向下移动三行。</p>
<p>10dd 将会删除十行。</p>
<p>y3″ 将会拷贝从当前光标到第三个出现的引号之间的内容到剪贴板。</p>
<p>数字是扩展 motion 命令作用域非常有效的方法。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/22/learn-x-in-y-minuteswhere-x=clojure/">
  <time datetime="2014-05-22T03:46:32.000Z">
    5月 22 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/22/learn-x-in-y-minuteswhere-x=clojure/">Learn X in Y minutes:Where X=clojure</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Get the code: <a href="http://learnxinyminutes.com/docs/files/learnclojure.clj" target="_blank">learnclojure.clj</a></p>
<p>Clojure is a Lisp family language developed for the Java Virtual Machine. It has a much stronger emphasis on pure <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank">functional programming</a> than Common Lisp, but includes several <a href="https://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank">STM</a> utilities to handle state as it comes up.</p>
<p>This combination allows it to handle concurrent processing very simply, and often automatically.</p>
<p>(You need a version of Clojure 1.2 or newer)</p>
<pre><code>; Comments start with semicolons.

; Clojure is written in <span class="string">"forms"</span>, which are just
; lists of things inside parentheses, separated by whitespace.
;
; The clojure reader  assumes that the first thing is a
; <span class="keyword">function</span> <span class="keyword">or</span> <span class="keyword">macro</span> to call, <span class="keyword">and</span> the rest are arguments.

; The first call in a file should be ns, to <span class="keyword">set</span> the namespace
(ns learnclojure)

; More basic examples:

; str will create a <span class="keyword">string</span> out of all its arguments
(str <span class="string">"Hello"</span> <span class="string">" "</span> <span class="string">"World"</span>) ; =&gt; <span class="string">"Hello World"</span>

; Math is straightforward
(+ <span class="number">1</span> <span class="number">1</span>) ; =&gt; <span class="number">2</span>
(- <span class="number">2</span> <span class="number">1</span>) ; =&gt; <span class="number">1</span>
(* <span class="number">1</span> <span class="number">2</span>) ; =&gt; <span class="number">2</span>
(/ <span class="number">2</span> <span class="number">1</span>) ; =&gt; <span class="number">2</span>

; Equality is =
(= <span class="number">1</span> <span class="number">1</span>) ; =&gt; <span class="keyword">true</span>
(= <span class="number">2</span> <span class="number">1</span>) ; =&gt; <span class="keyword">false</span>

; You need not for logic, too
(not <span class="keyword">true</span>) ; =&gt; <span class="keyword">false</span>

; Nesting forms works as you expect
(+ <span class="number">1</span> (- <span class="number">3</span> <span class="number">2</span>)) ; = <span class="number">1</span> + (<span class="number">3</span> - <span class="number">2</span>) =&gt; <span class="number">2</span>

; Types
;;;;;;;;;;;;;

; Clojure uses Java's object types for booleans, strings <span class="keyword">and</span> numbers.
; Use `class` to inspect them.
(class <span class="number">1</span>) ; Integer literals are java.lang.Long by default
(class <span class="number">1</span>.); Float literals are java.lang.Double
(class <span class="string">""</span>); Strings always double-quoted, <span class="keyword">and</span> are java.lang.<span class="keyword">String</span>
(class <span class="keyword">false</span>) ; Booleans are java.lang.Boolean
(class nil); The <span class="string">"null"</span> value is called nil

; <span class="keyword">If</span> you want to create a literal list of data, use ' to stop it from
; being evaluated
'(+ <span class="number">1</span> <span class="number">2</span>) ; =&gt; (+ <span class="number">1</span> <span class="number">2</span>)
; (shorthand for (quote (+ <span class="number">1</span> <span class="number">2</span>)))

; You can eval a quoted list
(eval '(+ <span class="number">1</span> <span class="number">2</span>)) ; =&gt; <span class="number">3</span>

; Collections &amp; Sequences
;;;;;;;;;;;;;;;;;;;

; Lists are linked-list data structures, <span class="keyword">while</span> Vectors are array-backed.
; Vectors <span class="keyword">and</span> Lists are java classes too!
(class [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]); =&gt; clojure.lang.PersistentVector
(class '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)); =&gt; clojure.lang.PersistentList

; A list would be written as just (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>), but we have to quote
; it to stop the reader thinking it's a <span class="keyword">function</span>.
; Also, (list <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) is the same as '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)

; <span class="string">"Collections"</span> are just groups of data
; Both lists <span class="keyword">and</span> vectors are collections:
(coll? '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)) ; =&gt; <span class="keyword">true</span>
(coll? [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) ; =&gt; <span class="keyword">true</span>

; <span class="string">"Sequences"</span> (seqs) are abstract descriptions of lists of data.
; Only lists are seqs.
(seq? '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)) ; =&gt; <span class="keyword">true</span>
(seq? [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) ; =&gt; <span class="keyword">false</span>

; A seq need only provide an entry when it is accessed.
; So, seqs which can be lazy -- they can define infinite series:
(range <span class="number">4</span>) ; =&gt; (<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)
(range) ; =&gt; (<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ...) (an infinite series)
(take <span class="number">4</span> (range)) ;  (<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)

; Use cons to add an item to the beginning of a list <span class="keyword">or</span> vector
(cons <span class="number">4</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) ; =&gt; (<span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)
(cons <span class="number">4</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)) ; =&gt; (<span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)

; Conj will add an item to a collection in the most efficient way.
; For lists, they insert at the beginning. For vectors, they insert at the end.
(conj [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] <span class="number">4</span>) ; =&gt; [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]
(conj '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="number">4</span>) ; =&gt; (<span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)

; Use concat to add lists <span class="keyword">or</span> vectors together
(concat [<span class="number">1</span> <span class="number">2</span>] '(<span class="number">3</span> <span class="number">4</span>)) ; =&gt; (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)

; Use filter, map to interact with collections
(map inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) ; =&gt; (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)
(filter even? [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]) ; =&gt; (<span class="number">2</span>)

; Use reduce to reduce them
(reduce + [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>])
; = (+ (+ (+ <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>) <span class="number">4</span>)
; =&gt; <span class="number">10</span>

; Reduce can take an initial-value argument too
(reduce conj [] '(<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>))
; = (conj (conj (conj [] <span class="number">3</span>) <span class="number">2</span>) <span class="number">1</span>)
; =&gt; [<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]

; Functions
;;;;;;;;;;;;;;;;;;;;;

; Use fn to create new functions. A <span class="keyword">function</span> always returns
; its last statement.
(fn [] <span class="string">"Hello World"</span>) ; =&gt; fn

; (You need extra parens to call it)
((fn [] <span class="string">"Hello World"</span>)) ; =&gt; <span class="string">"Hello World"</span>

; You can create a var using def
(def x <span class="number">1</span>)
x ; =&gt; <span class="number">1</span>

; Assign a <span class="keyword">function</span> to a var
(def hello-world (fn [] <span class="string">"Hello World"</span>))
(hello-world) ; =&gt; <span class="string">"Hello World"</span>

; You can shorten this process by using defn
(defn hello-world [] <span class="string">"Hello World"</span>)

; The [] is the list of arguments for the <span class="keyword">function</span>.
(defn hello [name]
  (str <span class="string">"Hello "</span> name))
(hello <span class="string">"Steve"</span>) ; =&gt; <span class="string">"Hello Steve"</span>

; You can also use this shorthand to create functions:
(def hello2 <span class="comment">#(str "Hello " %1))</span>
(hello2 <span class="string">"Fanny"</span>) ; =&gt; <span class="string">"Hello Fanny"</span>

; You can have multi-variadic functions, too
(defn hello3
  ([] <span class="string">"Hello World"</span>)
  ([name] (str <span class="string">"Hello "</span> name)))
(hello3 <span class="string">"Jake"</span>) ; =&gt; <span class="string">"Hello Jake"</span>
(hello3) ; =&gt; <span class="string">"Hello World"</span>

; Functions can pack extra arguments up in a seq for you
(defn count-args [&amp; args]
  (str <span class="string">"You passed "</span> (count args) <span class="string">" args: "</span> args))
(count-args <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) ; =&gt; <span class="string">"You passed 3 args: (1 2 3)"</span>

; You can mix regular <span class="keyword">and</span> packed arguments
(defn hello-count [name &amp; args]
  (str <span class="string">"Hello "</span> name <span class="string">", you passed "</span> (count args) <span class="string">" extra args"</span>))
(hello-count <span class="string">"Finn"</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)
; =&gt; <span class="string">"Hello Finn, you passed 3 extra args"</span>


; Maps
;;;;;;;;;;

; Hash maps <span class="keyword">and</span> array maps share an interface. Hash maps have faster lookups
; but don't retain key order.
(class {:a <span class="number">1</span> :b <span class="number">2</span> :c <span class="number">3</span>}) ; =&gt; clojure.lang.PersistentArrayMap
(class (hash-map :a <span class="number">1</span> :b <span class="number">2</span> :c <span class="number">3</span>)) ; =&gt; clojure.lang.PersistentHashMap

; Arraymaps will automatically become hashmaps through most operations
; <span class="keyword">if</span> they get big enough, so you don't need to worry.

; Maps can use any hashable type as a key, but usually keywords are best
; Keywords are like strings with some efficiency bonuses
(class :a) ; =&gt; clojure.lang.Keyword

(def stringmap {<span class="string">"a"</span> <span class="number">1</span>, <span class="string">"b"</span> <span class="number">2</span>, <span class="string">"c"</span> <span class="number">3</span>})
stringmap  ; =&gt; {<span class="string">"a"</span> <span class="number">1</span>, <span class="string">"b"</span> <span class="number">2</span>, <span class="string">"c"</span> <span class="number">3</span>}

(def keymap {:a <span class="number">1</span>, :b <span class="number">2</span>, :c <span class="number">3</span>})
keymap ; =&gt; {:a <span class="number">1</span>, :c <span class="number">3</span>, :b <span class="number">2</span>}

; By the way, commas are always treated as whitespace <span class="keyword">and</span> do nothing.

; Retrieve a value from a map by calling it as a <span class="keyword">function</span>
(stringmap <span class="string">"a"</span>) ; =&gt; <span class="number">1</span>
(keymap :a) ; =&gt; <span class="number">1</span>

; Keywords can be used to retrieve their value from a map, too!
(:b keymap) ; =&gt; <span class="number">2</span>

; Don't try this with strings.
;(<span class="string">"a"</span> stringmap)
; =&gt; Exception: java.lang.<span class="keyword">String</span> cannot be cast to clojure.lang.IFn

; Retrieving a non-present key returns nil
(stringmap <span class="string">"d"</span>) ; =&gt; nil

; Use assoc to add new keys to hash-maps
(def newkeymap (assoc keymap :d <span class="number">4</span>))
newkeymap ; =&gt; {:a <span class="number">1</span>, :b <span class="number">2</span>, :c <span class="number">3</span>, :d <span class="number">4</span>}

; But remember, clojure types are immutable!
keymap ; =&gt; {:a <span class="number">1</span>, :b <span class="number">2</span>, :c <span class="number">3</span>}

; Use dissoc to <span class="keyword">remove</span> keys
(dissoc keymap :a :b) ; =&gt; {:c <span class="number">3</span>}

; Sets
;;;;;;

(class <span class="comment">#{1 2 3}) ; =&gt; clojure.lang.PersistentHashSet</span>
(<span class="keyword">set</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]) ; =&gt; <span class="comment">#{1 2 3}</span>

; Add a member with conj
(conj <span class="comment">#{1 2 3} 4) ; =&gt; #{1 2 3 4}</span>

; <span class="keyword">Remove</span> one with disj
(disj <span class="comment">#{1 2 3} 1) ; =&gt; #{2 3}</span>

; Test for existence by using the <span class="keyword">set</span> as a <span class="keyword">function</span>:
(<span class="comment">#{1 2 3} 1) ; =&gt; 1</span>
(<span class="comment">#{1 2 3} 4) ; =&gt; nil</span>

; There are more functions in the clojure.sets namespace.

; Useful forms
;;;;;;;;;;;;;;;;;

; Logic constructs in clojure are just macros, <span class="keyword">and</span> look like
; everything <span class="keyword">else</span>
(<span class="keyword">if</span> <span class="keyword">false</span> <span class="string">"a"</span> <span class="string">"b"</span>) ; =&gt; <span class="string">"b"</span>
(<span class="keyword">if</span> <span class="keyword">false</span> <span class="string">"a"</span>) ; =&gt; nil

; Use let to create temporary bindings
(let [a <span class="number">1</span> b <span class="number">2</span>]
  (&gt; a b)) ; =&gt; <span class="keyword">false</span>

; Group statements together with do
(do
  (print <span class="string">"Hello"</span>)
  <span class="string">"World"</span>) ; =&gt; <span class="string">"World"</span> (prints <span class="string">"Hello"</span>)

; Functions have an implicit do
(defn print-<span class="keyword">and</span>-say-hello [name]
  (print <span class="string">"Saying hello to "</span> name)
  (str <span class="string">"Hello "</span> name))
(print-<span class="keyword">and</span>-say-hello <span class="string">"Jeff"</span>) ;=&gt; <span class="string">"Hello Jeff"</span> (prints <span class="string">"Saying hello to Jeff"</span>)

; So does let
(let [name <span class="string">"Urkel"</span>]
  (print <span class="string">"Saying hello to "</span> name)
  (str <span class="string">"Hello "</span> name)) ; =&gt; <span class="string">"Hello Urkel"</span> (prints <span class="string">"Saying hello to Urkel"</span>)

; Modules
;;;;;;;;;;;;;;;

; Use <span class="string">"use"</span> to get all functions from the module
(use 'clojure.<span class="keyword">set</span>)

; Now we can use <span class="keyword">set</span> operations
(intersection <span class="comment">#{1 2 3} #{2 3 4}) ; =&gt; #{2 3}</span>
(difference <span class="comment">#{1 2 3} #{2 3 4}) ; =&gt; #{1}</span>

; You can choose a subset of functions to import, too
(use '[clojure.<span class="keyword">set</span> :only [intersection]])

; Use require to import a module
(require 'clojure.<span class="keyword">string</span>)

; Use / to call functions from a module
; Here, the module is clojure.<span class="keyword">string</span> <span class="keyword">and</span> the <span class="keyword">function</span> is blank?
(clojure.<span class="keyword">string</span>/blank? <span class="string">""</span>) ; =&gt; <span class="keyword">true</span>

; You can give a module a shorter name <span class="keyword">on</span> import
(require '[clojure.<span class="keyword">string</span> :as str])
(str/replace <span class="string">"This is a test."</span> <span class="comment">#"[a-o]" str/upper-case) ; =&gt; "THIs Is A tEst."</span>
; (<span class="comment">#"" denotes a regular expression literal)</span>

; You can use require (<span class="keyword">and</span> use, but don't) from a namespace using :require.
; You don't need to quote your modules <span class="keyword">if</span> you do it this way.
(ns test
  (:require
    [clojure.<span class="keyword">string</span> :as str]
    [clojure.<span class="keyword">set</span> :as <span class="keyword">set</span>]))

; Java
;;;;;;;;;;;;;;;;;

; Java has a huge <span class="keyword">and</span> useful standard library, so
; you'll want to learn how to get at it.

; Use import to load a java module
(import java.util.Date)

; You can import from an ns too.
(ns test
  (:import java.util.Date
           java.util.Calendar))

; Use the class name with a <span class="string">"."</span> at the end to make a new instance
(Date.) ; &lt;a date object&gt;

; Use . to call methods. <span class="keyword">Or</span>, use the <span class="string">".method"</span> shortcut
(. (Date.) getTime) ; &lt;a timestamp&gt;
(.getTime (Date.)) ; exactly the same thing.

; Use / to call static methods
(System/currentTimeMillis) ; &lt;a timestamp&gt; (system is always present)

; Use doto to make dealing with (mutable) classes more tolerable
(import java.util.Calendar)
(doto (Calendar/getInstance)
  (.<span class="keyword">set</span> <span class="number">2000</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)
  .getTime) ; =&gt; A Date. <span class="keyword">set</span> to <span class="number">2000</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>

; STM
;;;;;;;;;;;;;;;;;

; Software Transactional Memory is the mechanism clojure uses to handle
; persistent state. There are a few constructs in clojure that use this.

; An atom is the simplest. Pass it an initial value
(def my-atom (atom {}))

; Update an atom with swap!.
; swap! takes a <span class="keyword">function</span> <span class="keyword">and</span> calls it with the current value of the atom
; as the first argument, <span class="keyword">and</span> any trailing arguments as the second
(swap! my-atom assoc :a <span class="number">1</span>) ; Sets my-atom to the result of (assoc {} :a <span class="number">1</span>)
(swap! my-atom assoc :b <span class="number">2</span>) ; Sets my-atom to the result of (assoc {:a <span class="number">1</span>} :b <span class="number">2</span>)

; Use '@' to dereference the atom <span class="keyword">and</span> get the value
my-atom  ;=&gt; Atom&lt;<span class="comment">#...&gt; (Returns the Atom object)</span>
@my-atom ; =&gt; {:a <span class="number">1</span> :b <span class="number">2</span>}

; Here's a simple counter using an atom
(def counter (atom <span class="number">0</span>))
(defn inc-counter []
  (swap! counter inc))

(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)

@counter ; =&gt; <span class="number">5</span>

; Other STM constructs are refs <span class="keyword">and</span> agents.
; Refs: http://clojure.org/refs
; Agents: http://clojure.org/agents
</code></pre><p><strong>Further Reading</strong></p>
<p>This is far from exhaustive, but hopefully it’s enough to get you on your feet.</p>
<p>Clojure.org has lots of articles: <a href="http://clojure.org/" target="_blank">http://clojure.org/</a></p>
<p>Clojuredocs.org has documentation with examples for most core functions: <a href="http://clojuredocs.org/quickref/Clojure%20Core" target="_blank">http://clojuredocs.org/quickref/Clojure%20Core</a></p>
<p>4Clojure is a great way to build your clojure/FP skills: <a href="http://www.4clojure.com/" target="_blank">http://www.4clojure.com/</a></p>
<p>Clojure-doc.org (yes, really) has a number of getting started articles: <a href="http://clojure-doc.org/" target="_blank">http://clojure-doc.org/</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/15/java-8新特性探究/">
  <time datetime="2014-05-15T04:02:25.000Z">
    5月 15 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/15/java-8新特性探究/">Java 8新特性探究</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="前言">前言</h1>
<p>自2013年6月13日，oracle就已经发布的Java 8特性完备版本（M7），但最终GA版本将在2014年3月18日（已第二次跳票，原计划今年9月发布的，据官网宣称是为了解决安全问题……），相信大家多多少少都听闻了关于Java 8的改进，总得来说，Java 8从语言，核心库，国际化、虚拟机，安全性，平台等方面一共有55个特性，本系列博文将带大家对这55个特性进行探究，不求做到最好，只求详细，深入浅出，通俗易懂。</p>
<h2 id="java几个重大版本">java几个重大版本</h2>
<p>java从1995年发布到现在，也走过18年了，个人认为，其中几个java版本都肩负着重大使命，影响甚远；<br>jdk1.0 1995年5月23日诞生，Oak语言改名为Java，并提出“Write Once ，Run anywhere”；<br>jdk1.2  1999年6月发布，将java划分为J2SE,J2ME,J2EE三大平台；<br>jdk1.4 主要是性能提升，在2000年时候JAVA成为世界上最流行的电脑语言，跟这个版本离不开关系，估计国内还有大量的java应用是运行在此版本上；<br>jdk5 诞生于2004年，他的使命就是易用，加入1. 泛型 2 自动装箱/拆箱  3 for-each  4 static import  5 变长参数等， 为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0；<br>jdk8 将在2014年3月份发布,迄今为止，可能是最大更新的java版本，也是令人期待的一个版本，在Java中引入闭包概念对Java程序开发方法的影响甚至会大于Java5中引入的泛型特征对编程方式带来的影响。<br>可以看出，jdk 8跟jdk 5之间，整整相差10年，这10年期间，相继发布jdk 6、7都是改动不大，这也说明，java发展确实有点缓慢了，以致曾经的跟随者.net在某方面超越了java，还有基于jvm上的动态语言崛起，比如Groovy、Scala等，2013年java one大会上，java平台首席架构师Mark Reinhold在会上说Java 8 is Revolutionary, Java is back（Java 8是革命性的,Java回来了），至于java 8能否能给我们带来眼前一亮的感觉呢，我们拭目以待吧</p>
<h2 id="学习java8的理由">学习java8的理由</h2>
<ol>
<li>提高java开发效率（更少的代码，更强的功能，主要是lambda表达式带来便利）</li>
<li>提高java程序的运行速度（批量数据处理，多核运行利用，更高的性能）</li>
<li>更安全，漏洞更少（为啥GA版本跳票，oracle解释说近来大量安全问题困扰着平台，所以推迟发布时间解决安全问题）</li>
<li>面试需要，跳槽的哥们，个人预言渐渐会被问及java 8的特性，想当初java 5出来一两年都会</li>
<li>逼格高，想在同事面前炫耀一般，但请注意，别以为java是向下兼容的就能随便把旧java系统升级到java最新版本</li>
<li>还在靠java开发养家糊口的程序员，不想知识陈旧落后</li>
</ol>
<h2 id="关于本系列文章说明">关于本系列文章说明</h2>
<p>本系列博文不是java入门教程，期望读者具有一定的java基础；<br>简短，排版良好，每一篇都精心准备，迎合国人的阅读习惯 （大家对长篇大论且毫无排版的文章肯定不感兴趣）；<br>降低jdk8的学习曲线，不需要到处搜索了，英文不好，或者官网上讲了，只是粗略带过，本系列文章将所有java 8的特性系统地探究；<br>最后一点，写博客比较辛苦，尊重别人的劳动成果，希望大家转载时候注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a></p>
<p>欢迎大家提出意见和问题，本人将尽量抽时间回答，谢谢。</p>
<hr>
<h1 id="（一）通往lambda之路_语法篇">（一）通往lambda之路_语法篇</h1>
<p>现在开始要灌输一些概念性的东西了，这能帮助你理解lambda更加透彻一点，如果你之前听说过，也可当是温习，所谓温故而知新……</p>
<p>在开始之前，可以同步下载jdk 8 和  IDE，IDE根据个人习惯了，不过eclipse官方版本还没出来，所以目前看的话，netbean7.4是首选的，毕竟前段子刚刚出的正式版本，以下是他们的下载地址。</p>
<p>jdk 8：<a href="https://jdk8.java.net/download.html" target="_blank">https://jdk8.java.net/download.html</a></p>
<p>Netbeans 7.4正式版:<a href="https://netbeans.org/downloads/(推荐，oracle官方发布" target="_blank">https://netbeans.org/downloads/(推荐，oracle官方发布</a>)</p>
<p>IDEA 12 EAP <a href="http://confluence.jetbrains.net/display/IDEADEV/IDEA+12+EAP" target="_blank">http://confluence.jetbrains.net/display/IDEADEV/IDEA+12+EAP</a></p>
<p>Unofficial builds of Eclipse :<a href="http://downloads.efxclipse.org/eclipse-java8/" target="_blank">http://downloads.efxclipse.org/eclipse-java8/</a></p>
<h2 id="函数式接口">函数式接口</h2>
<p>函数式接口（functional interface 也叫功能性接口，其实是同一个东西）。简单来说，函数式接口是只包含一个方法的接口。比如Java标准库中的java.lang.Runnable和java.util.Comparator都是典型的函数式接口。java 8提供 @FunctionalInterface作为注解,这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断，但 最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。 </p>
<p>Java中的lambda无法单独出现，它需要一个函数式接口来盛放，lambda表达式方法体其实就是函数接口的实现，下面讲到语法会讲到 </p>
<h2 id="Lambda语法">Lambda语法</h2>
<p>包含三个部分</p>
<ol>
<li><p>一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数</p>
</li>
<li><p>一个箭头符号：-&gt;</p>
</li>
<li><p>方法体，可以是表达式和代码块，方法体函数式接口里面方法的实现，如果是代码块，则必须用{}来包裹起来，且需要一个return 返回值，但有个例外，若函数式接口里面方法返回值是void，则无需{}</p>
</li>
</ol>
<p>总体看起来像这样</p>
<pre><code><span class="function"><span class="params">(parameters)</span> -&gt;</span> expression 或者 <span class="function"><span class="params">(parameters)</span> -&gt;</span> { statements; }
</code></pre><p>看一个完整的例子，方便理解</p>
<pre><code><span class="javadoc">/**
 * 测试lambda表达式
 *
 *<span class="javadoctag"> @author</span> benhail
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runThreadUseLambda</span>() {
        <span class="comment">//Runnable是一个函数接口，只包含了有个无参数的，返回void的run方法；</span>
        <span class="comment">//所以lambda表达式左边没有参数，右边也没有return，只是单纯的打印一句话</span>
        <span class="keyword">new</span> Thread(() -&gt;System.out.println(<span class="string">"lambda实现的线程"</span>)).start(); 
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runThreadUseInnerClass</span>() {
        <span class="comment">//这种方式就不多讲了，以前旧版本比较常见的做法</span>
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                System.out.println(<span class="string">"内部类实现的线程"</span>);
            }
        }).start();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        TestLambda.runThreadUseLambda();
        TestLambda.runThreadUseInnerClass();
    }
}
</code></pre><p>可以看出，使用lambda表达式设计的代码会更加简洁，而且还可读。</p>
<h2 id="方法引用">方法引用</h2>
<p>其实是lambda表达式的一个简化写法，所引用的方法其实是lambda表达式的方法体实现，语法也很简单，左边是容器（可以是类名，实例名），中间是”::”，右边是相应的方法名。如下所示：</p>
<pre><code><span class="tag">ObjectReference</span><span class="pseudo">::methodName</span>
</code></pre><p>一般方法的引用格式是</p>
<ol>
<li><p>如果是静态方法，则是ClassName::methodName。如 Object ::equals</p>
</li>
<li><p>如果是实例方法，则是Instance::methodName。如Object obj=new Object();obj::equals;</p>
</li>
<li><p>构造函数.则是ClassName::new</p>
</li>
</ol>
<p>再来看一个完整的例子，方便理解</p>
<pre><code><span class="keyword">import</span> java.awt.FlowLayout;
<span class="keyword">import</span> java.awt.event.ActionEvent;
<span class="keyword">import</span> javax.swing.JButton;
<span class="keyword">import</span> javax.swing.JFrame;

<span class="javadoc">/**
 *
 *<span class="javadoctag"> @author</span> benhail
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethodReference</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

        JFrame frame = <span class="keyword">new</span> JFrame();
        frame.setLayout(<span class="keyword">new</span> FlowLayout());
        frame.setVisible(<span class="keyword">true</span>);

        JButton button1 = <span class="keyword">new</span> JButton(<span class="string">"点我!"</span>);
        JButton button2 = <span class="keyword">new</span> JButton(<span class="string">"也点我!"</span>);

        frame.getContentPane().add(button1);
        frame.getContentPane().add(button2);
        <span class="comment">//这里addActionListener方法的参数是ActionListener，是一个函数式接口</span>
        <span class="comment">//使用lambda表达式方式</span>
        button1.addActionListener(e -&gt; { System.out.println(<span class="string">"这里是Lambda实现方式"</span>); });
        <span class="comment">//使用方法引用方式</span>
        button2.addActionListener(TestMethodReference::doSomething);

    }
    <span class="javadoc">/**
     * 这里是函数式接口ActionListener的实现方法
     *<span class="javadoctag"> @param</span> e 
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span>(ActionEvent e) {

        System.out.println(<span class="string">"这里是方法引用实现方式"</span>);

    }
}
</code></pre><p>可以看出，doSomething方法就是lambda表达式的实现，这样的好处就是，如果你觉得lambda的方法体会很长，影响代码可读性，方法引用就是个解决办法</p>
<h2 id="总结">总结</h2>
<p>以上就是lambda表达式语法的全部内容了，相信大家对lambda表达式都有一定的理解了，但只是代码简洁了这个好处的话，并不能打动很多观众，java 8也不会这么令人期待，其实java 8引入lambda迫切需求是因为lambda 表达式能简化集合上数据的多线程或者多核的处理，提供更快的集合处理速度 ，这个后续会讲到，关于JEP126的这一特性，将分3部分，之所以分开，是因为这一特性可写的东西太多了，这部分让读者熟悉lambda表达式以及方法引用的语法和概念，第二部分则是虚拟扩展方法（default method）的内容，最后一部分则是大数据集合的处理，解开lambda表达式的最强作用的神秘面纱。敬请期待。。。。</p>
<p>如果你有建议或者疑问，欢迎在评论里面留言</p>
<p>最后一点，写博客比较辛苦，尊重别人的劳动成果，希望大家转载时候注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a></p>
<hr>
<h1 id="（二）深入解析默认方法">（二）深入解析默认方法</h1>
<p>上篇讲了 lambda表达式的语法，但只是 JEP126 特性的一部分，另一部分就是默认方法（也称为虚拟扩展方法或防护方法） </p>
<h2 id="什么是默认方法，为什么要有默认方法">什么是默认方法，为什么要有默认方法</h2>
<p>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。 </p>
<p>为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
<p>简单的例子</p>
<p>一个接口A，Clazz类实现了接口A。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> {</span>
    <span class="keyword">default</span> <span class="keyword">void</span> foo(){
       System.out.println(<span class="string">"Calling A.foo()"</span>);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clazz</span> <span class="keyword">implements</span> <span class="title">A</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
       Clazz clazz = <span class="keyword">new</span> Clazz();
       clazz.foo();<span class="comment">//调用A.foo()</span>
    }
}
</code></pre><p>代码是可以编译的，即使Clazz类并没有实现foo()方法。在接口A中提供了foo()方法的默认实现。</p>
<h2 id="java_8抽象类与接口对比">java 8抽象类与接口对比</h2>
<p>这一个功能特性出来后，很多同学都反应了，java 8的接口都有实现方法了，跟抽象类还有什么区别？其实还是有的，请看下表对比。。</p>
<table>
<thead>
<tr>
<th>相同点</th>
<th>不同点 </th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 都是抽象类型；2. 都可以有实现方法（以前接口不行）；3. 都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）</td>
<td>1.抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；2.抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系；3.接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。 </td>
</tr>
</tbody>
</table>
<h2 id="多重继承的冲突说明">多重继承的冲突说明</h2>
<p>由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：</p>
<ol>
<li><p>一个声明在类里面的方法优先于任何默认方法（classes always win）</p>
</li>
<li><p>否则，则会优先选取最具体的实现，比如下面的例子 B重写了A的hello方法。</p>
</li>
</ol>
<p><img src="http://waakaakaa.qiniudn.com/151002_CET1_1028150.png" alt="image"></p>
<p>输出结果是：Hello World from B</p>
<p>如果想调用A的默认函数，则用到新语法X.super.m(…),下面修改C类，实现A接口，重写一个hello方法，如下所示：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>{</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span>(){
        A.<span class="keyword">super</span>.hello();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){
        <span class="keyword">new</span> C().hello();
    }
}
</code></pre><p>输出结果是：Hello World from A</p>
<h2 id="总结-1">总结</h2>
<p>默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。 </p>
<p>跟上篇博文结合起来，就是JEP126的全部了，后面还有54个特性等着我们去探究，为了让大家比较深刻了解lambda，学以致用，下一篇还是lambda的内容，预告一下下篇的标题：《Java 8特性探究（三）解开lambda表达式最强作用的神秘面纱》，第二个特性 将从第四篇开始，谢谢大家支持，敬请期待。。。</p>
<p>转载时候请注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a> </p>
<hr>
<h1 id="（三）解开lambda最强作用的神秘面纱">（三）解开lambda最强作用的神秘面纱</h1>
<p>我们期待了很久lambda为java带来闭包的概念，但是如果我们不在集合中使用它的话，就损失了很大价值。现有接口迁移成为lambda风格的问题已经通过default methods解决了，在这篇文章将深入解析Java集合里面的批量数据操作（bulk operation），解开lambda最强作用的神秘面纱。</p>
<h2 id="1-关于JSR335">1.关于JSR335</h2>
<p>JSR是Java Specification Requests的缩写，意思是Java 规范请求,Java 8 版本的主要改进是 Lambda 项目（JSR 335），其目的是使 Java 更易于为多核处理器编写代码。JSR 335=lambda表达式+接口改进（默认方法）+批量数据操作。加上前面两篇，我们已是完整的学习了JSR335的相关内容了。</p>
<h2 id="2-外部VS内部迭代">2.外部VS内部迭代</h2>
<p>以前Java集合是不能够表达内部迭代的，而只提供了一种外部迭代的方式，也就是for或者while循环。</p>
<pre><code><span class="keyword">List</span> persons = asList(<span class="keyword">new</span> Person(<span class="string">"Joe"</span>), <span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> Person(<span class="string">"John"</span>));
<span class="keyword">for</span> (Person p :  persons) {
   p.setLastName(<span class="string">"Doe"</span>);
}
</code></pre><p>上面的例子是我们以前的做法，也就是所谓的外部迭代，循环是固定的顺序循环。在现在多核的时代，如果我们想并行循环，不得不修改以上代码。效率能有多大提升还说定，且会带来一定的风险（线程安全问题等等）。<br>要描述内部迭代，我们需要用到Lambda这样的类库,下面利用lambda和Collection.forEach重写上面的循环</p>
<pre><code>persons<span class="preprocessor">.forEach</span>(p-&gt;p<span class="preprocessor">.setLastName</span>(<span class="string">"Doe"</span>))<span class="comment">;</span>
</code></pre><p>现在是由jdk 库来控制循环了，我们不需要关心last name是怎么被设置到每一个person对象里面去的，库可以根据运行环境来决定怎么做，并行，乱序或者懒加载方式。这就是内部迭代，客户端将行为p.setLastName当做数据传入api里面。 </p>
<p>内部迭代其实和集合的批量操作并没有密切的联系，借助它我们感受到语法表达上的变化。真正有意思的和批量操作相关的是新的流（stream）API。新的java.util.stream包已经添加进JDK 8了。</p>
<h2 id="3-Stream_API">3.Stream API</h2>
<p>流（Stream）仅仅代表着数据流，并没有数据结构，所以他遍历完一次之后便再也无法遍历（这点在编程时候需要注意，不像Collection，遍历多少次里面都还有数据），它的来源可以是Collection、array、io等等。</p>
<p>3.1中间与终点方法</p>
<p>流作用是提供了一种操作大数据接口，让数据操作更容易和更快。它具有过滤、映射以及减少遍历数等方法，这些方法分两种：中间方法和终端方法，“流”抽象天生就该是持续的，中间方法永远返回的是Stream，因此如果我们要获取最终结果的话，必须使用终点操作才能收集流产生的最终结果。区分这两个方法是看他的返回值，如果是Stream则是中间方法，否则是终点方法。具体请参照Stream的api。</p>
<p>简单介绍下几个中间方法（filter、map）以及终点方法（collect、sum）</p>
<p>3.1.1Filter</p>
<p>在数据流中实现过滤功能是首先我们可以想到的最自然的操作了。Stream接口暴露了一个filter方法，它可以接受表示操作的Predicate实现来使用定义了过滤条件的lambda表达式。</p>
<pre><code>List persons = …
Stream personsOver18 = persons<span class="preprocessor">.stream</span>()<span class="preprocessor">.filter</span>(p -&gt; p<span class="preprocessor">.getAge</span>() &gt; <span class="number">18</span>)<span class="comment">;//过滤18岁以上的人</span>
</code></pre><p>3.1.2Map</p>
<p>假使我们现在过滤了一些数据，比如转换对象的时候。Map操作允许我们执行一个Function的实现（Function<T,R>的泛型T,R分别表示执行输入和执行结果），它接受入参并返回。首先，让我们来看看怎样以匿名内部类的方式来描述它：</p>
<pre><code>Stream adult= persons
              .stream()
              .filter(p -&gt; p.getAge() &gt; <span class="number">18</span>)
              .map(<span class="keyword">new</span> Function() {
                  <span class="annotation">@Override</span>
                  <span class="keyword">public</span> Adult <span class="title">apply</span>(Person person) {
                     <span class="keyword">return</span> <span class="keyword">new</span> Adult(person);<span class="comment">//将大于18岁的人转为成年人</span>
                  }
              });
</code></pre><p>现在，把上述例子转换成使用lambda表达式的写法：</p>
<pre><code>Stream <span class="built_in">map</span> <span class="subst">=</span> persons<span class="built_in">.</span>stream()
                    <span class="built_in">.</span>filter(p <span class="subst">-&gt; </span>p<span class="built_in">.</span>getAge() <span class="subst">&gt;</span> <span class="number">18</span>)
                    <span class="built_in">.</span><span class="built_in">map</span>(person <span class="subst">-&gt; </span><span class="literal">new</span> Adult(person));
</code></pre><p>3.1.3Count</p>
<p>count方法是一个流的终点方法，可使流的结果最终统计，返回int，比如我们计算一下满足18岁的总人数</p>
<pre><code>int countOfAdult=persons<span class="preprocessor">.stream</span>()
                       <span class="preprocessor">.filter</span>(p -&gt; p<span class="preprocessor">.getAge</span>() &gt; <span class="number">18</span>)
                       <span class="preprocessor">.map</span>(person -&gt; new Adult(person))
                       <span class="preprocessor">.count</span>()<span class="comment">;</span>
</code></pre><p>3.1.4Collect</p>
<p>collect方法也是一个流的终点方法，可收集最终的结果</p>
<pre><code>List adultList= persons<span class="preprocessor">.stream</span>()
                       <span class="preprocessor">.filter</span>(p -&gt; p<span class="preprocessor">.getAge</span>() &gt; <span class="number">18</span>)
                       <span class="preprocessor">.map</span>(person -&gt; new Adult(person))
                       <span class="preprocessor">.collect</span>(Collectors<span class="preprocessor">.toList</span>())<span class="comment">;</span>
</code></pre><p>或者，如果我们想使用特定的实现类来收集结果：</p>
<pre><code>List adultList = persons
                 <span class="preprocessor">.stream</span>()
                 <span class="preprocessor">.filter</span>(p -&gt; p<span class="preprocessor">.getAge</span>() &gt; <span class="number">18</span>)
                 <span class="preprocessor">.map</span>(person -&gt; new Adult(person))
                 <span class="preprocessor">.collect</span>(Collectors<span class="preprocessor">.toCollection</span>(ArrayList::new))<span class="comment">;</span>
</code></pre><p>篇幅有限，其他的中间方法和终点方法就不一一介绍了，看了上面几个例子，大家明白这两种方法的区别即可，后面可根据需求来决定使用。</p>
<p>3.2顺序流与并行流</p>
<p>每个Stream都有两种模式：顺序执行和并行执行。</p>
<p>顺序流：</p>
<pre><code>List &lt;Person&gt; people = list<span class="preprocessor">.getStream</span><span class="preprocessor">.collect</span>(Collectors<span class="preprocessor">.toList</span>())<span class="comment">;</span>
</code></pre><p>并行流：</p>
<pre><code>List &lt;Person&gt; people = list<span class="preprocessor">.getStream</span><span class="preprocessor">.parallel</span>()<span class="preprocessor">.collect</span>(Collectors<span class="preprocessor">.toList</span>())<span class="comment">;</span>
</code></pre><p>顾名思义，当使用顺序方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p>
<p>3.2.1并行流原理：</p>
<pre><code><span class="keyword">List</span> originalList = someData;
split1 = originalList(<span class="number">0</span>, mid);<span class="comment">//将数据分小部分</span>
split2 = originalList(mid,end);
<span class="keyword">new</span> Runnable(split1.process());<span class="comment">//小部分执行操作</span>
<span class="keyword">new</span> Runnable(split2.process());
<span class="keyword">List</span> revisedList = split1 + split2;<span class="comment">//将结果合并</span>
</code></pre><p>大家对hadoop有稍微了解就知道，里面的 MapReduce  本身就是用于并行处理大数据集的软件框架，其 处理大数据的核心思想就是大而化小，分配到不同机器去运行map，最终通过reduce将所有机器的结果结合起来得到一个最终结果，与MapReduce不同，Stream则是利用多核技术可将大数据通过多核并行处理，而MapReduce则可以分布式的。</p>
<p>3.2.2顺序与并行性能测试对比</p>
<p>如果是多核机器，理论上并行流则会比顺序流快上一倍，下面是测试代码</p>
<pre><code>long t0 = System<span class="preprocessor">.nanoTime</span>()<span class="comment">;</span>

//初始化一个范围<span class="number">100</span>万整数流,求能被<span class="number">2</span>整除的数字，toArray（）是终点方法

int a[]=IntStream<span class="preprocessor">.range</span>(<span class="number">0</span>, <span class="number">1</span>_000_000)<span class="preprocessor">.filter</span>(p -&gt; p % <span class="number">2</span>==<span class="number">0</span>)<span class="preprocessor">.toArray</span>()<span class="comment">;</span>

long t1 = System<span class="preprocessor">.nanoTime</span>()<span class="comment">;</span>

//和上面功能一样，这里是用并行流来计算

int b[]=IntStream<span class="preprocessor">.range</span>(<span class="number">0</span>, <span class="number">1</span>_000_000)<span class="preprocessor">.parallel</span>()<span class="preprocessor">.filter</span>(p -&gt; p % <span class="number">2</span>==<span class="number">0</span>)<span class="preprocessor">.toArray</span>()<span class="comment">;</span>

long t2 = System<span class="preprocessor">.nanoTime</span>()<span class="comment">;</span>

//我本机的结果是serial: <span class="number">0.06</span>s, parallel <span class="number">0.02</span>s，证明并行流确实比顺序流快

System<span class="preprocessor">.out</span><span class="preprocessor">.printf</span>(<span class="string">"serial: %.2fs, parallel %.2fs%n"</span>, (t1 - t0) * <span class="number">1e-9</span>, (t2 - t1) * <span class="number">1e-9</span>)<span class="comment">;</span>
</code></pre><p>3.3关于Folk/Join框架</p>
<p>应用硬件的并行性在java 7就有了，那就是 java.util.concurrent 包的新增功能之一是一个 fork-join 风格的并行分解框架，同样也很强大高效，有兴趣的同学去研究，这里不详谈了，相比Stream.parallel()这种方式，我更倾向于后者。</p>
<h2 id="4-总结">4.总结</h2>
<p>如果没有lambda，Stream用起来相当别扭，他会产生大量的匿名内部类，比如上面的3.1.2map例子，如果没有default method，集合框架更改势必会引起大量的改动，所以lambda+default method使得jdk库更加强大，以及灵活，Stream以及集合框架的改进便是最好的证明。</p>
<p>java 8特性探究系列写了3篇了，作为大餐，将java 8的重量级特性lambda与default method写在前面，下篇上个小菜，荤素搭配，也是语言相关的，JEP104 Java 类型的注解的探究，同时谢谢大家的支持，欢迎提出建议。如果你想了解哪些特性，欢迎给我发留言。</p>
<p>转载时候请注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a> </p>
<hr>
<h1 id="（四）类型注解_复杂还是便捷">（四）类型注解 复杂还是便捷</h1>
<p>本文将介绍java 8的第二个特性：类型注解。 </p>
<p>注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么？复杂还是便捷？</p>
<h2 id="什么是类型注解">什么是类型注解</h2>
<p>在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；java 8里面，注解可以应用在任何地方，比如：</p>
<ul>
<li>创建类实例：<br>  new @Interned MyObject();</li>
<li>类型映射：<br>  myString = (@NonNull String) str;</li>
<li>implements 语句中：<br>  class UnmodifiableList<T> implements @Readonly List&lt;@Readonly T&gt; { … }</li>
<li>throw exception声明：<br>  void monitorTemperature() throws @Critical TemperatureException { … }</li>
</ul>
<p>需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。</p>
<h2 id="类型注解的作用">类型注解的作用</h2>
<p>先看看下面代码</p>
<pre><code>Collections<span class="preprocessor">.emptyList</span>()<span class="preprocessor">.add</span>(<span class="string">"One"</span>)<span class="comment">;</span>
int i=Integer<span class="preprocessor">.parseInt</span>(<span class="string">"hello"</span>)<span class="comment">;</span>
System<span class="preprocessor">.console</span>()<span class="preprocessor">.readLine</span>()<span class="comment">;</span>
</code></pre><p>上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；</p>
<p>类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。</p>
<h2 id="check_framework">check framework</h2>
<p>check framework是第三方工具，配合Java的类型注解效果就是1+1&gt;2。它可以嵌入到javac编译器里面，可以配合ant和maven使用，也可以作为eclipse插件。地址是<a href="http://types.cs.washington.edu/checker-framework/。" target="_blank">http://types.cs.washington.edu/checker-framework/。</a></p>
<p>check framework可以找到类型注解出现的地方并检查，举个简单的例子：</p>
<pre><code>import checkers.nullness.quals.*;
<span class="keyword">public</span> <span class="keyword">class</span> GetStarted {
    <span class="keyword">void</span> sample() {
        @NonNull Object <span class="keyword">ref</span> = <span class="keyword">new</span> Object();
    }
}
</code></pre><p>使用javac编译上面的类 </p>
<pre><code>javac -processor checkers<span class="preprocessor">.nullness</span><span class="preprocessor">.NullnessChecker</span> GetStarted<span class="preprocessor">.java</span>
</code></pre><p>编译是通过，但如果修改成</p>
<pre><code><span class="keyword">@NonNull</span> Object <span class="keyword">ref</span> = <span class="literal">null</span>;
</code></pre><p>再次编译，则出现 </p>
<pre><code>GetStarted.java:<span class="number">5</span>: incompatible types.
found   : <span class="keyword">@Nullable</span> &lt;nulltype&gt;
required: <span class="keyword">@NonNull</span> Object
        <span class="keyword">@NonNull</span> Object <span class="keyword">ref</span> = <span class="literal">null</span>;
                              ^
<span class="number">1</span> error
</code></pre><p>如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为</p>
<pre><code>import checkers.nullness.quals.*;
<span class="keyword">public</span> <span class="keyword">class</span> GetStarted {
    <span class="keyword">void</span> sample() {
        <span class="comment">/*@NonNull*/</span> Object <span class="keyword">ref</span> = <span class="keyword">null</span>;
    }
}
</code></pre><p>这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。</p>
<p>通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。</p>
<h2 id="关于JSR_308">关于JSR 308</h2>
<p>JSR 308想要解决在Java 1.5注解中出现的两个问题：</p>
<ul>
<li>在句法上对注解的限制：只能把注解写在声明的地方 </li>
<li>类型系统在语义上的限制：类型系统还做不到预防所有的bug </li>
</ul>
<p>JSR 308 通过如下方法解决上述两个问题： </p>
<ul>
<li>对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括：方法接收器（method receivers，译注：例public int size() @Readonly { … }），泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性</li>
<li>通过引入可插拔的类型系统（pluggable type systems）能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework</li>
</ul>
<p>对JSR308，有人反对，觉得更复杂更静态了，比如<br>@NotEmpty List&lt;@NonNull String&gt; strings = new ArrayList&lt;@NonNull String&gt;()&gt;<br>换成动态语言为<br>var strings = [“one”, “two”]; </p>
<p>有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。</p>
<h2 id="总结-2">总结</h2>
<p>并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用JSR 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。</p>
<p>转载时候请注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a> </p>
<hr>
<h1 id="（五）重复注解（repeating_annotations）">（五）重复注解（repeating annotations）</h1>
<h2 id="知识回顾">知识回顾</h2>
<p>前面介绍了：<br>lambda表达式和默认方法 （JEP 126）<br>批量数据操作（JEP 107）<br>类型注解（JEP 104）<br>注：JEP=JDK Enhancement-Proposal (JDK 增强建议 )，每个JEP即一个新特性。</p>
<p>在java 8里面，注解一共有2个改进，一个是类型注解，在上篇已经介绍了，本篇将介绍另外一个注解的改进：重复注解（JEP 120）。</p>
<h2 id="什么是重复注解">什么是重复注解</h2>
<p>允许在同一申明类型（类，属性，或方法）的多次使用同一个注解</p>
<h2 id="一个简单的例子">一个简单的例子</h2>
<p>java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码：</p>
<pre><code><span class="keyword">public</span> @<span class="keyword">interface</span> Authority {
     String role();
}

<span class="keyword">public</span> @<span class="keyword">interface</span> Authorities {
    Authority[] <span class="keyword">value</span>();
}

<span class="keyword">public</span> <span class="keyword">class</span> RepeatAnnotationUseOldVersion {

    @Authorities({@Authority(role=<span class="string">"Admin"</span>),@Authority(role=<span class="string">"Manager"</span>)})
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span>(){
    }
}
</code></pre><p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解，我们再来看看java 8里面的做法：</p>
<pre><code>@Repeatable(Authorities.class)
<span class="keyword">public</span> @<span class="keyword">interface</span> Authority {
     String role();
}

<span class="keyword">public</span> @<span class="keyword">interface</span> Authorities {
    Authority[] <span class="keyword">value</span>();
}

<span class="keyword">public</span> <span class="keyword">class</span> RepeatAnnotationUseNewVersion {
    @Authority(role=<span class="string">"Admin"</span>)
    @Authority(role=<span class="string">"Manager"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span>(){ }
}
</code></pre><p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点</p>
<h2 id="总结-3">总结</h2>
<p>JEP120没有太多内容，是一个小特性，仅仅是为了提高代码可读性。这次java 8对注解做了2个方面的改进（JEP 104,JEP120），相信注解会比以前使用得更加频繁了。</p>
<p>转载时候请注明出处。 <a href="http://my.oschina.net/benhaile" target="_blank">http://my.oschina.net/benhaile</a> </p>
<hr>
<h1 id="（六）泛型的目标类型推断">（六）泛型的目标类型推断</h1>
<h2 id="简单理解泛型">简单理解泛型</h2>
<p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点将就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。</p>
<p>理解Java泛型最简单的方法是把它看成一种便捷语法，能节省你某些Java类型转换(casting)上的操作：</p>
<pre><code>List&lt;Apple&gt; box = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();box.add(<span class="keyword">new</span> Apple());Apple apple =box.<span class="keyword">get</span>(<span class="number">0</span>);
</code></pre><p>上面的代码自身已表达的很清楚：box是一个装有Apple对象的List。get方法返回一个Apple对象实例，这个过程不需要进行类型转换。没有泛型，上面的代码需要写成这样：</p>
<pre><code><span class="attribute">Apple apple </span>=<span class="string"> (Apple)box.get(0);</span>
</code></pre><h2 id="泛型的尴尬">泛型的尴尬</h2>
<p>泛型的最大优点是提供了程序的类型安全同时可以向后兼容，但也有尴尬的地方，就是每次定义时都要写明泛型的类型，这样显示指定不仅感觉有些冗长，最主要是很多程序员不熟悉泛型，因此很多时候不能够给出正确的类型参数，现在通过编译器自动推断泛型的参数类型，能够减少这样的情况，并提高代码可读性。</p>
<h2 id="java7的泛型类型推断改进">java7的泛型类型推断改进</h2>
<p>在以前的版本中使用泛型类型，需要在声明并赋值的时候，两侧都加上泛型类型。例如：</p>
<pre><code><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">String</span>&gt; myMap = <span class="keyword">new</span> HashMap&lt;<span class="typename">String</span>, <span class="typename">String</span>&gt;();
</code></pre><p>你可能觉得:老子在声明变量的的时候已经指明了参数类型，为毛还要在初始化对象时再指定？幸好，在Java SE 7中，这种方式得以改进，现在你可以使用如下语句进行声明并赋值：</p>
<pre><code><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">String</span>&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;(); //注意后面的<span class="string">"&lt;&gt;"</span>
</code></pre><p>在这条语句中，编译器会根据变量声明时的泛型类型自动推断出实例化HashMap时的泛型类型。再次提醒一定要注意new HashMap后面的“&lt;&gt;”，只有加上这个“&lt;&gt;”才表示是自动类型推断，否则就是非泛型类型的HashMap，并且在使用编译器编译源代码时会给出一个警告提示。</p>
<p>但是：Java SE 7在创建泛型实例时的类型推断是有限制的：只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如：下面的例子在java 7无法正确编译（但现在在java8里面可以编译，因为根据方法参数来自动推断泛型的类型）：</p>
<pre><code><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">list</span> <span class="subst">=</span> <span class="literal">new</span> ArrayList<span class="subst">&lt;&gt;</span>();
<span class="built_in">list</span><span class="built_in">.</span>add(<span class="string">"A"</span>);<span class="comment">// 由于addAll期望获得Collection&lt;? extends String&gt;类型的参数，因此下面的语句无法通过</span>
<span class="built_in">list</span><span class="built_in">.</span>addAll(<span class="literal">new</span> ArrayList<span class="subst">&lt;&gt;</span>());
</code></pre><h2 id="Java8的泛型类型推断改进">Java8的泛型类型推断改进</h2>
<p>java8里面泛型的目标类型推断主要2个：</p>
<ol>
<li><p>支持通过方法上下文推断泛型目标类型</p>
</li>
<li><p>支持在方法调用链路当中，泛型类型推断传递到最后一个方法</p>
</li>
</ol>
<p>让我们看看官网的例子</p>
<pre><code>class List&lt;E&gt; {
   static &lt;Z&gt; List&lt;Z&gt; nil() { <span class="keyword">...</span> };
   static &lt;Z&gt; List&lt;Z&gt; cons(Z head, List&lt;Z&gt; tail) { <span class="keyword">...</span> };
   E head() { <span class="keyword">...</span> }
}
</code></pre><p>根据JEP101的特性，我们在调用上面方法的时候可以这样写</p>
<pre><code>//通过方法赋值的目标参数来自动推断泛型的类型
<span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt; l = <span class="keyword">List</span>.nil();
//而不是显示的指定类型
//<span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt; l = <span class="keyword">List</span>.&lt;<span class="keyword">String</span>&gt;nil();
//通过前面方法参数类型推断泛型的类型
<span class="keyword">List</span>.cons(<span class="number">42</span>, <span class="keyword">List</span>.nil());
//而不是显示的指定类型
//<span class="keyword">List</span>.cons(<span class="number">42</span>, <span class="keyword">List</span>.&lt;<span class="keyword">Integer</span>&gt;nil());
</code></pre><h2 id="总结-4">总结</h2>
<p>以上是JEP101的特性内容了，Java作为静态语言的代表者，可以说类型系统相当丰富。导致类型间互相转换的问题困扰着每个java程序员，通过编译器自动推断类型的东西可以稍微缓解一下类型转换太复杂的问题。 虽然说是小进步，但对于我们天天写代码的程序员，肯定能带来巨大的作用，至少心情更愉悦了~~说不定在java 9里面，我们会得到一个通用的类型var，像js或者scala的一些动态语言那样^_^</p>
<hr>
<h1 id="（七）深入解析日期和时间-JSR310">（七）深入解析日期和时间-JSR310</h1>
<p>博客一个月没更新了，这次给大家讲下java8时间与日期API。</p>
<p>众所周知，日期是商业逻辑计算一个关键的部分，任何企业应用程序都需要处理时间问题。应用程序需要知道当前的时间点和下一个时间点，有时它们还必须计算这两个时间点之间的路径。但java之前的日期做法太令人恶心了，我们先来吐槽一下</p>
<h2 id="吐槽java-util-Date跟Calendar">吐槽java.util.Date跟Calendar</h2>
<p>Tiago Fernandez做过一次投票，选举最烂的JAVA API，排第一的EJB2.X，第二的就是日期API。</p>
<p>槽点一</p>
<p>最开始的时候，Date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂（不懂单一职责，你妈妈知道吗？纯属恶搞~哈哈）</p>
<p>后来从JDK 1.1 开始，这三项职责分开了：</p>
<ul>
<li><p>使用Calendar类实现日期和时间字段之间转换；</p>
</li>
<li><p>使用DateFormat类来格式化和分析日期字符串；</p>
</li>
<li><p>而Date只用来承载日期和时间信息。</p>
</li>
</ul>
<p>原有Date中的相应方法已废弃。不过，无论是Date，还是Calendar，都用着太不方便了，这是API没有设计好的地方。</p>
<p>槽点二</p>
<p>坑爹的year和month</p>
<pre><code><span class="built_in">Date</span> <span class="built_in">date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>);
System.out.println(<span class="built_in">date</span>);
输出Thu Feb <span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">3912</span>
</code></pre><p>观察输出结果，year是2012+1900，而month，月份参数我不是给了1吗？怎么输出二月（Feb）了？</p>
<p>应该曾有人告诉你，如果你要设置日期，应该使用 java.util.Calendar，像这样…</p>
<pre><code>Calendar calendar = Calendar.getInstance();
calendar.<span class="operator"><span class="keyword">set</span>(<span class="number">2013</span>, <span class="number">8</span>, <span class="number">2</span>);</span>
</code></pre><p>这样写又不对了，calendar的month也是从0开始的，表达8月份应该用7这个数字，要么就干脆用枚举</p>
<pre><code>calendar.<span class="operator"><span class="keyword">set</span>(<span class="number">2013</span>, Calendar.AUGUST, <span class="number">2</span>);</span>
</code></pre><p>注意上面的代码，Calendar年份的传值不需要减去1900（当然月份的定义和Date还是一样），这种不一致真是让人抓狂！</p>
<p>有些人可能知道，Calendar相关的API是IBM捐出去的，所以才导致不一致。</p>
<p>槽点三</p>
<p>java.util.Date与java.util.Calendar中的所有属性都是可变的</p>
<p>下面的代码，计算两个日期之间的天数….</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    Calendar birth = Calendar.getInstance();
    birth.<span class="keyword">set</span>(<span class="number">1975</span>, Calendar.MAY, <span class="number">26</span>);
    Calendar now = Calendar.getInstance();
    System.<span class="keyword">out</span>.println(daysBetween(birth, now));
    System.<span class="keyword">out</span>.println(daysBetween(birth, now)); <span class="comment">// 显示 0？</span>
 }  

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">daysBetween</span>(Calendar begin, Calendar end) {
    <span class="keyword">long</span> daysBetween = <span class="number">0</span>;
    <span class="keyword">while</span>(begin.before(end)) {
        begin.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);
        daysBetween++;
    }
    <span class="keyword">return</span> daysBetween;
}
</code></pre><p>daysBetween有点问题，如果连续计算两个Date实例的话，第二次会取得0，因为Calendar状态是可变的，考虑到重复计算的场合，最好复制一个新的Calendar</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">daysBetween</span>(Calendar begin, Calendar end) {
    Calendar calendar = (Calendar) begin.clone(); <span class="comment">// 复制</span>
    <span class="keyword">long</span> daysBetween = <span class="number">0</span>;
    <span class="keyword">while</span>(calendar.before(end)) {
        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);
        daysBetween++;
    }
    <span class="keyword">return</span> daysBetween;
}
</code></pre><h2 id="JSR310">JSR310</h2>
<p>以上种种，导致目前有些第三方的java日期库诞生，比如广泛使用的JODA-TIME，还有Date4j等，虽然第三方库已经足够强大，好用，但还是有兼容问题的，比如标准的JSF日期转换器与joda-time API就不兼容，你需要编写自己的转换器，所以标准的API还是必须的，于是就有了JSR310。</p>
<p>JSR 310实际上有两个日期概念。第一个是Instant，它大致对应于java.util.Date类，因为它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。</p>
<p>第二个对应于人类自身的观念，比如LocalDate和LocalTime。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。</p>
<p>目前Java8已经实现了JSR310的全部内容。新增了java.time包定义的类表示了日期-时间概念的规则，包括instants, durations, dates, times, time-zones and periods。这些都是基于ISO日历系统，它又是遵循 Gregorian规则的。最重要的一点是值不可变，且线程安全，通过下面一张图，我们快速看下java.time包下的一些主要的类的值的格式，方便理解。</p>
<p><img src="http://waakaakaa.qiniudn.com/211851_CcKe_1028150.jpg" alt="image"></p>
<h2 id="方法概览">方法概览</h2>
<p>该包的API提供了大量相关的方法，这些方法一般有一致的方法前缀：</p>
<p>of：静态工厂方法。</p>
<p>parse：静态工厂方法，关注于解析。</p>
<p>get：获取某些东西的值。</p>
<p>is：检查某些东西的是否是true。</p>
<p>with：不可变的setter等价物。</p>
<p>plus：加一些量到某个对象。</p>
<p>minus：从某个对象减去一些量。</p>
<p>to：转换到另一个类型。</p>
<p>at：把这个对象与另一个对象组合起来，例如： date.atTime(time)。</p>
<h2 id="与旧的API对应关系">与旧的API对应关系</h2>
<p><img src="http://waakaakaa.qiniudn.com/214016_EMfq_1028150.png" alt="image"></p>
<h2 id="简单使用java-time的API">简单使用java.time的API</h2>
<p>参考<a href="http://jinnianshilongnian.iteye.com/blog/1994164" target="_blank">http://jinnianshilongnian.iteye.com/blog/1994164</a> 被我揉在一起，可读性很差，相应的代码都有注释了，我就不过多解释了。</p>
<pre><code>public class TimeIntroduction {
    public static void testClock() throws InterruptedException {
        //时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。  
        Clock c1 = Clock<span class="preprocessor">.systemUTC</span>()<span class="comment">; //系统默认UTC时钟（当前瞬时时间 System.currentTimeMillis()）  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c1<span class="preprocessor">.millis</span>())<span class="comment">; //每次调用将返回当前瞬时时间（UTC）  </span>
        Clock c2 = Clock<span class="preprocessor">.systemDefaultZone</span>()<span class="comment">; //系统默认时区时钟（当前瞬时时间）  </span>
        Clock c31 = Clock<span class="preprocessor">.system</span>(ZoneId<span class="preprocessor">.of</span>(<span class="string">"Europe/Paris"</span>))<span class="comment">; //巴黎时区  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c31<span class="preprocessor">.millis</span>())<span class="comment">; //每次调用将返回当前瞬时时间（UTC）  </span>
        Clock c32 = Clock<span class="preprocessor">.system</span>(ZoneId<span class="preprocessor">.of</span>(<span class="string">"Asia/Shanghai"</span>))<span class="comment">;//上海时区  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c32<span class="preprocessor">.millis</span>())<span class="comment">;//每次调用将返回当前瞬时时间（UTC）  </span>
        Clock c4 = Clock<span class="preprocessor">.fixed</span>(Instant<span class="preprocessor">.now</span>(), ZoneId<span class="preprocessor">.of</span>(<span class="string">"Asia/Shanghai"</span>))<span class="comment">;//固定上海时区时钟  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c4<span class="preprocessor">.millis</span>())<span class="comment">;</span>
        Thread<span class="preprocessor">.sleep</span>(<span class="number">1000</span>)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c4<span class="preprocessor">.millis</span>())<span class="comment">; //不变 即时钟时钟在那一个点不动  </span>
        Clock c5 = Clock<span class="preprocessor">.offset</span>(c1, Duration<span class="preprocessor">.ofSeconds</span>(<span class="number">2</span>))<span class="comment">; //相对于系统默认时钟两秒的时钟  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c1<span class="preprocessor">.millis</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(c5<span class="preprocessor">.millis</span>())<span class="comment">;</span>
    }
    public static void testInstant() {
        //瞬时时间 相当于以前的System<span class="preprocessor">.currentTimeMillis</span>()  
        Instant instant1 = Instant<span class="preprocessor">.now</span>()<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(instant1<span class="preprocessor">.getEpochSecond</span>())<span class="comment">;//精确到秒 得到相对于1970-01-01 00:00:00 UTC的一个时间  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(instant1<span class="preprocessor">.toEpochMilli</span>())<span class="comment">; //精确到毫秒  </span>
        Clock clock1 = Clock<span class="preprocessor">.systemUTC</span>()<span class="comment">; //获取系统UTC默认时钟  </span>
        Instant instant2 = Instant<span class="preprocessor">.now</span>(clock1)<span class="comment">;//得到时钟的瞬时时间  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(instant2<span class="preprocessor">.toEpochMilli</span>())<span class="comment">;</span>
        Clock clock2 = Clock<span class="preprocessor">.fixed</span>(instant1, ZoneId<span class="preprocessor">.systemDefault</span>())<span class="comment">; //固定瞬时时间时钟  </span>
        Instant instant3 = Instant<span class="preprocessor">.now</span>(clock2)<span class="comment">;//得到时钟的瞬时时间  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(instant3<span class="preprocessor">.toEpochMilli</span>())<span class="comment">;//equals instant1  </span>
    }
    public static void testLocalDateTime() {
        //使用默认时区时钟瞬时时间创建 Clock<span class="preprocessor">.systemDefaultZone</span>() --&gt;即相对于 ZoneId<span class="preprocessor">.systemDefault</span>()默认时区  
        LocalDateTime now = LocalDateTime<span class="preprocessor">.now</span>()<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(now)<span class="comment">;</span>
//自定义时区  
        LocalDateTime now2 = LocalDateTime<span class="preprocessor">.now</span>(ZoneId<span class="preprocessor">.of</span>(<span class="string">"Europe/Paris"</span>))<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(now2)<span class="comment">;//会以相应的时区显示日期  </span>
//自定义时钟  
        Clock clock = Clock<span class="preprocessor">.system</span>(ZoneId<span class="preprocessor">.of</span>(<span class="string">"Asia/Dhaka"</span>))<span class="comment">;</span>
        LocalDateTime now3 = LocalDateTime<span class="preprocessor">.now</span>(clock)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(now3)<span class="comment">;//会以相应的时区显示日期  </span>
//不需要写什么相对时间 如java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span> 年是相对于<span class="number">1900</span> 月是从<span class="number">0</span>开始  
//<span class="number">2013</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>  
        LocalDateTime d1 = LocalDateTime<span class="preprocessor">.of</span>(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>)<span class="comment">;</span>
//年月日 时分秒 纳秒  
        LocalDateTime d2 = LocalDateTime<span class="preprocessor">.of</span>(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">11</span>)<span class="comment">;</span>
//使用瞬时时间 + 时区  
        Instant instant = Instant<span class="preprocessor">.now</span>()<span class="comment">;</span>
        LocalDateTime d3 = LocalDateTime<span class="preprocessor">.ofInstant</span>(Instant<span class="preprocessor">.now</span>(), ZoneId<span class="preprocessor">.systemDefault</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d3)<span class="comment">;</span>
//解析String---&gt;LocalDateTime  
        LocalDateTime d4 = LocalDateTime<span class="preprocessor">.parse</span>(<span class="string">"2013-12-31T23:59"</span>)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d4)<span class="comment">;</span>
        LocalDateTime d5 = LocalDateTime<span class="preprocessor">.parse</span>(<span class="string">"2013-12-31T23:59:59.999"</span>)<span class="comment">;//999毫秒 等价于999000000纳秒  </span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d5)<span class="comment">;</span>
//使用DateTimeFormatter API 解析 和 格式化  
        DateTimeFormatter formatter = DateTimeFormatter<span class="preprocessor">.ofPattern</span>(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>)<span class="comment">;</span>
        LocalDateTime d6 = LocalDateTime<span class="preprocessor">.parse</span>(<span class="string">"2013/12/31 23:59:59"</span>, formatter)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(formatter<span class="preprocessor">.format</span>(d6))<span class="comment">;</span>
//时间获取  
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getYear</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getMonth</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getDayOfYear</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getDayOfMonth</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getDayOfWeek</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getHour</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getMinute</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getSecond</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d6<span class="preprocessor">.getNano</span>())<span class="comment">;</span>
//时间增减  
        LocalDateTime d7 = d6<span class="preprocessor">.minusDays</span>(<span class="number">1</span>)<span class="comment">;</span>
        LocalDateTime d8 = d7<span class="preprocessor">.plus</span>(<span class="number">1</span>, IsoFields<span class="preprocessor">.QUARTER</span>_YEARS)<span class="comment">;</span>
//LocalDate 即年月日 无时分秒  
//LocalTime即时分秒 无年月日  
//API和LocalDateTime类似就不演示了  
    }
    public static void testZonedDateTime() {
        //即带有时区的date-time 存储纳秒、时区和时差（避免与本地date-time歧义）。  
//API和LocalDateTime类似，只是多了时差(如<span class="number">2013</span>-<span class="number">12</span>-<span class="number">20</span>T10:<span class="number">35</span>:<span class="number">50.711</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai])  
        ZonedDateTime now = ZonedDateTime<span class="preprocessor">.now</span>()<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(now)<span class="comment">;</span>
        ZonedDateTime now2 = ZonedDateTime<span class="preprocessor">.now</span>(ZoneId<span class="preprocessor">.of</span>(<span class="string">"Europe/Paris"</span>))<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(now2)<span class="comment">;</span>
//其他的用法也是类似的 就不介绍了  
        ZonedDateTime z1 = ZonedDateTime<span class="preprocessor">.parse</span>(<span class="string">"2013-12-31T23:59:59Z[Europe/Paris]"</span>)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(z1)<span class="comment">;</span>
    }
    public static void testDuration() {
        //表示两个瞬时时间的时间段  
        Duration d1 = Duration<span class="preprocessor">.between</span>(Instant<span class="preprocessor">.ofEpochMilli</span>(System<span class="preprocessor">.currentTimeMillis</span>() - <span class="number">12323123</span>), Instant<span class="preprocessor">.now</span>())<span class="comment">;</span>
//得到相应的时差  
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d1<span class="preprocessor">.toDays</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d1<span class="preprocessor">.toHours</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d1<span class="preprocessor">.toMinutes</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d1<span class="preprocessor">.toMillis</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d1<span class="preprocessor">.toNanos</span>())<span class="comment">;</span>
//<span class="number">1</span>天时差 类似的还有如ofHours()  
        Duration d2 = Duration<span class="preprocessor">.ofDays</span>(<span class="number">1</span>)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d2<span class="preprocessor">.toDays</span>())<span class="comment">;</span>
    }
    public static void testChronology() {
        //提供对java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span>的替换，提供对年历系统的支持  
        Chronology c = HijrahChronology<span class="preprocessor">.INSTANCE</span><span class="comment">;</span>
        ChronoLocalDateTime d = c<span class="preprocessor">.localDateTime</span>(LocalDateTime<span class="preprocessor">.now</span>())<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(d)<span class="comment">;</span>
    }
    <span class="comment">/**
     * 新旧日期转换
     */</span>
    public static void testNewOldDateConversion(){
        Instant instant=new Date()<span class="preprocessor">.toInstant</span>()<span class="comment">;</span>
        Date date=Date<span class="preprocessor">.from</span>(instant)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(instant)<span class="comment">;</span>
        System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(date)<span class="comment">;</span>
    }
    public static void main(String[] args) throws InterruptedException {
        testClock()<span class="comment">;</span>
        testInstant()<span class="comment">;</span>
        testLocalDateTime()<span class="comment">;</span>
        testZonedDateTime()<span class="comment">;</span>
        testDuration()<span class="comment">;</span>
        testChronology()<span class="comment">;</span>
        testNewOldDateConversion()<span class="comment">;</span>
    }
}
</code></pre><h2 id="与Joda-Time的区别">与Joda-Time的区别</h2>
<p>其实JSR310的规范领导者Stephen Colebourne，同时也是Joda-Time的创建者，JSR310是在Joda-Time的基础上建立的，参考了绝大部分的API，但并不是说JSR310=JODA-Time，下面几个比较明显的区别是</p>
<ol>
<li><p>最明显的变化就是包名（从org.joda.time以及java.time）</p>
</li>
<li><p>JSR310不接受NULL值，Joda-Time视NULL值为0</p>
</li>
<li><p>JSR310的计算机相关的时间（Instant）和与人类相关的时间（DateTime）之间的差别变得更明显</p>
</li>
<li><p>JSR310所有抛出的异常都是DateTimeException的子类。虽然DateTimeException是一个RuntimeException</p>
</li>
</ol>
<h2 id="总结-5">总结</h2>
<p>对比旧的日期API</p>
<table>
<thead>
<tr>
<th>Java.time</th>
<th>java.util.Calendar以及Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>流畅的API</td>
<td>实例可变</td>
</tr>
<tr>
<td>实例不可变</td>
<td>Content Cell</td>
</tr>
<tr>
<td>线程安全</td>
<td>非线程安全</td>
</tr>
</tbody>
</table>
<p>日期与时间处理API，在各种语言中，可能都只是个不起眼的API，如果你没有较复杂的时间处理需求，可能只是利用日期与时间处理API取得系统时间，简单做些显示罢了，然而如果认真看待日期与时间，其复杂程度可能会远超过你的想象，天文、地理、历史、政治、文化等因素，都会影响到你对时间的处理。所以在处理时间上，最好选用JSR310（如果你用java8的话就实现310了），或者Joda-Time。</p>
<p>不止是java面临时间处理的尴尬，其他语言同样也遇到过类似的问题，比如</p>
<p>Arrow：Python 中更好的日期与时间处理库</p>
<p>Moment.js：JavaScript 中的日期库</p>
<p>Noda-Time：.NET 阵营的 Joda-Time 的复制</p>
<p>转载时请注明出处</p>
<hr>
<h1 id="（八）精简的JRE详解">（八）精简的JRE详解</h1>
<p>Oracle公司如期发布了Java 8正式版！没有让广大javaer失望。对于一个人来说，18岁是人生的转折点，从稚嫩走向成熟，法律意味着你是完全民事行为能力人，不再收益于未成年人保护法，到今年为止，java也走过了18年，java8是一个新的里程碑，带来了前所未有的诸多特性，lambda表达式，Stream API，新的Date time api，多核并发支持，重大安全问题改进等，相信java会越来越好，丰富的类库以及庞大的开源生态环境是其他语言所不具备的，说起丰富的类库，很多同学就吐槽了，java该减肥了，确实是该减肥，java8有个很好的特性，即JEP161(<a href="http://openjdk.java.net/jeps/161" target="_blank">http://openjdk.java.net/jeps/161</a> ),该特性定义了Java SE平台规范的一些子集，使java应用程序不需要整个JRE平台即可部署和运行在小型设备上。开发人员可以基于目标硬件的可用资源选择一个合适的JRE运行环境。</p>
<h2 id="好处">好处</h2>
<ol>
<li>更小的Java环境需要更少的计算资源。</li>
<li>一个较小的运行时环境可以更好的优化性能和启动时间。</li>
<li>消除未使用的代码从安全的角度总是好的。</li>
<li>这些打包的应用程序可以下载速度更快。</li>
</ol>
<h2 id="概念">概念</h2>
<p>紧凑的JRE分3种，分别是compact1、compact2、compact3，他们的关系是compact1&lt;compact2&lt;compact3,他们包含的API如下图所示</p>
<p><img src="http://waakaakaa.qiniudn.com/234651_o8nK_1028150.png" alt="image"></p>
<h2 id="使用javac根据profile编译应用程序">使用javac根据profile编译应用程序</h2>
<p>javac –bootclasspath, or javac –profile <profile> </p>
<p>如果不符合compact的api，则报错。</p>
<pre><code>$ javac -profile compact2 Test.java
Test.java:<span class="number">7</span>: <span class="keyword">error</span>: ThreadMXBean <span class="keyword">is</span> <span class="keyword">not</span> available <span class="keyword">in</span> profile <span class="comment">'compact2'</span>
 ThreadMXBean bean = ManagementFactory.getThreadMXBean();
 ^
Test.java:<span class="number">7</span>: <span class="keyword">error</span>: ManagementFactory <span class="keyword">is</span> <span class="keyword">not</span> available <span class="keyword">in</span> profile <span class="comment">'compact2'</span>
 ThreadMXBean bean = ManagementFactory.getThreadMXBean();
                     ^
<span class="number">2</span> errors
</code></pre><h2 id="使用工具开发的效果">使用工具开发的效果</h2>
<p><img src="http://waakaakaa.qiniudn.com/000844_kr6c_1028150.png" alt="image"></p>
<h2 id="JPEDS工具使用">JPEDS工具使用</h2>
<p>java8新增一个工具，用来分析应用程序所依赖的profile，有三个参数比较常用 -p，-v，-r</p>
<pre><code>import java<span class="preprocessor">.util</span><span class="preprocessor">.Set</span><span class="comment">;</span>
import java<span class="preprocessor">.util</span><span class="preprocessor">.HashSet</span><span class="comment">;</span>

public class Deps {
  public static void main(String[] args) {
    System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(Math<span class="preprocessor">.random</span>())<span class="comment">;</span>
    <span class="keyword">Set</span>&lt;String&gt; <span class="keyword">set</span> = new HashSet&lt;&gt;()<span class="comment">;</span>
  }
}

************** PROFILE ********************
jdeps -P Deps<span class="preprocessor">.class</span> 
Deps<span class="preprocessor">.class</span> -&gt; /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/rt<span class="preprocessor">.jar</span>
   &lt;unnamed&gt; (Deps<span class="preprocessor">.class</span>)
      -&gt; java<span class="preprocessor">.io</span>                                            compact1
      -&gt; java<span class="preprocessor">.lang</span>                                          compact1
      -&gt; java<span class="preprocessor">.util</span>                                          compact1

************** VERBOSE ********************
jdeps -v Deps<span class="preprocessor">.class</span> 
Deps<span class="preprocessor">.class</span> -&gt; /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/rt<span class="preprocessor">.jar</span>
   Deps (Deps<span class="preprocessor">.class</span>)
      -&gt; java<span class="preprocessor">.io</span><span class="preprocessor">.PrintStream</span>                                
      -&gt; java<span class="preprocessor">.lang</span><span class="preprocessor">.Math</span>                                     
      -&gt; java<span class="preprocessor">.lang</span><span class="preprocessor">.Object</span>                                   
      -&gt; java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span>                                   
      -&gt; java<span class="preprocessor">.lang</span><span class="preprocessor">.System</span>                                   
      -&gt; java<span class="preprocessor">.util</span><span class="preprocessor">.HashSet</span>  

************** RECURSIVE ********************
jdeps -R Deps<span class="preprocessor">.class</span> 
Deps<span class="preprocessor">.class</span> -&gt; /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/rt<span class="preprocessor">.jar</span>
   &lt;unnamed&gt; (Deps<span class="preprocessor">.class</span>)
      -&gt; java<span class="preprocessor">.io</span>                                            
      -&gt; java<span class="preprocessor">.lang</span>                                          
      -&gt; java<span class="preprocessor">.util</span>                                          
/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/jce<span class="preprocessor">.jar</span> -&gt; /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/rt<span class="preprocessor">.jar</span>
   javax<span class="preprocessor">.crypto</span> (jce<span class="preprocessor">.jar</span>)
      -&gt; java<span class="preprocessor">.io</span>                                            
      -&gt; java<span class="preprocessor">.lang</span>                                          
      -&gt; java<span class="preprocessor">.lang</span><span class="preprocessor">.reflect</span>                                  
      -&gt; java<span class="preprocessor">.net</span>                                           
      -&gt; java<span class="preprocessor">.nio</span>                                           
      -&gt; java<span class="preprocessor">.security</span>                                      
      -&gt; java<span class="preprocessor">.security</span><span class="preprocessor">.cert</span>                                 
      -&gt; java<span class="preprocessor">.security</span><span class="preprocessor">.spec</span>                                 
      -&gt; java<span class="preprocessor">.util</span>                                          
      -&gt; java<span class="preprocessor">.util</span><span class="preprocessor">.concurrent</span>                               
      -&gt; java<span class="preprocessor">.util</span><span class="preprocessor">.jar</span>                                      
      -&gt; java<span class="preprocessor">.util</span><span class="preprocessor">.regex</span>                                    
      -&gt; java<span class="preprocessor">.util</span><span class="preprocessor">.zip</span>                                      
      -&gt; javax<span class="preprocessor">.security</span><span class="preprocessor">.auth</span>                                
      -&gt; sun<span class="preprocessor">.security</span><span class="preprocessor">.jca</span>                                   JDK internal API (rt<span class="preprocessor">.jar</span>)
      -&gt; sun<span class="preprocessor">.security</span><span class="preprocessor">.util</span>                                  JDK internal API (rt<span class="preprocessor">.jar</span>)
      -&gt; sun<span class="preprocessor">.security</span><span class="preprocessor">.validator</span>                             JDK internal API (rt<span class="preprocessor">.jar</span>)
   javax<span class="preprocessor">.crypto</span><span class="preprocessor">.interfaces</span> (jce<span class="preprocessor">.jar</span>)
      -&gt; java<span class="preprocessor">.lang</span>                                          
      -&gt; java<span class="preprocessor">.math</span>                                          
      -&gt; java<span class="preprocessor">.security</span>                                      
   javax<span class="preprocessor">.crypto</span><span class="preprocessor">.spec</span> (jce<span class="preprocessor">.jar</span>)
      -&gt; java<span class="preprocessor">.lang</span>                                          
      -&gt; java<span class="preprocessor">.math</span>                                          
      -&gt; java<span class="preprocessor">.security</span><span class="preprocessor">.spec</span>                                 
      -&gt; java<span class="preprocessor">.util</span>                                          
/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/rt<span class="preprocessor">.jar</span> -&gt; /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0</span><span class="preprocessor">.jdk</span>/Contents/Home/jre/lib/jce<span class="preprocessor">.jar</span>
   java<span class="preprocessor">.security</span> (rt<span class="preprocessor">.jar</span>)
      -&gt; javax<span class="preprocessor">.crypto</span>                                       JDK internal API (jce<span class="preprocessor">.jar</span>)
   sun<span class="preprocessor">.security</span><span class="preprocessor">.util</span> (rt<span class="preprocessor">.jar</span>)
      -&gt; javax<span class="preprocessor">.crypto</span>                                       JDK internal API (jce<span class="preprocessor">.jar</span>)
      -&gt; javax<span class="preprocessor">.crypto</span><span class="preprocessor">.interfaces</span>                            JDK internal API (jce<span class="preprocessor">.jar</span>)
      -&gt; javax<span class="preprocessor">.crypto</span><span class="preprocessor">.spec</span>                                  JDK internal API (jce<span class="preprocessor">.jar</span>)
</code></pre><h2 id="在linux上构建profile">在linux上构建profile</h2>
<pre><code>$ hg clone http://hg.openjdk.java.net/jdk8/jdk8/
$ cd jdk8
$ make images profiles : 
## Finished profiles (build time 00:00:27)
<span class="bullet">----- </span>Build times -------
Start 2013-03-17 14:47:35
End 2013-03-17 14:58:26
00:00:25 corba
00:00:15 demos
00:01:50 hotspot
00:00:24 images
00:00:21 jaxp
00:00:31 jaxws
00:05:37 jdk
00:00:43 langtools
00:00:18 nashorn
00:00:27 profiles
<span class="header">00:10:51 TOTAL
-------------------------</span>
Finished building Java(TM) for target <span class="emphasis">'images profiles'</span>
$ cd images
$ ls -d <span class="strong">*image
j2re-compact1-image j2re-compact2-image j2re-compact3-image j2re-image j2sdk-image</span>
</code></pre><h2 id="编译后compact大致的占用空间">编译后compact大致的占用空间</h2>
<p><img src="http://waakaakaa.qiniudn.com/002445_qWal_1028150.png" alt="image"></p>
<h2 id="总结-6">总结</h2>
<p>如今，物联网正风行一时。我们看到大量不同的设备在市场上出现，每一种的更新速度都越来越快。java需要一个占用资源少的JRE运行环境，紧凑的JRE特性的出现，希望能带来以后的物联网的发展，甚至还是会有大量的java应用程序出现在物联网上面。目前oracle也发布了针对raspberry pi的JRE了。</p>
<p>另外该特性也是为java9的模块化项目做准备，模块化特性是javaer所期待的特性。他是解决业务系统复杂度的一个利器，当然OSGI也是相当的出色。但osgi对于新学者来说未免太复杂了。</p>
<hr>
<h1 id="（九）跟OOM：Permgen说再见吧">（九）跟OOM：Permgen说再见吧</h1>
<p>很多开发者都在其系统中见过“java.lang.OutOfMemoryError: PermGen space”这一问题。这往往是由类加载器相关的内存泄漏以及新类加载器的创建导致的，通常出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，在产品中最常见的“问题”是默认值太低了。常用的解决方法是将其设置为256MB或更高。</p>
<h2 id="PermGen_space简单介绍">PermGen space简单介绍</h2>
<p>PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，说说为什么会内存益出：这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。</p>
<p>JVM 种类有很多，比如 Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM（淘宝好样的！）等等。当然武林盟主是Hotspot了，这个毫无争议。需要注意的是，PermGen space是Oracle-Sun Hotspot才有，JRockit以及J9是没有这个区域。</p>
<h2 id="元空间（MetaSpace）一种新的内存空间诞生">元空间（MetaSpace）一种新的内存空间诞生</h2>
<p>JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）；这与Oracle JRockit 和IBM JVM’s很相似，如下图所示</p>
<p><img src="http://waakaakaa.qiniudn.com/195605_gspc_1028150.png" alt="image"></p>
<p>这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用……但请等等，这么说还为时过早。在默认情况下，这些改变是透明的，接下来我们的展示将使你知道仍然要关注类元数据内存的占用。请一定要牢记，这个新特性也不能神奇地消除类和类加载器导致的内存泄漏。</p>
<p>java8中metaspace总结如下：</p>
<h2 id="PermGen_空间的状况">PermGen 空间的状况</h2>
<p>这部分内存空间将全部移除。</p>
<p>JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。</p>
<h2 id="Metaspace_内存分配模型">Metaspace 内存分配模型</h2>
<p>大部分类元数据都在本地内存中分配。</p>
<p>用于描述类元数据的“klasses”已经被移除。</p>
<h2 id="Metaspace_容量">Metaspace 容量</h2>
<p>默认情况下，类元数据只受可用的本地内存限制（容量取决于是32位或是64位操作系统的可用虚拟内存大小）。</p>
<p>新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。</p>
<h2 id="Metaspace_垃圾回收">Metaspace 垃圾回收</h2>
<p>对于僵死的类及类加载器的垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行。</p>
<p>适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。</p>
<h2 id="Java_堆内存的影响">Java 堆内存的影响</h2>
<p>一些杂项数据已经移到Java堆空间中。升级到JDK8之后，会发现Java堆 空间有所增长。</p>
<h2 id="Metaspace_监控">Metaspace 监控</h2>
<p>元空间的使用情况可以从HotSpot1.8的详细GC日志输出中得到。</p>
<p>Jstat 和 JVisualVM两个工具，在使用b75版本进行测试时，已经更新了，但是还是能看到老的PermGen空间的出现。</p>
<p>前面已经从理论上充分说明，下面让我们通过“泄漏”程序进行新内存空间的观察……</p>
<h2 id="PermGen_vs-_Metaspace_运行时比较">PermGen vs. Metaspace 运行时比较</h2>
<p>为了更好地理解Metaspace内存空间的运行时行为，</p>
<p>将进行以下几种场景的测试：</p>
<ol>
<li>使用JDK1.7运行Java程序，监控并耗尽默认设定的85MB大小的PermGen内存空间。</li>
<li>使用JDK1.8运行Java程序，监控新Metaspace内存空间的动态增长和垃圾回收过程。</li>
<li>使用JDK1.8运行Java程序，模拟耗尽通过“MaxMetaspaceSize”参数设定的128MB大小的Metaspace内存空间。</li>
</ol>
<p>首先建立了一个模拟PermGen OOM的代码</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ClassA {
 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(String name) {
  <span class="comment">// do nothing</span>
 }
}
</code></pre><p>上面是一个简单的ClassA，把他编译成class字节码放到D：/classes下面，测试代码中用URLClassLoader来加载此类型上面类编译成class</p>
<pre><code><span class="javadoc">/**
 * 模拟PermGen OOM
 *<span class="javadoctag"> @author</span> benhail
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">try</span> {
            <span class="comment">//准备url</span>
            URL url = <span class="keyword">new</span> File(<span class="string">"D:/classes"</span>).toURI().toURL();
            URL[] urls = {url};
            <span class="comment">//获取有关类型加载的JMX接口</span>
            ClassLoadingMXBean loadingBean = ManagementFactory.getClassLoadingMXBean();
            <span class="comment">//用于缓存类加载器</span>
            List&lt;ClassLoader&gt; classLoaders = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();
            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                <span class="comment">//加载类型并缓存类加载器实例</span>
                ClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);
                classLoaders.add(classLoader);
                classLoader.loadClass(<span class="string">"ClassA"</span>);
                <span class="comment">//显示数量信息（共加载过的类型数目，当前还有效的类型数目，已经被卸载的类型数目）</span>
                System.out.println(<span class="string">"total: "</span> + loadingBean.getTotalLoadedClassCount());
                System.out.println(<span class="string">"active: "</span> + loadingBean.getLoadedClassCount());
                System.out.println(<span class="string">"unloaded: "</span> + loadingBean.getUnloadedClassCount());
            }
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>虚拟机器参数设置如下：-verbose -verbose:gc</p>
<p>设置-verbose参数是为了获取类型加载和卸载的信息</p>
<p>设置-verbose:gc是为了获取垃圾收集的相关信息</p>
<h2 id="JDK_1-7_@64-bit_–_PermGen_耗尽测试">JDK 1.7 @64-bit – PermGen 耗尽测试</h2>
<p>Java1.7的PermGen默认空间为85 MB（或者可以通过-XX:MaxPermSize=XXXm指定）</p>
<p><img src="http://waakaakaa.qiniudn.com/200026_JwJP_1028150.jpg" alt="image"></p>
<p>可以从上面的JVisualVM的截图看出：当加载超过6万个类之后，PermGen被耗尽。我们也能通过程序和GC的输出观察耗尽的过程。</p>
<p>程序输出(摘取了部分)</p>
<pre><code>......
[Loaded ClassA from file:/<span class="keyword">D</span>:/classes/]
total: <span class="number">64887</span>
active: <span class="number">64887</span>
unloaded: <span class="number">0</span>
[GC <span class="number">245041</span><span class="keyword">K</span>-&gt;<span class="number">213978</span><span class="keyword">K</span>(<span class="number">536768</span><span class="keyword">K</span>), <span class="number">0.0597188</span> secs]
[<span class="keyword">Full</span> GC <span class="number">213978</span><span class="keyword">K</span>-&gt;<span class="number">211425</span><span class="keyword">K</span>(<span class="number">644992</span><span class="keyword">K</span>), <span class="number">0.6456638</span> secs]
[GC <span class="number">211425</span><span class="keyword">K</span>-&gt;<span class="number">211425</span><span class="keyword">K</span>(<span class="number">656448</span><span class="keyword">K</span>), <span class="number">0.0086696</span> secs]
[<span class="keyword">Full</span> GC <span class="number">211425</span><span class="keyword">K</span>-&gt;<span class="number">211411</span><span class="keyword">K</span>(<span class="number">731008</span><span class="keyword">K</span>), <span class="number">0.6924754</span> secs]
[GC <span class="number">211411</span><span class="keyword">K</span>-&gt;<span class="number">211411</span><span class="keyword">K</span>(<span class="number">726528</span><span class="keyword">K</span>), <span class="number">0.0088992</span> secs]
...............
java.lang.OutOfMemoryError: PermGen space
</code></pre><h2 id="JDK_1-8_@64-bit_–_Metaspace大小动态调整测试">JDK 1.8 @64-bit – Metaspace大小动态调整测试</h2>
<p>Java的Metaspace空间：不受限制 （默认）</p>
<p><img src="http://waakaakaa.qiniudn.com/195610_E1X2_1028150.png" alt="image"></p>
<p>从上面的截图可以看到，JVM Metaspace进行了动态扩展，本地内存的使用由20MB增长到646MB，以满足程序中不断增长的类数据内存占用需求。我们也能观察到JVM的垃圾回收事件—试图销毁僵死的类或类加载器对象。但是，由于我们程序的泄漏，JVM别无选择只能动态扩展Metaspace内存空间。程序加载超过10万个类，而没有出现OOM事件。</p>
<h2 id="JDK_1-8_@64-bit_–_Metaspace_受限测试">JDK 1.8 @64-bit – Metaspace 受限测试</h2>
<p>Java的Metaspace空间：128MB（-XX:MaxMetaspaceSize=128m）</p>
<p><img src="http://waakaakaa.qiniudn.com/195611_JlBi_1028150.png" alt="image"></p>
<p>可以从上面的JVisualVM的截图看出：当加载超过2万个类之后，Metaspace被耗尽；与JDK1.7运行时非常相似。我们也能通过程序和GC的输出观察耗尽的过程。另一个有趣的现象是，保留的原生内存占用量是设定的最大大小两倍之多。这可能表明，如果可能的话，可微调元空间容量大小策略，来避免本地内存的浪费。</p>
<p>从Java程序的输出中看到如下异常。</p>
<pre><code>[Loaded ClassA from file:/<span class="keyword">D</span>:/classes/]
total: <span class="number">21393</span>
active: <span class="number">21393</span>
unloaded: <span class="number">0</span>
[GC (Metadata GC <span class="keyword">Threshold</span>) <span class="number">64306</span><span class="keyword">K</span>-&gt;<span class="number">57010</span><span class="keyword">K</span>(<span class="number">111616</span><span class="keyword">K</span>), <span class="number">0.0145502</span> secs]
[<span class="keyword">Full</span> GC (Metadata GC <span class="keyword">Threshold</span>) <span class="number">57010</span><span class="keyword">K</span>-&gt;<span class="number">56810</span><span class="keyword">K</span>(<span class="number">122368</span><span class="keyword">K</span>), <span class="number">0.1068084</span> secs]
java.lang.OutOfMemoryError: Metaspace
</code></pre><p>在设置了MaxMetaspaceSize的情况下，该空间的内存仍然会耗尽，进而引发“java.lang.OutOfMemoryError: Metadata space”错误。因为类加载器的泄漏仍然存在，而通常Java又不希望无限制地消耗本机内存，因此设置一个类似于MaxPermSize的限制看起来也是合理的。</p>
<h2 id="总结-7">总结</h2>
<ol>
<li>之前不管是不是需要，JVM都会吃掉那块空间……如果设置得太小，JVM会死掉；如果设置得太大，这块内存就被JVM浪费了。理论上说，现在你完全可以不关注这个，因为JVM会在运行时自动调校为“合适的大小”；</li>
<li>提高Full GC的性能，在Full GC期间，Metadata到Metadata pointers之间不需要扫描了，别小看这几纳秒时间；</li>
<li>隐患就是如果程序存在内存泄露，像OOMTest那样，不停的扩展metaspace的空间，会导致机器的内存不足，所以还是要有必要的调试和监控。</li>
</ol>
<hr>
<h1 id="（十）StampedLock将是解决同步问题的新宠">（十）StampedLock将是解决同步问题的新宠</h1>
<p>Java8就像一个宝藏，一个小的API改进，也足与写一篇文章，比如同步，一直是多线程并发编程的一个老话题，相信没有人喜欢同步的代码，这会降低应用的吞吐量等性能指标，最坏的时候会挂起死机，但是即使这样你也没得选择，因为要保证信息的正确性。所以本文决定将从synchronized、Lock到Java8新增的StampedLock进行对比分析，相信StampedLock不会让大家失望。</p>
<h2 id="synchronized">synchronized</h2>
<p>在java5之前，实现同步主要是使用synchronized。它是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p>有四种不同的同步块：</p>
<ol>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ol>
<p>大家对此应该不陌生，所以不多讲了，以下是代码示例</p>
<pre><code><span class="keyword">synchronized</span>(<span class="keyword">this</span>)
<span class="comment">// do operation</span>
}
</code></pre><p>小结：在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，性能上也有所提升。</p>
<h2 id="Lock">Lock</h2>
<p>它是Java 5在java.util.concurrent.locks新增的一个API。</p>
<p>Lock是一个接口，核心方法是lock()，unlock()，tryLock()，实现类有ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock；</p>
<p>ReentrantReadWriteLock, ReentrantLock 和synchronized锁都有相同的内存语义。</p>
<p>与synchronized不同的是，Lock完全用Java写成，在java这个层面是无关JVM实现的。Lock提供更灵活的锁机制，很多synchronized 没有提供的许多特性，比如锁投票，定时锁等候和中断锁等候，但因为lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</p>
<p>下面是Lock的一个代码示例</p>
<pre><code>rwlock.writeLock().<span class="keyword">lock</span>();
<span class="keyword">try</span> {
<span class="comment">// do operation</span>
} <span class="keyword">finally</span> {
rwlock.writeLock().unlock();
}
</code></pre><p>小结：比synchronized更灵活、更具可伸缩性的锁定机制，但不管怎么说还是synchronized代码要更容易书写些</p>
<h2 id="StampedLock">StampedLock</h2>
<p>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<p>下面是java doc提供的StampedLock一个例子</p>
<pre><code>class Point {
   <span class="keyword">private</span> <span class="keyword">double</span> x, y;
   <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();
   <span class="keyword">void</span> move(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY) { <span class="comment">// an exclusively locked method</span>
     <span class="keyword">long</span> stamp = sl.writeLock();
     <span class="keyword">try</span> {
       x += deltaX;
       y += deltaY;
     } <span class="keyword">finally</span> {
       sl.unlockWrite(stamp);
     }
   }
  <span class="comment">//下面看看乐观读锁案例</span>
   <span class="keyword">double</span> distanceFromOrigin() { <span class="comment">// A read-only method</span>
     <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span>
     <span class="keyword">double</span> currentX = x, currentY = y; <span class="comment">//将两个字段读入本地局部变量</span>
     <span class="keyword">if</span> (!sl.validate(stamp)) { <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span>
        stamp = sl.readLock(); <span class="comment">//如果没有，我们再次获得一个读悲观锁</span>
        <span class="keyword">try</span> {
          currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span>
          currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span>
        } <span class="keyword">finally</span> {
           sl.unlockRead(stamp);
        }
     }
     <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);
   }
<span class="comment">//下面是悲观读锁案例</span>
   <span class="keyword">void</span> moveIfAtOrigin(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY) { <span class="comment">// upgrade</span>
     <span class="comment">// Could instead start with optimistic, not read mode</span>
     <span class="keyword">long</span> stamp = sl.readLock();
     <span class="keyword">try</span> {
       <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) { <span class="comment">//循环，检查当前状态是否符合</span>
         <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span>
         <span class="keyword">if</span> (ws != <span class="number">0</span>L) { <span class="comment">//这是确认转为写锁是否成功</span>
           stamp = ws; <span class="comment">//如果成功 替换票据</span>
           x = newX; <span class="comment">//进行状态改变</span>
           y = newY; <span class="comment">//进行状态改变</span>
           <span class="keyword">break</span>;
         }
         <span class="keyword">else</span> { <span class="comment">//如果不能成功转换为写锁</span>
           sl.unlockRead(stamp); <span class="comment">//我们显式释放读锁</span>
           stamp = sl.writeLock(); <span class="comment">//显式直接进行写锁 然后再通过循环再试</span>
         }
       }
     } <span class="keyword">finally</span> {
       sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span>
     }
   }
 }
</code></pre><p>小结：</p>
<p>StampedLock要比ReentrantReadWriteLock更加廉价，也就是消耗比较小。</p>
<h2 id="StampedLock与ReadWriteLock性能对比">StampedLock与ReadWriteLock性能对比</h2>
<p>下图是和ReadWritLock相比，在一个线程情况下，是读速度其4倍左右，写是1倍。</p>
<p><img src="http://waakaakaa.qiniudn.com/203230_Xwbp_1028150.png" alt="image"></p>
<p>下图是六个线程情况下，读性能是其几十倍，写性能也是近10倍左右：</p>
<p><img src="http://waakaakaa.qiniudn.com/203230_HPwL_1028150.png" alt="image"></p>
<p>下图是吞吐量提高：</p>
<p><img src="http://waakaakaa.qiniudn.com/203230_jw39_1028150.png" alt="image"></p>
<h2 id="总结-8">总结</h2>
<ol>
<li>synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定；</li>
<li>ReentrantLock、ReentrantReadWriteLock,、StampedLock都是对象层面的锁定，要保证锁定一定会被释放，就必须将unLock()放到finally{}中；</li>
<li>StampedLock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下；</li>
<li>StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法;</li>
<li>当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现;</li>
<li>当线程增长能够预估，ReentrantLock是一个很好的通用的锁实现;</li>
</ol>
<p>StampedLock 可以说是Lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前Lock的东西，毕竟他还是有些应用场景的，起码API比StampedLock容易入手，下篇博文争取更新快一点，可能会是Nashorn的内容，这里允许我先卖个关子。。。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/15/图解git/">
  <time datetime="2014-05-15T03:34:41.000Z">
    5月 15 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/15/图解git/">图解Git</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>再次感谢原著作者和中文翻译者。</p>
<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。 如果你想知道这个站点怎样产生，请前往<a href="http://github.com/MarkLodato/visual-git-guide" target="_blank">GitHub repository</a>。</p>
<h1 id="正文">正文</h1>
<ol>
<li>基本用法</li>
<li>约定</li>
<li>命令详解<ol>
<li>Diff</li>
<li>Commit</li>
<li>Checkout</li>
<li>Detached HEAD(匿名分支提交)</li>
<li>Reset</li>
<li>Merge</li>
<li>Cherry Pick</li>
<li>Rebase</li>
</ol>
</li>
<li>技术说明</li>
</ol>
<h1 id="基本用法">基本用法</h1>
<p><img src="http://waakaakaa.qiniudn.com/18023901_1rGz.png" alt="image"></p>
<p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p>
<ul>
<li>git add files把当前文件放入暂存区域。</li>
<li>git commit给暂存区域生成快照并提交。</li>
<li>git reset — files用来撤销最后一次git add files，你也可以用git reset撤销所有暂存区域文件。</li>
<li>git checkout — files把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li>
</ul>
<p>你可以用git reset -p,git checkout -p, orgit add -p进入交互模式。</p>
<p>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023902_v1l1.png" alt="image"></p>
<ul>
<li>git commit -a相当于运行git add把所有当前目录下的文件加入暂存区域再运行。git commit.</li>
<li>git commit files进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。</li>
<li>git checkout HEAD — files回滚到复制最后一次提交。</li>
</ul>
<h1 id="约定">约定</h1>
<p>后文中以下面的形式使用图片。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023902_HPS4.png" alt="image"></p>
<p>绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的HEAD标识。 这张图片里显示最后5次提交，ed489是最新提交。 master分支指向此次提交，另一个maint分支指向祖父提交节点。</p>
<h1 id="命令详解">命令详解</h1>
<h2 id="Diff">Diff</h2>
<p>有许多种方法查看两次提交之间的变动。下面是一些示例。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023903_Kah8.png" alt="image"></p>
<h2 id="Commit">Commit</h2>
<p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是master。 在运行命令之前，master指向ed489，提交后，master指向新的节点f0cec并以ed489作为父节点。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023903_WAeN.png" alt="image"></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在master分支的祖父节点maint分支进行一次提交，生成了1800b。 这样，maint分支就不再是master分支的祖父节点。此时，合并 (或者 衍合) 是必须的。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023904_3rQl.png" alt="image"></p>
<p>如果想更改一次提交，使用git commit —amend。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023905_JkJm.png" alt="image"></p>
<p>另一个例子是分离HEAD提交,后文讲。</p>
<h2 id="Checkout">Checkout</h2>
<p>checkout命令通常用来从仓库中取出文件，或者在分支中切换。</p>
<p>checkout命令让git把文件复制到工作目录和暂存区域。比如git checkout HEAD~ foo.c把文件从foo.c提交节点HEAD~ (当前提交节点的父节点)复制到工作目录并且生成索引。注意当前分支没有变化。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023906_48sQ.png" alt="image"></p>
<p>如果没有指定文件名，而是一个本地分支，那么将切换到那个分支去。同时把索引和工作目录切换到那个分支对应的状态。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023906_agrc.png" alt="image"></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像master~3类似的东西，就得到一个匿名分支，称作detached HEAD。 这样可以很方便的在历史版本之间互相切换。但是，这样的提交是完全不同的，详细的在下面。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023907_KKbG.png" alt="image"></p>
<h2 id="用分离HEAD提交(找不到好的译法)">用分离HEAD提交(找不到好的译法)</h2>
<p>HEAD是分离的时候, 提交可以正常进行, 但是没有更新已命名的分支. 。(可以看作是匿名分支。)</p>
<p><img src="http://waakaakaa.qiniudn.com/18023907_CMC3.png" alt="image"></p>
<p>如果此时切换到别的分支，那么所作的工作会全部丢失。注意这个命令之后就不存在2eecb了。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023908_WUnd.png" alt="image"></p>
<p>如果你想保存当前的状态，可以用这个命令创建一个新的分支:git checkout -b name。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023908_e0uN.png" alt="image"></p>
<h2 id="Reset">Reset</h2>
<p>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用—hard选项，那么工作目录也更新，如果用—soft选项，那么都不变。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023908_soI2.png" alt="image"></p>
<p>如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用—hard选项，工作目录也同样。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023909_0BSY.png" alt="image"></p>
<p>如果给了文件名(或者-p选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023909_66sM.png" alt="image"></p>
<h2 id="Merge">Merge</h2>
<p>merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致fast-forward合并。指向只是简单的移动，并生成一个新的提交。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023909_onFU.png" alt="image"></p>
<p>否则就是一次真正的合并。默认把当前提交(ed489 如下所示)和另一个提交(33104)以及他们的共同祖父节点(b325c)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点33104一起做一次新提交。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023910_3Ok3.png" alt="image"></p>
<h2 id="Cherry_Pick">Cherry Pick</h2>
<p>cherry-pick命令”复制”一个提交节点并在当前复制做一次完全一样的新提交。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023910_xwgB.png" alt="image"></p>
<h2 id="Rebase">Rebase</h2>
<p>衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick</p>
<p><img src="http://waakaakaa.qiniudn.com/18023912_larL.png" alt="image"></p>
<p>上面的命令都在topic分支中进行，而不是master分支，在master分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p>
<p>要限制回滚范围，使用—onto选项。下面的命令在master分支上重演当前分支从169a6以来的最近几个提交，即2c33a。</p>
<p><img src="http://waakaakaa.qiniudn.com/18023912_4hux.png" alt="image"></p>
<p>同样有git rebase —interactive让你更方便的完成一些复杂操组，比如丢弃、重排、修改、合并提交。没有图片体现着下，细节看这里:git-rebase(1)</p>
<h1 id="技术说明">技术说明</h1>
<p>文件内容并没有真正存储在索引(.git/index)或者提交对象中，而是以blob的形式分别存储在数据库中(.git/objects)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(tree)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p>
<p>如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与git commit —amend或者git rebase很像。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/15/sql-中不同类型的表连接/">
  <time datetime="2014-05-15T03:15:40.000Z">
    5月 15 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/15/sql-中不同类型的表连接/">SQL 中不同类型的表连接</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>1、简介</strong></p>
<p>在关系型数据库中，join操作是将不同的表中的数据联合在一起时非常通用的一种做法。首先让我们看看join是如何操作的，然后我们探索一下当join和where语句同时存在的时候的执行顺序问题，最后来谈一谈不同类型的join的顺序问题。</p>
<p><strong>2、建立初始的测试表结构（<a href="http://www.codeproject.com/Articles/435694/Understanding-Table-Joins-using-SQL" target="_blank">建表语句到这里下载</a>）</strong></p>
<p>表建立完之后，将会看到如下三个表。</p>
<p><img src="http://waakaakaa.qiniudn.com/103306_e9CO_82993.jpg" alt="image"></p>
<p>我们将通过以上三个表来演示join操作。这三个表都是用来做演示的，所以我并没有使用主键和外键。</p>
<p><strong>3、表的笛卡尔乘积</strong></p>
<p>一般情况下，我们使用两个表中的相关字段进行join操作，例如，employee表中的DeptId字段对应于Department表中的DepId字段，通过这种方式进行join。</p>
<p>下面的一个例子是不使用关联字段来做表的连接。这里TableA和TableB以笛卡尔乘积的方式连在了一起。笛卡尔乘积就是先从第一个表中取出一条记录，和第二章表中的每一条记录配合，然后再取出第二条记录，同样和第二张表的所有记录配合，直至第一张表中的所有记录都取完。所以最终的结果数量将是两张表的乘积。</p>
<p><img src="http://waakaakaa.qiniudn.com/103407_CPoq_82993.jpg" alt="image"></p>
<p><strong>4、join两张表</strong></p>
<p>当我们想做两个表的连接，而不是像上面的例子一样得到大量的无用的结果的时候，我们就得从两张表中选取一个join列。我下面给出的例子是使用id作为join列的。我们可以通过这种方式使得结果只映射我们需要的那一部分，从而过滤掉了无用数据。</p>
<p><img src="http://waakaakaa.qiniudn.com/103435_FDRs_82993.jpg" alt="image"></p>
<p>注意：在笛卡尔乘积表中的第一行和第五行满足了join的映射关系，从而被作为结果，其他的都被过滤掉了。</p>
<p><strong>5、join多张表</strong></p>
<p>上面的例子是join两张表，如果想join多张表，我们需要在上面的结果中选择一列，然后再在新表中选择一列，将这两者作为join字段，然后指定join的规则，这样我们理论上可以join任意多张表。</p>
<p><img src="http://waakaakaa.qiniudn.com/103524_uGSe_82993.jpg" alt="image"></p>
<p>首先，Table_A和Table_B做了连接，就上上面的join两张表的例子，然后将join的结果作为一张表AB。再将AB与Table_C连接。</p>
<p><img src="http://waakaakaa.qiniudn.com/103553_ofCc_82993.jpg" alt="image"></p>
<p><strong>6、join类型</strong></p>
<p>在两张不同的表做连接有3中join类型。</p>
<ol>
<li>full join</li>
<li>inner join</li>
<li>outer join(left outer join、right outer join)</li>
</ol>
<p>在上面两个例子中我们看到的是inner join。如果我们连接表自身就叫做self join。这个特殊类型不会混淆连接类型。</p>
<p><strong>7、full join</strong></p>
<p>full join和笛卡尔有些不同，笛卡尔积会获取所有可能的结果。而full join将匹配的结果与所有左边的表中不匹配右边的行和右边的表中所有不匹配左边的行加在一起，在不匹配的地方使用NULL代替。结果行数=匹配行数+左表剩余行数+右表剩余行数。</p>
<p><img src="http://waakaakaa.qiniudn.com/103707_a5Lt_82993.jpg" alt="image"></p>
<p><img src="http://waakaakaa.qiniudn.com/103715_XlOu_82993.jpg" alt="image"></p>
<p>在上面的图片中，蓝色的行是两个表匹配的行。</p>
<p>第二行，左边绿色，右边红色的是不匹配的，左表中的行是存在的，而右表中的字段则被null填充。</p>
<p>第三行，左边红色，右边绿色的同样是不匹配的，右表中的行是存在的，而左表中的字段则被null填充。</p>
<p><strong>8、left join</strong></p>
<p>左连接（left join）保证左表中的所有行都有，而当不匹配的时候以NULL填充右表字段。</p>
<p><img src="http://waakaakaa.qiniudn.com/103812_omnc_82993.jpg" alt="image"></p>
<p>蓝色匹配，红色和绿色不匹配</p>
<p><strong>9、right join</strong></p>
<p>反过来，右连接（right join）保证右表中所有的行都有，而当不匹配的时候以NULL填充左表字段。</p>
<p><img src="http://waakaakaa.qiniudn.com/103918_9ZGB_82993.jpg" alt="image"></p>
<p>蓝色匹配，红色和绿色不匹配</p>
<p><strong>10、inner join</strong></p>
<p>inner join就是只列出匹配的行。</p>
<p><strong>11、self join</strong></p>
<p>表连接自身叫做self join。为了解释一下这个让我们看如下图中的employee表。EmployeeID是此表的主键，ReportsTo引用了此表的主键。我们可以想象成这样，ReportTo字段引用代表该雇员的上司，其上司同样也是雇员。</p>
<p><img src="http://waakaakaa.qiniudn.com/104034_6UfA_82993.jpg" alt="image"></p>
<p>看如下例子</p>
<p>这里，有ReportTo指向的行是Manager，所以employee是左表，Manager是右表。</p>
<p><strong>12、执行顺序</strong></p>
<p>当连接中有where语句的时候我们需要注意连接和where的执行顺序问题。</p>
<ol>
<li>将where语句先于join执行，因为执行完where查询的结果将会比较少，从而join操作性能会提升。</li>
<li>将where语句后与join执行。</li>
</ol>
<p>以上两者将在inner join的时候返回同样的结果，但是当使用outer join的时候至少有一种连接操作的返回结果不同。看下面例子。</p>
<p><img src="http://waakaakaa.qiniudn.com/104203_qlXI_82993.jpg" alt="image"></p>
<p><img src="http://waakaakaa.qiniudn.com/104332_G4d9_82993.jpg" alt="image"></p>
<p><img src="http://waakaakaa.qiniudn.com/104345_t1jS_82993.jpg" alt="image"></p>
<p>所以记住当外连接的时候尽量先执行join操作然后执行where语句。</p>
<p><strong>13、连接的顺序</strong></p>
<p>当你想将inner join和outer join同时使用的时候join的顺序也是非常重要的。</p>
<p>什么是连接的顺序？如果我像这样连接三张表【X inner Y】left Z，顺序就是先inner join再left join。</p>
<p>让我们回到上面的例子中，你想得到的结果是获取所有客户的名字，不管他们是否有订单。如果他们确实有一些订单，还要列出了客户订购的数量。</p>
<p>看如下的查询【先outer join再inner join】</p>
<p><img src="http://waakaakaa.qiniudn.com/104419_CpoO_82993.jpg" alt="image"></p>
<ol>
<li>在Orders和Customers中进行了right join。右连接能保证你获取所有Customer的信息，不管他是否有order。</li>
<li>现在上面的结果将和Order Details连接。但是我们需要注意的是，在右连接的结果中有两行roderid为null的，因为这两个customer并没有任何order，而在后面做inner join的时候，由于orderid为null，inner join将跳过这两行，从而导致这两个customer的信息被过滤掉了。<br>再让我们看看下面的这个查询【先inner join再outer join】</li>
</ol>
<p><img src="http://waakaakaa.qiniudn.com/104459_m47U_82993.jpg" alt="image"></p>
<p>让我们分析一下为什么这才是我们想要的结果。</p>
<p>首先Order和Order Details表做inner join，所有匹配的结果都将被列出来，然后将此结果作为左表，Customer表作为右表，右表的所有行都将被列出来，不管其匹配与否（言外之意，那两个没有order的customer也将被列出来）。</p>
<p>所以，在我们同时使用inner join和outer join的时候一定要对连接的顺序做慎重考虑。</p>
<p><strong>14、获取同样数据的其他办法</strong></p>
<p>看如下查询</p>
<p><img src="http://waakaakaa.qiniudn.com/104551_IGzJ_82993.jpg" alt="image"></p>
<ol>
<li>首先查询出Customers将其作为左表</li>
<li>然后将Orders表查询出来，仍然作为左表</li>
<li>然后查询出Order Details表将其作为右表与Orders表进行inner join。</li>
<li>最后Customers表将于第三步查询出的结果进行左连接。别忘了左连接将保证Customers表不丢失任何记录。</li>
</ol>
<p><a href="http://oschina.net/" target="_blank">OSChina.NET</a>原创翻译/<a href="http://www.codeproject.com/Articles/435694/Understanding-Table-Joins-using-SQL" target="_blank">原文链接</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/15/检查和收集-linux-硬件信息的-7-个命令/">
  <time datetime="2014-05-15T02:25:27.000Z">
    5月 15 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/15/检查和收集-linux-硬件信息的-7-个命令/">检查和收集 Linux 硬件信息的 7 个命令</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>英文原文：<a href="http://www.itsprite.com/linux-7-linux-commands-to-checkgather-hardware-information-in-linux-system/" target="_blank">7 Linux commands to check/gather hardware information in linux system</a></p>
<p>在Linux系统中，有许多命令可用于查询主机的硬件信息。一些命令只针对特定的硬件组件，比如CPU、内存，一些命令可以查询多个硬件信息。</p>
<p>这篇文章只是简单的让每个人了解查询硬件信息的基本命令使用，包括lscpu、hwinfo、lshw、lspci、lsblk、lsusb等等。</p>
<p><strong>1. lscpu用于查询CPU信息</strong></p>
<pre><code>[root@devops ~]# lscpu
Architecture:          x86_64
CPU op-mode(s):        <span class="number">32</span>-bit, <span class="number">64</span>-bit
<span class="keyword">Byte</span> <span class="keyword">Order</span>:            Little Endian
CPU(s):                <span class="number">1</span>
<span class="keyword">On</span>-line CPU(s) list:   <span class="number">0</span>
<span class="keyword">Thread</span>(s) per core:    <span class="number">1</span>
Core(s) per socket:    <span class="number">1</span>
CPU socket(s):         <span class="number">1</span>
NUMA node(s):          <span class="number">1</span>
Vendor ID:             GenuineIntel
CPU family:            <span class="number">6</span>
Model:                 <span class="number">45</span>
Stepping:              <span class="number">7</span>
CPU MHz:               <span class="number">2194.842</span>
BogoMIPS:              <span class="number">4389.68</span>
Hypervisor vendor:     Xen
Virtualization type:   full
L1d cache:             <span class="number">32</span><span class="keyword">K</span>
L1i cache:             <span class="number">32</span><span class="keyword">K</span>
L2 cache:              <span class="number">256</span><span class="keyword">K</span>
L3 cache:              <span class="number">15360</span><span class="keyword">K</span>
NUMA node0 CPU(s):     <span class="number">0</span>
</code></pre><p><strong>2. lshw显示硬件信息表</strong></p>
<p>这个命令应用普遍，它可通过个人需求而列出多种不同的硬件参数：CPU、内存、硬盘、USB控制器、lshw卡片等等，本质上就是从/proc目录不同文件中中提取对应的硬件信息。</p>
<p>按照下面的步骤去安装lshw工具，然后就可以使用了。</p>
<pre><code> wget http://ezix<span class="preprocessor">.org</span>/software/files/lshw-B<span class="number">.02</span><span class="number">.14</span><span class="preprocessor">.tar</span><span class="preprocessor">.gz</span>
 tar -zxvf lshw-B<span class="number">.02</span><span class="number">.14</span><span class="preprocessor">.tar</span><span class="preprocessor">.gz</span>
 cd lshw-B<span class="number">.02</span><span class="number">.14</span>
 make &amp;&amp; make install
</code></pre><p>示例：</p>
<pre><code>[root<span class="variable">@devops</span> lshw-B<span class="number">.02</span><span class="number">.14</span>]# lshw -short
H/W path          Device       Class      Description
=====================================================
                               <span class="keyword">system</span>     HVM domU
/<span class="number">0</span>                             bus        Motherboard
/<span class="number">0</span>/<span class="number">0</span>                           <span class="keyword">memory</span>     <span class="number">96</span>KiB BIOS
/<span class="number">0</span>/<span class="number">1</span>                           processor  Intel(R) Xeon(R) CPU E5-<span class="number">2430</span> <span class="number">0</span> @ <span class="number">2.20</span>GHz
/<span class="number">0</span>/<span class="number">2</span>                           <span class="keyword">memory</span>     System Memory
/<span class="number">0</span>/<span class="number">2</span>/<span class="number">0</span>                         <span class="keyword">memory</span>     <span class="number">512</span>MiB DIMM RAM
/<span class="number">0</span>/<span class="number">2</span>/<span class="number">1</span>                         <span class="keyword">memory</span>     <span class="number">512</span>MiB DIMM RAM
/<span class="number">0</span>/<span class="number">3</span>                           <span class="keyword">memory</span>     <span class="number">96</span>KiB BIOS
/<span class="number">0</span>/<span class="number">4</span>                           processor  CPU
/<span class="number">0</span>/<span class="number">5</span>                           <span class="keyword">memory</span>     System Memory
/<span class="number">0</span>/<span class="number">6</span>                           <span class="keyword">memory</span>     
/<span class="number">0</span>/<span class="number">7</span>                           <span class="keyword">memory</span>     
/<span class="number">0</span>/<span class="number">100</span>                         bridge     <span class="number">440</span>FX - <span class="number">82441</span>FX PMC [Natoma]
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1</span>                       bridge     <span class="number">82371</span>SB PIIX3 ISA [Natoma/Triton II]
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.1</span>        scsi1        storage    <span class="number">82371</span>SB PIIX3 IDE [Natoma/Triton II]
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.1</span>/<span class="number">0.0</span><span class="number">.0</span>  /dev/cdrom1  disk       SCSI CD-ROM
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.2</span>                     bus        <span class="number">82371</span>SB PIIX3 USB [Natoma/Triton II]
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.2</span>/<span class="number">1</span>      usb1         bus        UHCI Host Controller
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.2</span>/<span class="number">1</span>/<span class="number">2</span>                 input      QEMU USB Tablet
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">1.3</span>                     bridge     <span class="number">82371</span>AB/EB/MB PIIX4 ACPI
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">2</span>                       display    GD <span class="number">5446</span>
/<span class="number">0</span>/<span class="number">100</span>/<span class="number">3</span>                       generic    Xen Platform Device
/<span class="number">1</span>                eth0         network    Ethernet interface
/<span class="number">2</span>                eth1         network    Ethernet interface
[root<span class="variable">@devops</span> lshw-B<span class="number">.02</span><span class="number">.14</span>]#
</code></pre><p><strong>3. hwinfo-硬件信息</strong></p>
<p>hwinfo类似于lshw，也能查询硬件信息，且应用广泛。它也能输出多个硬件部分的详细或者简要信息，但是不同的是有时hwinfo比lshw的信息更详细。</p>
<p>默认情况下，Linux系统没有安装hwinfo工具，所以你需要按照以下步骤自己安装：</p>
<p><strong>CentOS 6</strong></p>
<pre><code><span class="preprocessor">#rpm -Uvh http://mirror.symnds.com/distributions/gf/el/6/gf/x86_64/gf-release-6-6.gf.el6.noarch.rpm</span>
<span class="preprocessor">#yum list hwinfo</span>
<span class="preprocessor">#yum install hwinfo</span>
</code></pre><p><strong>CentOS 5</strong></p>
<pre><code><span class="preprocessor">#rpm -Uvh http://mirror.symnds.com/distributions/gf/el/5/gf/x86_64/gf-release-5-6.gf.el5.noarch.rpm</span>
<span class="preprocessor">#yum list hwinfo</span>
<span class="preprocessor">#yum install hwinfo</span>

[root@devops tmp]<span class="preprocessor"># rpm -Uvh http://mirror.symnds.com/distributions/gf/el/6/gf/x86_64/gf-release-6-6.gf.el6.noarch.rpm</span>
Retrieving http://mirror<span class="preprocessor">.symnds</span><span class="preprocessor">.com</span>/distributions/gf/el/<span class="number">6</span>/gf/x86_64/gf-release-<span class="number">6</span>-<span class="number">6.</span>gf<span class="preprocessor">.el</span>6<span class="preprocessor">.noarch</span><span class="preprocessor">.rpm</span>
<span class="label">warning:</span> /var/tmp/rpm-tmp<span class="preprocessor">.m</span>2mMAO: Header V4 RSA/SHA1 Signature, key ID <span class="number">13</span>a4d2a9: NOKEY
Preparing...                <span class="preprocessor">########################################### [100%]</span>
   <span class="number">1</span>:gf-release             <span class="preprocessor">########################################### [100%]</span>
[root@devops tmp]<span class="preprocessor"># yum list hwinfo</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * extras: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * updates: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
gf                                                                                                    

 <span class="number">00</span>:<span class="number">00</span>     
gf/primary_db                                                                                     

 <span class="number">00</span>:<span class="number">00</span>     
Available Packages
hwinfo<span class="preprocessor">.x</span>86_64
[root@devops tmp]<span class="preprocessor"># yum list hwinfo</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * extras: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * updates: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
gf                                                                                                   

 <span class="number">00</span>:<span class="number">00</span>     
gf/primary_db                                                                                          

 <span class="number">00</span>:<span class="number">00</span>     
Available Packages
hwinfo<span class="preprocessor">.x</span>86_64                                                <span class="number">20.2</span>-<span class="number">1.</span>gf<span class="preprocessor">.el</span>6
</code></pre><p>示例：</p>
<pre><code>[root@devops tmp]<span class="preprocessor"># hwinfo -short</span>
<span class="label">oops:</span> don&amp;<span class="preprocessor">#039;t know what to do with "short"</span>
[root@devops tmp]<span class="preprocessor"># hwinfo --short</span>
<span class="label">cpu:</span>                                                            
                       Intel(R) Xeon(R) CPU E5-<span class="number">2430</span> <span class="number">0</span> @ <span class="number">2.20</span>GHz, <span class="number">2194</span> MHz
<span class="label">keyboard:</span>
  /dev/input/event3    AT Translated <span class="keyword">Set</span> <span class="number">2</span> keyboard
  /dev/ttyS0           serial console
<span class="label">mouse:</span>
  /dev/input/mice      Adomax QEMU USB Tablet
  /dev/input/mice      Macintosh mouse button emulation
  /dev/input/mice      ImExPS/<span class="number">2</span> Generic Explorer Mouse
graphics card:
                       Cirrus Logic GD <span class="number">5446</span>
<span class="label">storage:</span>
                       Intel <span class="number">82371</span>SB PIIX3 IDE [Natoma/Triton II]
                       Xen Virtual Storage <span class="number">0</span>
                       Xen Virtual Storage <span class="number">1</span>
                       Xen Virtual Storage <span class="number">2</span>
<span class="label">network:</span>
  eth0                 Xen Virtual Ethernet Card <span class="number">0</span>
  eth1                 Xen Virtual Ethernet Card <span class="number">1</span>
network interface:
  lo                   Loopback network interface
  eth0                 Ethernet network interface
  eth1                 Ethernet network interface
<span class="label">disk:</span>
  /dev/xvda            Disk
  /dev/xvdb            Disk
<span class="label">partition:</span>
  /dev/xvda1           Partition
  /dev/xvdb1           Partition
<span class="label">cdrom:</span>
  /dev/sr0             QEMU DVD-ROM
usb controller:
                       Qumranet Qemu virtual machine
<span class="label">bios:</span>
                       BIOS
<span class="label">bridge:</span>
                       Qumranet Qemu virtual machine
                       Qumranet Qemu virtual machine
                       Qumranet Qemu virtual machine
<span class="label">hub:</span>
                       Linux <span class="number">2.6</span><span class="number">.32</span>-<span class="number">279.</span>el6<span class="preprocessor">.x</span>86_64 uhci_hcd UHCI Host Controller
<span class="label">memory:</span>
                       Main Memory
<span class="label">unknown:</span>
                       FPU
                       DMA controller
                       PIC
                       Timer
                       Keyboard controller
                       XenSource Xen Platform Device
[root@devops tmp]<span class="preprocessor">#</span>
</code></pre><p><strong>4. lspci</strong></p>
<p>lsppci命令可列出PCI总线的信息以及连接到PCI总线上的设备信息，比如VGA适配器、SATA控制器、其他模块等等。lspci工具是pciutils包的一部分，所以在安装lspci之前，你需要安装pciutils包。</p>
<p>安装pciutils包使用下面的命令：</p>
<pre><code>#yum install pciutils

[root@devops tmp]# yum install pciutils
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Setting up Install Process
Resolving Dependencies
-<span class="ruby">-&gt; <span class="constant">Running</span> transaction check
</span>-<span class="ruby">--&gt; <span class="constant">Package</span> pciutils.x86_64 <span class="number">0</span><span class="symbol">:</span><span class="number">3.1</span>.<span class="number">10</span>-<span class="number">2</span>.el6 will be installed
</span>-<span class="ruby">-&gt; <span class="constant">Processing</span> <span class="constant">Dependency</span><span class="symbol">:</span> pciutils-libs = <span class="number">3.1</span>.<span class="number">10</span>-<span class="number">2</span>.el6 <span class="keyword">for</span> <span class="symbol">package:</span> pciutils-<span class="number">3.1</span>.<span class="number">10</span>-<span class="number">2</span>.el6.x86_64
</span>-<span class="ruby">-&gt; <span class="constant">Running</span> transaction check
</span>-<span class="ruby">--&gt; <span class="constant">Package</span> pciutils-libs.x86_64 <span class="number">0</span><span class="symbol">:</span><span class="number">3.1</span>.<span class="number">4</span>-<span class="number">11</span>.el6 will be updated
</span>-<span class="ruby">--&gt; <span class="constant">Package</span> pciutils-libs.x86_64 <span class="number">0</span><span class="symbol">:</span><span class="number">3.1</span>.<span class="number">10</span>-<span class="number">2</span>.el6 will be an update
</span>-<span class="ruby">-&gt; <span class="constant">Finished</span> <span class="constant">Dependency</span> <span class="constant">Resolution</span>
</span>
Dependencies Resolved

Installing:
 pciutils                         x86_64                    3.1.10-2.el6               

      85 k
Updating for dependencies:
 pciutils-libs                    x86_64                    3.1.10-2.el6                 

      34 k

.....  

Dependency Updated:
  pciutils-libs.x86_64 0:3.1.10-2.el6                                                                            

Complete!
</code></pre><p>示例：</p>
<pre><code>[root<span class="variable">@devops</span> tmp]<span class="comment"># lspci </span>
<span class="number">00</span><span class="symbol">:</span><span class="number">00</span>.<span class="number">0</span> <span class="constant">Host</span> <span class="symbol">bridge:</span> <span class="constant">Intel</span> <span class="constant">Corporation</span> <span class="number">440</span>FX - <span class="number">82441</span>FX <span class="constant">PMC</span> [<span class="constant">Natoma</span>] (rev <span class="number">02</span>)
<span class="number">00</span><span class="symbol">:</span><span class="number">01</span>.<span class="number">0</span> <span class="constant">ISA</span> <span class="symbol">bridge:</span> <span class="constant">Intel</span> <span class="constant">Corporation</span> <span class="number">82371</span>SB <span class="constant">PIIX3</span> <span class="constant">ISA</span> [<span class="constant">Natoma</span>/<span class="constant">Triton</span> <span class="constant">II</span>]
<span class="number">00</span><span class="symbol">:</span><span class="number">01</span>.<span class="number">1</span> <span class="constant">IDE</span> <span class="symbol">interface:</span> <span class="constant">Intel</span> <span class="constant">Corporation</span> <span class="number">82371</span>SB <span class="constant">PIIX3</span> <span class="constant">IDE</span> [<span class="constant">Natoma</span>/<span class="constant">Triton</span> <span class="constant">II</span>]
<span class="number">00</span><span class="symbol">:</span><span class="number">01</span>.<span class="number">2</span> <span class="constant">USB</span> <span class="symbol">controller:</span> <span class="constant">Intel</span> <span class="constant">Corporation</span> <span class="number">82371</span>SB <span class="constant">PIIX3</span> <span class="constant">USB</span> [<span class="constant">Natoma</span>/<span class="constant">Triton</span> <span class="constant">II</span>] (rev <span class="number">01</span>)
<span class="number">00</span><span class="symbol">:</span><span class="number">01</span>.<span class="number">3</span> <span class="constant">Bridge</span><span class="symbol">:</span> <span class="constant">Intel</span> <span class="constant">Corporation</span> <span class="number">82371</span>AB/<span class="constant">EB</span>/<span class="constant">MB</span> <span class="constant">PIIX4</span> <span class="constant">ACPI</span> (rev <span class="number">01</span>)
<span class="number">00</span><span class="symbol">:</span><span class="number">02</span>.<span class="number">0</span> <span class="constant">VGA</span> compatible <span class="symbol">controller:</span> <span class="constant">Cirrus</span> <span class="constant">Logic</span> <span class="constant">GD</span> <span class="number">5446</span>
<span class="number">00</span><span class="symbol">:</span><span class="number">03</span>.<span class="number">0</span> <span class="constant">Unassigned</span> <span class="class"><span class="keyword">class</span> [<span class="title">ff80</span>]: <span class="title">XenSource</span>, <span class="title">Inc</span>. <span class="title">Xen</span> <span class="title">Platform</span> <span class="title">Device</span> (<span class="title">rev</span> 01)</span>
[root<span class="variable">@devops</span> tmp]<span class="comment">#</span>
</code></pre><p><strong>5. lsusb-列出USB总线信息</strong></p>
<p>这个命令可列出USB控制器的设备信息。</p>
<p>lsusb工具是usbutils包的一部分，所以你需要按照如下命令安装：</p>
<pre><code><span class="preprocessor">#yum install usbutils</span>

[root@devops tmp]<span class="preprocessor"># yum install usbutils</span>
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * extras: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
 * updates: mirrors<span class="preprocessor">.aliyun</span><span class="preprocessor">.com</span>
Setting up Install Process
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package usbutils<span class="preprocessor">.x</span>86_64 <span class="number">0</span>:<span class="number">003</span>-<span class="number">4.</span>el6 will be installed
--&gt; Processing Dependency: libusb-<span class="number">1.0</span><span class="preprocessor">.so</span><span class="number">.0</span>()(<span class="number">64</span>bit) for package: usbutils-<span class="number">003</span>-<span class="number">4.</span>el6<span class="preprocessor">.x</span>86_64
--&gt; Running transaction check
---&gt; Package libusb1<span class="preprocessor">.x</span>86_64 <span class="number">0</span>:<span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6 will be installed
--&gt; Finished Dependency Resolution

Dependencies Resolved

============================================

============
 Package                     Arch                      Version                              

      Size
=======================================================
============
<span class="label">Installing:</span>
 usbutils                    x86_64                    <span class="number">003</span>-<span class="number">4.</span>el6                                  

      <span class="number">71</span> k
Installing for dependencies:
 libusb1                     x86_64                    <span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6                      

      <span class="number">80</span> k

Transaction Summary
================================================================

============
Install       <span class="number">2</span> Package(s)

Total download size: <span class="number">152</span> k
Installed size: <span class="number">377</span> k
Is this ok [<span class="built_in">y</span>/N]: <span class="built_in">y</span>
Downloading Packages:
(<span class="number">1</span>/<span class="number">2</span>): libusb1-<span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6<span class="preprocessor">.x</span>86_64<span class="preprocessor">.rpm</span>                                                     

 <span class="number">00</span>:<span class="number">00</span>     
(<span class="number">2</span>/<span class="number">2</span>): usbutils-<span class="number">003</span>-<span class="number">4.</span>el6<span class="preprocessor">.x</span>86_64<span class="preprocessor">.rpm</span>                                               

 <span class="number">00</span>:<span class="number">00</span>     
--------------------------------------------------------

------------
Total                                                                                     

 <span class="number">00</span>:<span class="number">00</span>     
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : libusb1-<span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6<span class="preprocessor">.x</span>86_64                                                                  

       <span class="number">1</span>/<span class="number">2</span> 
  Installing : usbutils-<span class="number">003</span>-<span class="number">4.</span>el6<span class="preprocessor">.x</span>86_64                                                                         

       <span class="number">2</span>/<span class="number">2</span> 
  Verifying  : usbutils-<span class="number">003</span>-<span class="number">4.</span>el6<span class="preprocessor">.x</span>86_64                                                                         

       <span class="number">1</span>/<span class="number">2</span> 
  Verifying  : libusb1-<span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6<span class="preprocessor">.x</span>86_64                                                                  

       <span class="number">2</span>/<span class="number">2</span> 

<span class="label">Installed:</span>
  usbutils<span class="preprocessor">.x</span>86_64 <span class="number">0</span>:<span class="number">003</span>-<span class="number">4.</span>el6                                                                                    

Dependency Installed:
  libusb1<span class="preprocessor">.x</span>86_64 <span class="number">0</span>:<span class="number">1.0</span><span class="number">.9</span>-<span class="number">0.6</span><span class="preprocessor">.rc</span>1<span class="preprocessor">.el</span>6                                                                             

Complete!
</code></pre><p>示例：</p>
<pre><code>[root<span class="variable">@devops</span> tmp]<span class="comment"># lsusb</span>
<span class="constant">Bus</span> <span class="number">001</span> <span class="constant">Device</span> <span class="number">001</span><span class="symbol">:</span> <span class="constant">ID</span> <span class="number">1</span><span class="symbol">d6b:</span><span class="number">0001</span> <span class="constant">Linux</span> <span class="constant">Foundation</span> <span class="number">1.1</span> root hub
<span class="constant">Bus</span> <span class="number">001</span> <span class="constant">Device</span> <span class="number">002</span><span class="symbol">:</span> <span class="constant">ID</span> <span class="number">0627</span><span class="symbol">:</span><span class="number">0001</span> <span class="constant">Adomax</span> <span class="constant">Technology</span> <span class="constant">Co</span>., <span class="constant">Ltd</span> 
[root<span class="variable">@devops</span> tmp]<span class="comment">#</span>
</code></pre><p><strong>6. lsblk-列出块设备的信息</strong></p>
<pre><code>[root<span class="variable">@devops</span> tmp]<span class="comment"># lsblk</span>
<span class="constant">NAME</span>    <span class="constant">MAJ</span><span class="symbol">:MIN</span> <span class="constant">RM</span>   <span class="constant">SIZE</span> <span class="constant">RO</span> <span class="constant">TYPE</span> <span class="constant">MOUNTPOINT</span>
xvda    <span class="number">202</span><span class="symbol">:</span><span class="number">0</span>    <span class="number">0</span>    <span class="number">20</span>G  <span class="number">0</span> disk 
└─xvda1 <span class="number">202</span><span class="symbol">:</span><span class="number">1</span>    <span class="number">0</span>    <span class="number">20</span>G  <span class="number">0</span> part /
xvdb    <span class="number">202</span><span class="symbol">:</span><span class="number">16</span>   <span class="number">0</span>    <span class="number">10</span>G  <span class="number">0</span> disk 
└─xvdb1 <span class="number">202</span><span class="symbol">:</span><span class="number">17</span>   <span class="number">0</span>    <span class="number">10</span>G  <span class="number">0</span> part /alidata
sr<span class="number">0</span>      <span class="number">11</span><span class="symbol">:</span><span class="number">0</span>    <span class="number">1</span>   <span class="number">362</span>K  <span class="number">0</span> rom
</code></pre><p><strong>7. lsscsi-列出SCSI的设备信息</strong></p>
<p>列出SCSI/SDAT设备的信息，比如硬盘驱动器、光盘驱动器。</p>
<pre><code>[root<span class="variable">@devops</span> tmp]<span class="comment"># lsscsi</span>
[<span class="number">1</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span>]    cd/dvd  <span class="constant">QEMU</span>     <span class="constant">QEMU</span> <span class="constant">DVD</span>-<span class="constant">ROM</span>     <span class="number">0</span>.<span class="number">10</span>  /dev/sr<span class="number">0</span> 
[root<span class="variable">@devops</span> tmp]<span class="comment">#</span>
</code></pre><p>完毕！Enjoy this！</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/introduction-to-mou/">
  <time datetime="2014-05-14T08:23:12.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/introduction-to-mou/"></a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="Mou">Mou</h1>
<p><img src="http://mouapp.com/Mou_128.png" alt="Mou icon"></p>
<h2 id="Overview">Overview</h2>
<p><strong>Mou</strong>, the missing Markdown editor for <em>web developers</em>.</p>

    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/2014/05/14/introduction-to-mou/#more" class="more-link">阅读全文</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/漫画：如果用编程语言来写作文/">
  <time datetime="2014-05-14T08:02:40.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/漫画：如果用编程语言来写作文/">漫画：如果用编程语言来写作文</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>如果说这世界上有一种东西太多了，那它就是广告。如果说这世界上还有另外一种东西太多了，那就是对软件开发的类比。</p>
<p>这是《软件开发如同越狱》这篇文章里的一段话，说的不假，人们喜欢拿编程语言说事儿，但可惜这篇文章的这个类比的并不形象。不过也有好的类比，比如《如果编程语言是一条船… 》，这篇文章就很有意思，而且还配了图。今天的这个漫画书有点纯搞笑的意思了，用编程语言来写作文，会写出什么效果？看看老师的反应就知道了。</p>
<p><img src="http://waakaakaa.qiniudn.com/10070749_5T5H.png" alt="image"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/05/14/单个-c-文件实现的-web-服务器/">
  <time datetime="2014-05-14T07:58:31.000Z">
    5月 14 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/05/14/单个-c-文件实现的-web-服务器/">单个 C 文件实现的 Web 服务器</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>/*</p>
<pre><code> * WebServer.c
 *
 *  Created on: Nov <span class="number">3</span>, <span class="number">2012</span>
 *      Author: pavithra
 *
 * A web server in C language <span class="keyword">using</span> only the standard libraries.
 * The port number is passed as an argument.
 *
 */

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>

<span class="preprocessor">#define EOL "\r\n"</span>
<span class="preprocessor">#define EOL_SIZE 2</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span> {
 <span class="keyword">char</span> *ext;
 <span class="keyword">char</span> *mediatype;
} extn;

<span class="comment">//Possible media types</span>
extn extensions[] ={
 {<span class="string">"gif"</span>, <span class="string">"image/gif"</span> },
 {<span class="string">"txt"</span>, <span class="string">"text/plain"</span> },
 {<span class="string">"jpg"</span>, <span class="string">"image/jpg"</span> },
 {<span class="string">"jpeg"</span>,<span class="string">"image/jpeg"</span>},
 {<span class="string">"png"</span>, <span class="string">"image/png"</span> },
 {<span class="string">"ico"</span>, <span class="string">"image/ico"</span> },
 {<span class="string">"zip"</span>, <span class="string">"image/zip"</span> },
 {<span class="string">"gz"</span>,  <span class="string">"image/gz"</span>  },
 {<span class="string">"tar"</span>, <span class="string">"image/tar"</span> },
 {<span class="string">"htm"</span>, <span class="string">"text/html"</span> },
 {<span class="string">"html"</span>,<span class="string">"text/html"</span> },
 {<span class="string">"php"</span>, <span class="string">"text/html"</span> },
 {<span class="string">"pdf"</span>,<span class="string">"application/pdf"</span>},
 {<span class="string">"zip"</span>,<span class="string">"application/octet-stream"</span>},
 {<span class="string">"rar"</span>,<span class="string">"application/octet-stream"</span>},
 {<span class="number">0</span>,<span class="number">0</span>} };

<span class="comment">/*
 A helper function
 */</span>
<span class="keyword">void</span> error(<span class="keyword">const</span> <span class="keyword">char</span> *msg) {
 perror(msg);
 <span class="built_in">exit</span>(<span class="number">1</span>);
}

<span class="comment">/*
 A helper function
 */</span>
<span class="keyword">int</span> get_file_size(<span class="keyword">int</span> fd) {
 <span class="keyword">struct</span> stat stat_struct;
 <span class="keyword">if</span> (fstat(fd, &amp;stat_struct) == -<span class="number">1</span>)
  <span class="keyword">return</span> (<span class="number">1</span>);
 <span class="keyword">return</span> (<span class="keyword">int</span>) stat_struct.st_size;
}

<span class="comment">/*
 A helper function
 */</span>
<span class="keyword">void</span> send_new(<span class="keyword">int</span> fd, <span class="keyword">char</span> *msg) {
 <span class="keyword">int</span> len = <span class="built_in">strlen</span>(msg);
 <span class="keyword">if</span> (send(fd, msg, len, <span class="number">0</span>) == -<span class="number">1</span>) {
  <span class="built_in">printf</span>(<span class="string">"Error in send\n"</span>);
 }
}

<span class="comment">/*
 This function recieves the buffer
 until an "End of line(EOL)" byte is recieved
 */</span>
<span class="keyword">int</span> recv_new(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer) {
 <span class="keyword">char</span> *p = buffer; <span class="comment">// Use of a pointer to the buffer rather than dealing with the buffer directly</span>
 <span class="keyword">int</span> eol_matched = <span class="number">0</span>; <span class="comment">// Use to check whether the recieved byte is matched with the buffer byte or not</span>
 <span class="keyword">while</span> (recv(fd, p, <span class="number">1</span>, <span class="number">0</span>) != <span class="number">0</span>) <span class="comment">// Start receiving 1 byte at a time</span>
 {
  <span class="keyword">if</span> (*p == EOL[eol_matched]) <span class="comment">// if the byte matches with the first eol byte that is '\r'</span>
    {
   ++eol_matched;
   <span class="keyword">if</span> (eol_matched == EOL_SIZE) <span class="comment">// if both the bytes matches with the EOL</span>
   {
    *(p + <span class="number">1</span> - EOL_SIZE) = <span class="string">'\0'</span>; <span class="comment">// End the string</span>
    <span class="keyword">return</span> (<span class="built_in">strlen</span>(buffer)); <span class="comment">// Return the bytes recieved</span>
   }
  } <span class="keyword">else</span> {
   eol_matched = <span class="number">0</span>;
  }
  p++; <span class="comment">// Increment the pointer to receive next byte</span>
 }
 <span class="keyword">return</span> (<span class="number">0</span>);
}

<span class="comment">/*
 A helper function: Returns the
 web root location.
 */</span>
<span class="keyword">char</span>* webroot() {
 <span class="comment">// open the file "conf" for reading</span>
 FILE *in = fopen(<span class="string">"conf"</span>, <span class="string">"rt"</span>);
 <span class="comment">// read the first line from the file</span>
 <span class="keyword">char</span> buff[<span class="number">1000</span>];
 fgets(buff, <span class="number">1000</span>, in);
 <span class="comment">// close the stream</span>
 fclose(in);
 <span class="keyword">char</span>* nl_ptr = <span class="built_in">strrchr</span>(buff, <span class="string">'\n'</span>);
 <span class="keyword">if</span> (nl_ptr != NULL)
  *nl_ptr = <span class="string">'\0'</span>;
 <span class="keyword">return</span> strdup(buff);
}

<span class="comment">/*
 Handles php requests
 */</span>
<span class="keyword">void</span> php_cgi(<span class="keyword">char</span>* script_path, <span class="keyword">int</span> fd) {
 send_new(fd, <span class="string">"HTTP/1.1 200 OK\n Server: Web Server in C\n Connection: close\n"</span>);
 dup2(fd, STDOUT_FILENO);
 <span class="keyword">char</span> script[<span class="number">500</span>];
 <span class="built_in">strcpy</span>(script, <span class="string">"SCRIPT_FILENAME="</span>);
 <span class="built_in">strcat</span>(script, script_path);
 putenv(<span class="string">"GATEWAY_INTERFACE=CGI/1.1"</span>);
 putenv(script);
 putenv(<span class="string">"QUERY_STRING="</span>);
 putenv(<span class="string">"REQUEST_METHOD=GET"</span>);
 putenv(<span class="string">"REDIRECT_STATUS=true"</span>);
 putenv(<span class="string">"SERVER_PROTOCOL=HTTP/1.1"</span>);
 putenv(<span class="string">"REMOTE_HOST=127.0.0.1"</span>);
 execl(<span class="string">"/usr/bin/php-cgi"</span>, <span class="string">"php-cgi"</span>, NULL);
}

<span class="comment">/*
 This function parses the HTTP requests,
 arrange resource locations,
 check for supported media types,
 serves files in a web root,
 sends the HTTP error codes.
 */</span>
<span class="keyword">int</span> connection(<span class="keyword">int</span> fd) {
 <span class="keyword">char</span> request[<span class="number">500</span>], resource[<span class="number">500</span>], *ptr;
 <span class="keyword">int</span> fd1, length;
 <span class="keyword">if</span> (recv_new(fd, request) == <span class="number">0</span>) {
  <span class="built_in">printf</span>(<span class="string">"Recieve Failed\n"</span>);
 }
 <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, request);
 <span class="comment">// Check for a valid browser request</span>
 ptr = <span class="built_in">strstr</span>(request, <span class="string">" HTTP/"</span>);
 <span class="keyword">if</span> (ptr == NULL) {
  <span class="built_in">printf</span>(<span class="string">"NOT HTTP !\n"</span>);
 } <span class="keyword">else</span> {
  *ptr = <span class="number">0</span>;
  ptr = NULL;

  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(request, <span class="string">"GET "</span>, <span class="number">4</span>) == <span class="number">0</span>) {
   ptr = request + <span class="number">4</span>;
  }
  <span class="keyword">if</span> (ptr == NULL) {
   <span class="built_in">printf</span>(<span class="string">"Unknown Request ! \n"</span>);
  } <span class="keyword">else</span> {
   <span class="keyword">if</span> (ptr[<span class="built_in">strlen</span>(ptr) - <span class="number">1</span>] == <span class="string">'/'</span>) {
    <span class="built_in">strcat</span>(ptr, <span class="string">"index.html"</span>);
   }
   <span class="built_in">strcpy</span>(resource, webroot());
   <span class="built_in">strcat</span>(resource, ptr);
   <span class="keyword">char</span>* s = <span class="built_in">strchr</span>(ptr, <span class="string">'.'</span>);
   <span class="keyword">int</span> i;
   <span class="keyword">for</span> (i = <span class="number">0</span>; extensions[i].ext != NULL; i++) {
    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s + <span class="number">1</span>, extensions[i].ext) == <span class="number">0</span>) {
     fd1 = open(resource, O_RDONLY, <span class="number">0</span>);
     <span class="built_in">printf</span>(<span class="string">"Opening \"%s\"\n"</span>, resource);
     <span class="keyword">if</span> (fd1 == -<span class="number">1</span>) {
      <span class="built_in">printf</span>(<span class="string">"404 File not found Error\n"</span>);
      send_new(fd, <span class="string">"HTTP/1.1 404 Not Found\r\n"</span>);
      send_new(fd, <span class="string">"Server : Web Server in C\r\n\r\n"</span>);
      send_new(fd, <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/head&gt;&lt;/title&gt;"</span>);
      send_new(fd, <span class="string">"&lt;body&gt;&lt;p&gt;404 Not Found: The requested resource could not be found!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>);
      <span class="comment">//Handling php requests</span>
     } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extensions[i].ext, <span class="string">"php"</span>) == <span class="number">0</span>) {
      php_cgi(resource, fd);
      sleep(<span class="number">1</span>);
      close(fd);
      <span class="built_in">exit</span>(<span class="number">1</span>);
     } <span class="keyword">else</span> {
      <span class="built_in">printf</span>(<span class="string">"200 OK, Content-Type: %s\n\n"</span>,
        extensions[i].mediatype);
      send_new(fd, <span class="string">"HTTP/1.1 200 OK\r\n"</span>);
      send_new(fd, <span class="string">"Server : Web Server in C\r\n\r\n"</span>);
      <span class="keyword">if</span> (ptr == request + <span class="number">4</span>) <span class="comment">// if it is a GET request</span>
        {
       <span class="keyword">if</span> ((length = get_file_size(fd1)) == -<span class="number">1</span>)
        <span class="built_in">printf</span>(<span class="string">"Error in getting size !\n"</span>);
       size_t total_bytes_sent = <span class="number">0</span>;
       ssize_t bytes_sent;
       <span class="keyword">while</span> (total_bytes_sent &lt; length) {
        <span class="comment">//Zero copy optimization</span>
        <span class="keyword">if</span> ((bytes_sent = sendfile(fd, fd1, <span class="number">0</span>,
          length - total_bytes_sent)) &lt;= <span class="number">0</span>) {
         <span class="keyword">if</span> (errno == EINTR || errno == EAGAIN) {
          <span class="keyword">continue</span>;
         }
         perror(<span class="string">"sendfile"</span>);
         <span class="keyword">return</span> -<span class="number">1</span>;
        }
        total_bytes_sent += bytes_sent;
       }

      }
     }
     <span class="keyword">break</span>;
    }
    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(extensions) / <span class="keyword">sizeof</span>(extensions[<span class="number">0</span>]);
    <span class="keyword">if</span> (i == size - <span class="number">2</span>) {
     <span class="built_in">printf</span>(<span class="string">"415 Unsupported Media Type\n"</span>);
     send_new(fd, <span class="string">"HTTP/1.1 415 Unsupported Media Type\r\n"</span>);
     send_new(fd, <span class="string">"Server : Web Server in C\r\n\r\n"</span>);
     send_new(fd, <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;415 Unsupported Media Type&lt;/head&gt;&lt;/title&gt;"</span>);
     send_new(fd, <span class="string">"&lt;body&gt;&lt;p&gt;415 Unsupported Media Type!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>);
    }
   }

   close(fd);
  }
 }
 shutdown(fd, SHUT_RDWR);
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {
 <span class="keyword">int</span> sockfd, newsockfd, portno, pid;
 socklen_t clilen;
 <span class="keyword">struct</span> sockaddr_in serv_addr, cli_addr;

 <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {
  <span class="built_in">fprintf</span>(stderr, <span class="string">"ERROR, no port provided\n"</span>);
  <span class="built_in">exit</span>(<span class="number">1</span>);
 }
 sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);
 <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)
  error(<span class="string">"ERROR opening socket"</span>);
 bzero((<span class="keyword">char</span> *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));
 portno = atoi(argv[<span class="number">1</span>]);
 serv_addr.sin_family = AF_INET;
 serv_addr.sin_addr.s_addr = INADDR_ANY;
 serv_addr.sin_port = htons(portno);
 <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>)
  error(<span class="string">"ERROR on binding"</span>);
 listen(sockfd, <span class="number">5</span>);
 clilen = <span class="keyword">sizeof</span>(cli_addr);
 <span class="comment">/*
  Server runs forever, forking off a separate
  process for each connection.
  */</span>
 <span class="keyword">while</span> (<span class="number">1</span>) {
  newsockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;cli_addr, &amp;clilen);
  <span class="keyword">if</span> (newsockfd &lt; <span class="number">0</span>)
   error(<span class="string">"ERROR on accept"</span>);
  pid = fork();
  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)
   error(<span class="string">"ERROR on fork"</span>);
  <span class="keyword">if</span> (pid == <span class="number">0</span>) {
   close(sockfd);
   connection(newsockfd);
   <span class="built_in">exit</span>(<span class="number">0</span>);
  } <span class="keyword">else</span>
   close(newsockfd);
 } <span class="comment">/* end of while */</span>
 close(sockfd);
 <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* we never get here */</span>
}
</code></pre>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2014 <a href="/">Xin Zhang</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>